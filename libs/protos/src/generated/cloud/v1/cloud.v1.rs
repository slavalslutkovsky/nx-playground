// @generated
// This file is @generated by prost-build.
/// Money representation with precision
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Money {
    /// Amount in smallest currency unit (cents for USD)
    #[prost(int64, tag="1")]
    pub amount: i64,
    #[prost(enumeration="Currency", tag="2")]
    pub currency: i32,
    /// Number of decimal places (2 for cents)
    #[prost(int32, tag="3")]
    pub decimal_places: i32,
}
/// Time range for queries and reports
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TimeRange {
    /// Unix timestamp in seconds
    #[prost(int64, tag="1")]
    pub start_timestamp: i64,
    #[prost(int64, tag="2")]
    pub end_timestamp: i64,
}
/// Region information
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Region {
    /// e.g., "us-east-1", "eastus", "us-central1"
    #[prost(string, tag="1")]
    pub code: ::prost::alloc::string::String,
    /// e.g., "US East (N. Virginia)"
    #[prost(string, tag="2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(enumeration="CloudProvider", tag="3")]
    pub provider: i32,
}
/// Pagination for list requests
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Pagination {
    #[prost(int32, tag="1")]
    pub limit: i32,
    #[prost(int32, tag="2")]
    pub offset: i32,
}
/// Resource identifier across clouds
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResourceIdentifier {
    #[prost(enumeration="CloudProvider", tag="1")]
    pub provider: i32,
    /// Provider-specific ID
    #[prost(string, tag="2")]
    pub resource_id: ::prost::alloc::string::String,
    #[prost(enumeration="ResourceType", tag="3")]
    pub resource_type: i32,
    #[prost(string, tag="4")]
    pub region: ::prost::alloc::string::String,
    /// AWS account, Azure subscription, GCP project
    #[prost(string, tag="5")]
    pub account_id: ::prost::alloc::string::String,
}
/// Cloud provider enumeration
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CloudProvider {
    Unspecified = 0,
    Aws = 1,
    Azure = 2,
    Gcp = 3,
}
impl CloudProvider {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CLOUD_PROVIDER_UNSPECIFIED",
            Self::Aws => "AWS",
            Self::Azure => "AZURE",
            Self::Gcp => "GCP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CLOUD_PROVIDER_UNSPECIFIED" => Some(Self::Unspecified),
            "AWS" => Some(Self::Aws),
            "AZURE" => Some(Self::Azure),
            "GCP" => Some(Self::Gcp),
            _ => None,
        }
    }
}
/// Resource type enumeration
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ResourceType {
    Unspecified = 0,
    /// VMs, instances
    Compute = 1,
    /// Object storage, block storage
    Storage = 2,
    /// RDS, Cloud SQL, etc.
    Database = 3,
    /// Load balancers, VPNs, etc.
    Network = 4,
    /// Lambda, Cloud Functions, etc.
    Serverless = 5,
    /// BigQuery, Redshift, etc.
    Analytics = 6,
    /// EKS, AKS, GKE
    Kubernetes = 7,
    Other = 8,
}
impl ResourceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "RESOURCE_TYPE_UNSPECIFIED",
            Self::Compute => "COMPUTE",
            Self::Storage => "STORAGE",
            Self::Database => "DATABASE",
            Self::Network => "NETWORK",
            Self::Serverless => "SERVERLESS",
            Self::Analytics => "ANALYTICS",
            Self::Kubernetes => "KUBERNETES",
            Self::Other => "OTHER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RESOURCE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "COMPUTE" => Some(Self::Compute),
            "STORAGE" => Some(Self::Storage),
            "DATABASE" => Some(Self::Database),
            "NETWORK" => Some(Self::Network),
            "SERVERLESS" => Some(Self::Serverless),
            "ANALYTICS" => Some(Self::Analytics),
            "KUBERNETES" => Some(Self::Kubernetes),
            "OTHER" => Some(Self::Other),
            _ => None,
        }
    }
}
/// Pricing unit enumeration
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PricingUnit {
    Unspecified = 0,
    Hour = 1,
    Month = 2,
    Gb = 3,
    GbHour = 4,
    GbMonth = 5,
    Request = 6,
    MillionRequests = 7,
    Second = 8,
    Unit = 9,
}
impl PricingUnit {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PRICING_UNIT_UNSPECIFIED",
            Self::Hour => "HOUR",
            Self::Month => "MONTH",
            Self::Gb => "GB",
            Self::GbHour => "GB_HOUR",
            Self::GbMonth => "GB_MONTH",
            Self::Request => "REQUEST",
            Self::MillionRequests => "MILLION_REQUESTS",
            Self::Second => "SECOND",
            Self::Unit => "UNIT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PRICING_UNIT_UNSPECIFIED" => Some(Self::Unspecified),
            "HOUR" => Some(Self::Hour),
            "MONTH" => Some(Self::Month),
            "GB" => Some(Self::Gb),
            "GB_HOUR" => Some(Self::GbHour),
            "GB_MONTH" => Some(Self::GbMonth),
            "REQUEST" => Some(Self::Request),
            "MILLION_REQUESTS" => Some(Self::MillionRequests),
            "SECOND" => Some(Self::Second),
            "UNIT" => Some(Self::Unit),
            _ => None,
        }
    }
}
/// Currency enumeration
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Currency {
    Unspecified = 0,
    Usd = 1,
    Eur = 2,
    Gbp = 3,
}
impl Currency {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CURRENCY_UNSPECIFIED",
            Self::Usd => "USD",
            Self::Eur => "EUR",
            Self::Gbp => "GBP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CURRENCY_UNSPECIFIED" => Some(Self::Unspecified),
            "USD" => Some(Self::Usd),
            "EUR" => Some(Self::Eur),
            "GBP" => Some(Self::Gbp),
            _ => None,
        }
    }
}
/// Collection job
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CollectionJob {
    #[prost(bytes="vec", tag="1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration="CollectionJobType", tag="2")]
    pub r#type: i32,
    #[prost(enumeration="CollectionJobStatus", tag="3")]
    pub status: i32,
    #[prost(enumeration="CloudProvider", repeated, tag="4")]
    pub providers: ::prost::alloc::vec::Vec<i32>,
    #[prost(enumeration="ResourceType", repeated, tag="5")]
    pub resource_types: ::prost::alloc::vec::Vec<i32>,
    #[prost(string, repeated, tag="6")]
    pub regions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag="7")]
    pub started_at: i64,
    #[prost(int64, optional, tag="8")]
    pub completed_at: ::core::option::Option<i64>,
    #[prost(message, optional, tag="9")]
    pub progress: ::core::option::Option<CollectionJobProgress>,
    #[prost(string, optional, tag="10")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="11")]
    pub metrics: ::core::option::Option<CollectionJobMetrics>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CollectionJobProgress {
    #[prost(int32, tag="1")]
    pub total_tasks: i32,
    #[prost(int32, tag="2")]
    pub completed_tasks: i32,
    #[prost(int32, tag="3")]
    pub failed_tasks: i32,
    #[prost(string, tag="4")]
    pub current_task: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CollectionJobMetrics {
    #[prost(int64, tag="1")]
    pub prices_collected: i64,
    #[prost(int64, tag="2")]
    pub resources_discovered: i64,
    #[prost(int64, tag="3")]
    pub prices_updated: i64,
    #[prost(int64, tag="4")]
    pub prices_unchanged: i64,
    #[prost(int64, tag="5")]
    pub duration_ms: i64,
}
/// Trigger collection request
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TriggerPriceCollectionRequest {
    #[prost(enumeration="CollectionJobType", tag="1")]
    pub r#type: i32,
    /// Empty = all configured providers
    #[prost(enumeration="CloudProvider", repeated, tag="2")]
    pub providers: ::prost::alloc::vec::Vec<i32>,
    /// Empty = all types
    #[prost(enumeration="ResourceType", repeated, tag="3")]
    pub resource_types: ::prost::alloc::vec::Vec<i32>,
    /// Empty = all configured regions
    #[prost(string, repeated, tag="4")]
    pub regions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Force collection even if recent data exists
    #[prost(bool, tag="5")]
    pub force: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TriggerPriceCollectionResponse {
    #[prost(message, optional, tag="1")]
    pub job: ::core::option::Option<CollectionJob>,
}
/// Get collection status
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetCollectionStatusRequest {
    #[prost(bytes="vec", tag="1")]
    pub job_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetCollectionStatusResponse {
    #[prost(message, optional, tag="1")]
    pub job: ::core::option::Option<CollectionJob>,
}
/// List collection jobs
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListCollectionJobsRequest {
    #[prost(enumeration="CollectionJobStatus", optional, tag="1")]
    pub status: ::core::option::Option<i32>,
    #[prost(enumeration="CollectionJobType", optional, tag="2")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(message, optional, tag="3")]
    pub time_range: ::core::option::Option<TimeRange>,
    #[prost(message, optional, tag="4")]
    pub pagination: ::core::option::Option<Pagination>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCollectionJobsResponse {
    #[prost(message, repeated, tag="1")]
    pub jobs: ::prost::alloc::vec::Vec<CollectionJob>,
    #[prost(int32, tag="2")]
    pub total_count: i32,
}
/// Resource inventory item (from Crossplane)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InventoryItem {
    #[prost(message, optional, tag="1")]
    pub resource: ::core::option::Option<ResourceIdentifier>,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    /// Crossplane resource status
    #[prost(string, tag="3")]
    pub status: ::prost::alloc::string::String,
    #[prost(map="string, string", tag="4")]
    pub labels: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(map="string, string", tag="5")]
    pub annotations: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(message, optional, tag="6")]
    pub spec: ::core::option::Option<ResourceSpec>,
    #[prost(int64, tag="7")]
    pub created_at: i64,
    #[prost(int64, tag="8")]
    pub last_synced_at: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceSpec {
    #[prost(string, tag="1")]
    pub instance_type: ::prost::alloc::string::String,
    #[prost(int32, optional, tag="2")]
    pub vcpus: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="3")]
    pub memory_gb: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="4")]
    pub storage_gb: ::core::option::Option<i32>,
    #[prost(map="string, string", tag="5")]
    pub additional_specs: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Get inventory request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInventoryRequest {
    #[prost(enumeration="CloudProvider", optional, tag="1")]
    pub provider: ::core::option::Option<i32>,
    #[prost(enumeration="ResourceType", repeated, tag="2")]
    pub resource_types: ::prost::alloc::vec::Vec<i32>,
    #[prost(string, repeated, tag="3")]
    pub regions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(map="string, string", tag="4")]
    pub label_selector: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(message, optional, tag="5")]
    pub pagination: ::core::option::Option<Pagination>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInventoryResponse {
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<InventoryItem>,
    #[prost(int32, tag="2")]
    pub total_count: i32,
}
/// Stream inventory changes
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamInventoryChangesRequest {
    #[prost(enumeration="CloudProvider", optional, tag="1")]
    pub provider: ::core::option::Option<i32>,
    #[prost(enumeration="ResourceType", repeated, tag="2")]
    pub resource_types: ::prost::alloc::vec::Vec<i32>,
    #[prost(map="string, string", tag="3")]
    pub label_selector: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InventoryChange {
    #[prost(message, optional, tag="1")]
    pub item: ::core::option::Option<InventoryItem>,
    #[prost(enumeration="InventoryChangeType", tag="2")]
    pub change_type: i32,
    #[prost(message, optional, tag="3")]
    pub previous_state: ::core::option::Option<InventoryItem>,
}
/// Collection schedule
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CollectionSchedule {
    #[prost(bytes="vec", tag="1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    /// e.g., "0 */6 * * *" (every 6 hours)
    #[prost(string, tag="3")]
    pub cron_expression: ::prost::alloc::string::String,
    #[prost(enumeration="CollectionJobType", tag="4")]
    pub job_type: i32,
    #[prost(enumeration="CloudProvider", repeated, tag="5")]
    pub providers: ::prost::alloc::vec::Vec<i32>,
    #[prost(enumeration="ResourceType", repeated, tag="6")]
    pub resource_types: ::prost::alloc::vec::Vec<i32>,
    #[prost(string, repeated, tag="7")]
    pub regions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag="8")]
    pub enabled: bool,
    #[prost(int64, optional, tag="9")]
    pub last_run_at: ::core::option::Option<i64>,
    #[prost(int64, optional, tag="10")]
    pub next_run_at: ::core::option::Option<i64>,
}
/// Get collection schedule
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetCollectionScheduleRequest {
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCollectionScheduleResponse {
    #[prost(message, repeated, tag="1")]
    pub schedules: ::prost::alloc::vec::Vec<CollectionSchedule>,
}
/// Update collection schedule
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateCollectionScheduleRequest {
    #[prost(bytes="vec", tag="1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, optional, tag="2")]
    pub cron_expression: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag="3")]
    pub enabled: ::core::option::Option<bool>,
    #[prost(enumeration="CloudProvider", repeated, tag="4")]
    pub providers: ::prost::alloc::vec::Vec<i32>,
    #[prost(enumeration="ResourceType", repeated, tag="5")]
    pub resource_types: ::prost::alloc::vec::Vec<i32>,
    #[prost(string, repeated, tag="6")]
    pub regions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateCollectionScheduleResponse {
    #[prost(message, optional, tag="1")]
    pub schedule: ::core::option::Option<CollectionSchedule>,
}
/// Collection job status
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CollectionJobStatus {
    Unspecified = 0,
    Pending = 1,
    Running = 2,
    Completed = 3,
    Failed = 4,
    Cancelled = 5,
}
impl CollectionJobStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "COLLECTION_JOB_STATUS_UNSPECIFIED",
            Self::Pending => "COLLECTION_JOB_STATUS_PENDING",
            Self::Running => "COLLECTION_JOB_STATUS_RUNNING",
            Self::Completed => "COLLECTION_JOB_STATUS_COMPLETED",
            Self::Failed => "COLLECTION_JOB_STATUS_FAILED",
            Self::Cancelled => "COLLECTION_JOB_STATUS_CANCELLED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COLLECTION_JOB_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "COLLECTION_JOB_STATUS_PENDING" => Some(Self::Pending),
            "COLLECTION_JOB_STATUS_RUNNING" => Some(Self::Running),
            "COLLECTION_JOB_STATUS_COMPLETED" => Some(Self::Completed),
            "COLLECTION_JOB_STATUS_FAILED" => Some(Self::Failed),
            "COLLECTION_JOB_STATUS_CANCELLED" => Some(Self::Cancelled),
            _ => None,
        }
    }
}
/// Collection job type
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CollectionJobType {
    Unspecified = 0,
    /// Collect pricing data
    Pricing = 1,
    /// Collect resource inventory
    Inventory = 2,
    /// Both pricing and inventory
    Full = 3,
}
impl CollectionJobType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "COLLECTION_JOB_TYPE_UNSPECIFIED",
            Self::Pricing => "PRICING",
            Self::Inventory => "INVENTORY",
            Self::Full => "FULL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COLLECTION_JOB_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "PRICING" => Some(Self::Pricing),
            "INVENTORY" => Some(Self::Inventory),
            "FULL" => Some(Self::Full),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InventoryChangeType {
    Unspecified = 0,
    Created = 1,
    Updated = 2,
    Deleted = 3,
}
impl InventoryChangeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "INVENTORY_CHANGE_TYPE_UNSPECIFIED",
            Self::Created => "CREATED",
            Self::Updated => "UPDATED",
            Self::Deleted => "DELETED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INVENTORY_CHANGE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "CREATED" => Some(Self::Created),
            "UPDATED" => Some(Self::Updated),
            "DELETED" => Some(Self::Deleted),
            _ => None,
        }
    }
}
/// Optimization recommendation
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Recommendation {
    #[prost(bytes="vec", tag="1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag="2")]
    pub resource: ::core::option::Option<ResourceIdentifier>,
    #[prost(enumeration="RecommendationType", tag="3")]
    pub r#type: i32,
    #[prost(enumeration="RecommendationPriority", tag="4")]
    pub priority: i32,
    #[prost(enumeration="RecommendationStatus", tag="5")]
    pub status: i32,
    #[prost(string, tag="6")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag="7")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag="8")]
    pub estimated_monthly_savings: ::core::option::Option<Money>,
    /// 0.0 - 1.0
    #[prost(double, tag="9")]
    pub confidence_score: f64,
    #[prost(message, repeated, tag="10")]
    pub actions: ::prost::alloc::vec::Vec<RecommendationAction>,
    #[prost(message, optional, tag="11")]
    pub impact: ::core::option::Option<RecommendationImpact>,
    #[prost(int64, tag="12")]
    pub created_at: i64,
    #[prost(int64, tag="13")]
    pub updated_at: i64,
    #[prost(int64, optional, tag="14")]
    pub expires_at: ::core::option::Option<i64>,
    #[prost(map="string, string", tag="15")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Action to implement recommendation
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecommendationAction {
    #[prost(int32, tag="1")]
    pub order: i32,
    /// e.g., "resize", "terminate", "purchase"
    #[prost(string, tag="2")]
    pub action_type: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub description: ::prost::alloc::string::String,
    #[prost(map="string, string", tag="4")]
    pub parameters: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(bool, tag="5")]
    pub reversible: bool,
}
/// Impact assessment
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RecommendationImpact {
    #[prost(enumeration="ImpactLevel", tag="1")]
    pub performance_impact: i32,
    #[prost(enumeration="ImpactLevel", tag="2")]
    pub availability_impact: i32,
    #[prost(enumeration="ImpactLevel", tag="3")]
    pub security_impact: i32,
    #[prost(string, tag="4")]
    pub risk_summary: ::prost::alloc::string::String,
}
/// Current resource details for recommendation context
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CurrentResourceDetails {
    #[prost(string, tag="1")]
    pub instance_type: ::prost::alloc::string::String,
    #[prost(int32, tag="2")]
    pub vcpus: i32,
    #[prost(int32, tag="3")]
    pub memory_gb: i32,
    #[prost(double, tag="4")]
    pub avg_cpu_utilization: f64,
    #[prost(double, tag="5")]
    pub avg_memory_utilization: f64,
    #[prost(message, optional, tag="6")]
    pub current_monthly_cost: ::core::option::Option<Money>,
}
/// Suggested resource details
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SuggestedResourceDetails {
    #[prost(string, tag="1")]
    pub instance_type: ::prost::alloc::string::String,
    #[prost(int32, tag="2")]
    pub vcpus: i32,
    #[prost(int32, tag="3")]
    pub memory_gb: i32,
    #[prost(message, optional, tag="4")]
    pub projected_monthly_cost: ::core::option::Option<Money>,
    /// For cross-cloud recommendations
    #[prost(enumeration="CloudProvider", optional, tag="5")]
    pub suggested_provider: ::core::option::Option<i32>,
}
/// Get recommendations request
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetRecommendationsRequest {
    #[prost(enumeration="CloudProvider", optional, tag="1")]
    pub provider: ::core::option::Option<i32>,
    #[prost(enumeration="ResourceType", repeated, tag="2")]
    pub resource_types: ::prost::alloc::vec::Vec<i32>,
    #[prost(enumeration="RecommendationType", repeated, tag="3")]
    pub recommendation_types: ::prost::alloc::vec::Vec<i32>,
    #[prost(enumeration="RecommendationPriority", optional, tag="4")]
    pub min_priority: ::core::option::Option<i32>,
    #[prost(enumeration="RecommendationStatus", optional, tag="5")]
    pub status: ::core::option::Option<i32>,
    #[prost(message, optional, tag="6")]
    pub min_savings: ::core::option::Option<Money>,
    #[prost(message, optional, tag="7")]
    pub pagination: ::core::option::Option<Pagination>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRecommendationsResponse {
    #[prost(message, repeated, tag="1")]
    pub recommendations: ::prost::alloc::vec::Vec<Recommendation>,
    #[prost(int32, tag="2")]
    pub total_count: i32,
    #[prost(message, optional, tag="3")]
    pub total_potential_savings: ::core::option::Option<Money>,
}
/// Get single recommendation
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetRecommendationRequest {
    #[prost(bytes="vec", tag="1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRecommendationResponse {
    #[prost(message, optional, tag="1")]
    pub recommendation: ::core::option::Option<Recommendation>,
    #[prost(message, optional, tag="2")]
    pub current_details: ::core::option::Option<CurrentResourceDetails>,
    #[prost(message, optional, tag="3")]
    pub suggested_details: ::core::option::Option<SuggestedResourceDetails>,
}
/// Apply recommendation
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ApplyRecommendationRequest {
    #[prost(bytes="vec", tag="1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    /// Simulate without applying
    #[prost(bool, tag="2")]
    pub dry_run: bool,
    #[prost(string, optional, tag="3")]
    pub approval_note: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyRecommendationResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    #[prost(string, optional, tag="2")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="3")]
    pub recommendation: ::core::option::Option<Recommendation>,
    #[prost(string, optional, tag="4")]
    pub execution_log: ::core::option::Option<::prost::alloc::string::String>,
}
/// Dismiss recommendation
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DismissRecommendationRequest {
    #[prost(bytes="vec", tag="1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag="2")]
    pub reason: ::prost::alloc::string::String,
    /// Optionally snooze until date
    #[prost(int64, optional, tag="3")]
    pub snooze_until: ::core::option::Option<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DismissRecommendationResponse {
    #[prost(message, optional, tag="1")]
    pub recommendation: ::core::option::Option<Recommendation>,
}
/// Get savings summary
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetSavingsSummaryRequest {
    #[prost(enumeration="CloudProvider", optional, tag="1")]
    pub provider: ::core::option::Option<i32>,
    #[prost(message, optional, tag="2")]
    pub time_range: ::core::option::Option<TimeRange>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSavingsSummaryResponse {
    #[prost(message, optional, tag="1")]
    pub total_potential_savings: ::core::option::Option<Money>,
    #[prost(message, optional, tag="2")]
    pub realized_savings: ::core::option::Option<Money>,
    #[prost(int32, tag="3")]
    pub total_recommendations: i32,
    #[prost(int32, tag="4")]
    pub applied_recommendations: i32,
    #[prost(message, repeated, tag="5")]
    pub savings_by_type: ::prost::alloc::vec::Vec<SavingsByType>,
    #[prost(message, repeated, tag="6")]
    pub savings_by_provider: ::prost::alloc::vec::Vec<SavingsByProvider>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SavingsByType {
    #[prost(enumeration="RecommendationType", tag="1")]
    pub r#type: i32,
    #[prost(message, optional, tag="2")]
    pub potential_savings: ::core::option::Option<Money>,
    #[prost(message, optional, tag="3")]
    pub realized_savings: ::core::option::Option<Money>,
    #[prost(int32, tag="4")]
    pub recommendation_count: i32,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SavingsByProvider {
    #[prost(enumeration="CloudProvider", tag="1")]
    pub provider: i32,
    #[prost(message, optional, tag="2")]
    pub potential_savings: ::core::option::Option<Money>,
    #[prost(message, optional, tag="3")]
    pub realized_savings: ::core::option::Option<Money>,
    #[prost(int32, tag="4")]
    pub recommendation_count: i32,
}
/// Analyze resources request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalyzeResourcesRequest {
    #[prost(message, repeated, tag="1")]
    pub resources: ::prost::alloc::vec::Vec<ResourceIdentifier>,
    /// Empty = all types
    #[prost(enumeration="RecommendationType", repeated, tag="2")]
    pub analysis_types: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalyzeResourcesResponse {
    #[prost(message, repeated, tag="1")]
    pub recommendations: ::prost::alloc::vec::Vec<Recommendation>,
    #[prost(int64, tag="2")]
    pub analysis_duration_ms: i64,
}
/// Recommendation types
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RecommendationType {
    Unspecified = 0,
    /// Resize over/under-provisioned resources
    Rightsizing = 1,
    /// Purchase reserved capacity
    ReservedInstance = 2,
    /// Use spot/preemptible instances
    SpotInstance = 3,
    /// Terminate idle resources
    IdleResource = 4,
    /// Move to cheaper storage tier
    StorageTier = 5,
    /// Move to cheaper region
    RegionMigration = 6,
    /// Upgrade to newer generation
    GenerationUpgrade = 7,
    /// Optimize licensing costs
    LicenseOptimization = 8,
    /// Move workload to another provider
    CrossCloudMigration = 9,
}
impl RecommendationType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "RECOMMENDATION_TYPE_UNSPECIFIED",
            Self::Rightsizing => "RIGHTSIZING",
            Self::ReservedInstance => "RESERVED_INSTANCE",
            Self::SpotInstance => "SPOT_INSTANCE",
            Self::IdleResource => "IDLE_RESOURCE",
            Self::StorageTier => "STORAGE_TIER",
            Self::RegionMigration => "REGION_MIGRATION",
            Self::GenerationUpgrade => "GENERATION_UPGRADE",
            Self::LicenseOptimization => "LICENSE_OPTIMIZATION",
            Self::CrossCloudMigration => "CROSS_CLOUD_MIGRATION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RECOMMENDATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "RIGHTSIZING" => Some(Self::Rightsizing),
            "RESERVED_INSTANCE" => Some(Self::ReservedInstance),
            "SPOT_INSTANCE" => Some(Self::SpotInstance),
            "IDLE_RESOURCE" => Some(Self::IdleResource),
            "STORAGE_TIER" => Some(Self::StorageTier),
            "REGION_MIGRATION" => Some(Self::RegionMigration),
            "GENERATION_UPGRADE" => Some(Self::GenerationUpgrade),
            "LICENSE_OPTIMIZATION" => Some(Self::LicenseOptimization),
            "CROSS_CLOUD_MIGRATION" => Some(Self::CrossCloudMigration),
            _ => None,
        }
    }
}
/// Recommendation priority
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RecommendationPriority {
    Unspecified = 0,
    Low = 1,
    Medium = 2,
    High = 3,
    Critical = 4,
}
impl RecommendationPriority {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "RECOMMENDATION_PRIORITY_UNSPECIFIED",
            Self::Low => "RECOMMENDATION_PRIORITY_LOW",
            Self::Medium => "RECOMMENDATION_PRIORITY_MEDIUM",
            Self::High => "RECOMMENDATION_PRIORITY_HIGH",
            Self::Critical => "RECOMMENDATION_PRIORITY_CRITICAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RECOMMENDATION_PRIORITY_UNSPECIFIED" => Some(Self::Unspecified),
            "RECOMMENDATION_PRIORITY_LOW" => Some(Self::Low),
            "RECOMMENDATION_PRIORITY_MEDIUM" => Some(Self::Medium),
            "RECOMMENDATION_PRIORITY_HIGH" => Some(Self::High),
            "RECOMMENDATION_PRIORITY_CRITICAL" => Some(Self::Critical),
            _ => None,
        }
    }
}
/// Recommendation status
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RecommendationStatus {
    Unspecified = 0,
    Pending = 1,
    Approved = 2,
    Applied = 3,
    Dismissed = 4,
    Failed = 5,
    Expired = 6,
}
impl RecommendationStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "RECOMMENDATION_STATUS_UNSPECIFIED",
            Self::Pending => "RECOMMENDATION_STATUS_PENDING",
            Self::Approved => "RECOMMENDATION_STATUS_APPROVED",
            Self::Applied => "RECOMMENDATION_STATUS_APPLIED",
            Self::Dismissed => "RECOMMENDATION_STATUS_DISMISSED",
            Self::Failed => "RECOMMENDATION_STATUS_FAILED",
            Self::Expired => "RECOMMENDATION_STATUS_EXPIRED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RECOMMENDATION_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "RECOMMENDATION_STATUS_PENDING" => Some(Self::Pending),
            "RECOMMENDATION_STATUS_APPROVED" => Some(Self::Approved),
            "RECOMMENDATION_STATUS_APPLIED" => Some(Self::Applied),
            "RECOMMENDATION_STATUS_DISMISSED" => Some(Self::Dismissed),
            "RECOMMENDATION_STATUS_FAILED" => Some(Self::Failed),
            "RECOMMENDATION_STATUS_EXPIRED" => Some(Self::Expired),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ImpactLevel {
    Unspecified = 0,
    None = 1,
    Low = 2,
    Medium = 3,
    High = 4,
}
impl ImpactLevel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "IMPACT_LEVEL_UNSPECIFIED",
            Self::None => "IMPACT_LEVEL_NONE",
            Self::Low => "IMPACT_LEVEL_LOW",
            Self::Medium => "IMPACT_LEVEL_MEDIUM",
            Self::High => "IMPACT_LEVEL_HIGH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "IMPACT_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
            "IMPACT_LEVEL_NONE" => Some(Self::None),
            "IMPACT_LEVEL_LOW" => Some(Self::Low),
            "IMPACT_LEVEL_MEDIUM" => Some(Self::Medium),
            "IMPACT_LEVEL_HIGH" => Some(Self::High),
            _ => None,
        }
    }
}
/// Price entry representing a single pricing record
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PriceEntry {
    /// UUID as bytes
    #[prost(bytes="vec", tag="1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration="CloudProvider", tag="2")]
    pub provider: i32,
    #[prost(enumeration="ResourceType", tag="3")]
    pub resource_type: i32,
    /// Provider-specific SKU
    #[prost(string, tag="4")]
    pub sku: ::prost::alloc::string::String,
    /// e.g., "Amazon EC2", "Azure VMs"
    #[prost(string, tag="5")]
    pub service_name: ::prost::alloc::string::String,
    /// e.g., "Compute Instance"
    #[prost(string, tag="6")]
    pub product_family: ::prost::alloc::string::String,
    /// e.g., "t3.medium", "Standard_D2s_v3"
    #[prost(string, tag="7")]
    pub instance_type: ::prost::alloc::string::String,
    #[prost(string, tag="8")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag="9")]
    pub unit_price: ::core::option::Option<Money>,
    #[prost(enumeration="PricingUnit", tag="10")]
    pub pricing_unit: i32,
    #[prost(string, tag="11")]
    pub description: ::prost::alloc::string::String,
    /// Additional attributes (vCPU, memory, etc.)
    #[prost(map="string, string", tag="12")]
    pub attributes: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// When this price became effective
    #[prost(int64, tag="13")]
    pub effective_date: i64,
    /// When this price expires (null if current)
    #[prost(int64, optional, tag="14")]
    pub expiration_date: ::core::option::Option<i64>,
    /// When we fetched this price
    #[prost(int64, tag="15")]
    pub collected_at: i64,
}
/// Pricing tier for volume-based pricing
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PricingTier {
    /// Start of tier (units)
    #[prost(int64, tag="1")]
    pub start_usage: i64,
    /// End of tier (null for unlimited)
    #[prost(int64, optional, tag="2")]
    pub end_usage: ::core::option::Option<i64>,
    #[prost(message, optional, tag="3")]
    pub unit_price: ::core::option::Option<Money>,
}
/// Request to get a single price
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetPriceRequest {
    #[prost(bytes="vec", tag="1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPriceResponse {
    #[prost(message, optional, tag="1")]
    pub price: ::core::option::Option<PriceEntry>,
}
/// Request to list prices with filters
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListPricesRequest {
    #[prost(enumeration="CloudProvider", optional, tag="1")]
    pub provider: ::core::option::Option<i32>,
    #[prost(enumeration="ResourceType", optional, tag="2")]
    pub resource_type: ::core::option::Option<i32>,
    #[prost(string, repeated, tag="3")]
    pub regions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag="4")]
    pub service_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="5")]
    pub instance_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="6")]
    pub sku: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="7")]
    pub pagination: ::core::option::Option<Pagination>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPricesResponse {
    #[prost(message, repeated, tag="1")]
    pub prices: ::prost::alloc::vec::Vec<PriceEntry>,
    #[prost(int32, tag="2")]
    pub total_count: i32,
}
/// Request to compare prices across providers
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ComparePricesRequest {
    #[prost(enumeration="ResourceType", tag="1")]
    pub resource_type: i32,
    /// Comparison criteria
    #[prost(int32, optional, tag="2")]
    pub vcpus: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="3")]
    pub memory_gb: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="4")]
    pub storage_gb: ::core::option::Option<i32>,
    #[prost(string, repeated, tag="5")]
    pub regions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Empty means all providers
    #[prost(enumeration="CloudProvider", repeated, tag="6")]
    pub providers: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComparePricesResponse {
    #[prost(message, repeated, tag="1")]
    pub comparisons: ::prost::alloc::vec::Vec<PriceComparison>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PriceComparison {
    /// e.g., "4vcpu-8gb-compute"
    #[prost(string, tag="1")]
    pub comparison_key: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="2")]
    pub provider_prices: ::prost::alloc::vec::Vec<ProviderPrice>,
    #[prost(message, optional, tag="3")]
    pub cheapest: ::core::option::Option<ProviderPrice>,
    /// vs. most expensive
    #[prost(message, optional, tag="4")]
    pub potential_savings: ::core::option::Option<Money>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProviderPrice {
    #[prost(enumeration="CloudProvider", tag="1")]
    pub provider: i32,
    #[prost(message, optional, tag="2")]
    pub price: ::core::option::Option<PriceEntry>,
    /// Estimated monthly cost
    #[prost(message, optional, tag="3")]
    pub monthly_estimate: ::core::option::Option<Money>,
}
/// Request for price history
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetPriceHistoryRequest {
    #[prost(string, tag="1")]
    pub sku: ::prost::alloc::string::String,
    #[prost(enumeration="CloudProvider", tag="2")]
    pub provider: i32,
    #[prost(string, tag="3")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub time_range: ::core::option::Option<TimeRange>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPriceHistoryResponse {
    #[prost(message, repeated, tag="1")]
    pub history: ::prost::alloc::vec::Vec<PriceEntry>,
}
/// Request to stream price updates
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StreamPriceUpdatesRequest {
    #[prost(enumeration="CloudProvider", repeated, tag="1")]
    pub providers: ::prost::alloc::vec::Vec<i32>,
    #[prost(enumeration="ResourceType", repeated, tag="2")]
    pub resource_types: ::prost::alloc::vec::Vec<i32>,
    #[prost(string, repeated, tag="3")]
    pub regions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PriceUpdate {
    #[prost(message, optional, tag="1")]
    pub price: ::core::option::Option<PriceEntry>,
    #[prost(enumeration="PriceUpdateType", tag="2")]
    pub update_type: i32,
    /// For CHANGED updates
    #[prost(message, optional, tag="3")]
    pub previous_price: ::core::option::Option<PriceEntry>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PriceUpdateType {
    Unspecified = 0,
    New = 1,
    Changed = 2,
    Removed = 3,
}
impl PriceUpdateType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PRICE_UPDATE_TYPE_UNSPECIFIED",
            Self::New => "NEW",
            Self::Changed => "CHANGED",
            Self::Removed => "REMOVED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PRICE_UPDATE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "NEW" => Some(Self::New),
            "CHANGED" => Some(Self::Changed),
            "REMOVED" => Some(Self::Removed),
            _ => None,
        }
    }
}
/// Provider configuration
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ProviderConfig {
    #[prost(bytes="vec", tag="1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration="CloudProvider", tag="2")]
    pub provider: i32,
    /// User-friendly name
    #[prost(string, tag="3")]
    pub name: ::prost::alloc::string::String,
    /// AWS account, Azure subscription, GCP project
    #[prost(string, tag="4")]
    pub account_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="5")]
    pub credentials: ::core::option::Option<ProviderCredentials>,
    #[prost(string, repeated, tag="6")]
    pub enabled_regions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration="ResourceType", repeated, tag="7")]
    pub enabled_resource_types: ::prost::alloc::vec::Vec<i32>,
    #[prost(bool, tag="8")]
    pub enabled: bool,
    #[prost(int64, tag="9")]
    pub created_at: i64,
    #[prost(int64, tag="10")]
    pub updated_at: i64,
}
/// Provider credentials (sensitive, stored encrypted)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ProviderCredentials {
    #[prost(oneof="provider_credentials::Credentials", tags="1, 2, 3")]
    pub credentials: ::core::option::Option<provider_credentials::Credentials>,
}
/// Nested message and enum types in `ProviderCredentials`.
pub mod provider_credentials {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Credentials {
        #[prost(message, tag="1")]
        Aws(super::AwsCredentials),
        #[prost(message, tag="2")]
        Azure(super::AzureCredentials),
        #[prost(message, tag="3")]
        Gcp(super::GcpCredentials),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AwsCredentials {
    /// For IAM role assumption (preferred)
    #[prost(string, optional, tag="1")]
    pub role_arn: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="2")]
    pub external_id: ::core::option::Option<::prost::alloc::string::String>,
    /// For access keys (less preferred)
    #[prost(string, optional, tag="3")]
    pub access_key_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="4")]
    pub secret_access_key: ::core::option::Option<::prost::alloc::string::String>,
    /// Region for STS calls
    #[prost(string, tag="5")]
    pub region: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AzureCredentials {
    #[prost(string, tag="1")]
    pub tenant_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub client_id: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub client_secret: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub subscription_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GcpCredentials {
    /// Service account JSON key (base64 encoded)
    #[prost(string, tag="1")]
    pub service_account_key: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub project_id: ::prost::alloc::string::String,
}
/// Provider status
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ProviderStatus {
    #[prost(bytes="vec", tag="1")]
    pub provider_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration="ProviderHealthStatus", tag="2")]
    pub health: i32,
    #[prost(string, optional, tag="3")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, tag="4")]
    pub last_successful_sync: i64,
    #[prost(int64, tag="5")]
    pub last_check_at: i64,
    #[prost(message, optional, tag="6")]
    pub metrics: ::core::option::Option<ProviderMetrics>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ProviderMetrics {
    #[prost(int64, tag="1")]
    pub total_prices_collected: i64,
    #[prost(int64, tag="2")]
    pub total_resources_discovered: i64,
    #[prost(int64, tag="3")]
    pub last_collection_duration_ms: i64,
    #[prost(int64, tag="4")]
    pub avg_collection_duration_ms: i64,
}
/// Register provider request
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RegisterProviderRequest {
    #[prost(enumeration="CloudProvider", tag="1")]
    pub provider: i32,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub account_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub credentials: ::core::option::Option<ProviderCredentials>,
    #[prost(string, repeated, tag="5")]
    pub enabled_regions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration="ResourceType", repeated, tag="6")]
    pub enabled_resource_types: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RegisterProviderResponse {
    #[prost(message, optional, tag="1")]
    pub config: ::core::option::Option<ProviderConfig>,
}
/// List providers
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListProvidersRequest {
    #[prost(enumeration="CloudProvider", optional, tag="1")]
    pub provider_filter: ::core::option::Option<i32>,
    #[prost(bool, optional, tag="2")]
    pub enabled_only: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListProvidersResponse {
    #[prost(message, repeated, tag="1")]
    pub providers: ::prost::alloc::vec::Vec<ProviderConfig>,
}
/// Get provider
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetProviderRequest {
    #[prost(bytes="vec", tag="1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetProviderResponse {
    #[prost(message, optional, tag="1")]
    pub config: ::core::option::Option<ProviderConfig>,
    #[prost(message, optional, tag="2")]
    pub status: ::core::option::Option<ProviderStatus>,
}
/// Update provider
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateProviderRequest {
    #[prost(bytes="vec", tag="1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, optional, tag="2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="3")]
    pub credentials: ::core::option::Option<ProviderCredentials>,
    #[prost(string, repeated, tag="4")]
    pub enabled_regions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration="ResourceType", repeated, tag="5")]
    pub enabled_resource_types: ::prost::alloc::vec::Vec<i32>,
    #[prost(bool, optional, tag="6")]
    pub enabled: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateProviderResponse {
    #[prost(message, optional, tag="1")]
    pub config: ::core::option::Option<ProviderConfig>,
}
/// Remove provider
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RemoveProviderRequest {
    #[prost(bytes="vec", tag="1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RemoveProviderResponse {
}
/// Test connection
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TestConnectionRequest {
    #[prost(bytes="vec", tag="1")]
    pub provider_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TestConnectionResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    #[prost(string, optional, tag="2")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, tag="3")]
    pub latency_ms: i64,
}
/// Get provider health
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetProviderHealthRequest {
    #[prost(bytes="vec", tag="1")]
    pub provider_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetProviderHealthResponse {
    #[prost(message, optional, tag="1")]
    pub status: ::core::option::Option<ProviderStatus>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProviderHealthStatus {
    Unspecified = 0,
    Healthy = 1,
    Degraded = 2,
    Unhealthy = 3,
    Unknown = 4,
}
impl ProviderHealthStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PROVIDER_HEALTH_STATUS_UNSPECIFIED",
            Self::Healthy => "HEALTHY",
            Self::Degraded => "DEGRADED",
            Self::Unhealthy => "UNHEALTHY",
            Self::Unknown => "UNKNOWN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROVIDER_HEALTH_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "HEALTHY" => Some(Self::Healthy),
            "DEGRADED" => Some(Self::Degraded),
            "UNHEALTHY" => Some(Self::Unhealthy),
            "UNKNOWN" => Some(Self::Unknown),
            _ => None,
        }
    }
}
include!("cloud.v1.tonic.rs");
// @@protoc_insertion_point(module)