// @generated
// This file is @generated by prost-build.
// ============= Multi-Tenancy =============

/// Tenant context for all operations
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TenantContext {
    /// UUID as bytes (16 bytes)
    #[prost(bytes="vec", tag="1")]
    pub project_id: ::prost::alloc::vec::Vec<u8>,
    /// Optional namespace within project
    #[prost(string, optional, tag="2")]
    pub namespace: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional user ID for access control
    #[prost(bytes="vec", optional, tag="3")]
    pub user_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
// ============= Collection Management =============

#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VectorConfig {
    /// Vector dimension (1536, 3072, etc.)
    #[prost(uint32, tag="1")]
    pub dimension: u32,
    /// Distance metric
    #[prost(enumeration="DistanceMetric", tag="2")]
    pub distance: i32,
    /// Optional HNSW index config
    #[prost(message, optional, tag="3")]
    pub hnsw: ::core::option::Option<HnswConfig>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HnswConfig {
    /// Max connections per layer (default: 16)
    #[prost(uint32, optional, tag="1")]
    pub m: ::core::option::Option<u32>,
    /// Construction time search width (default: 100)
    #[prost(uint32, optional, tag="2")]
    pub ef_construct: ::core::option::Option<u32>,
    /// When to switch to full scan
    #[prost(uint32, optional, tag="3")]
    pub full_scan_threshold: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateCollectionRequest {
    #[prost(message, optional, tag="1")]
    pub tenant: ::core::option::Option<TenantContext>,
    #[prost(string, tag="2")]
    pub collection_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub config: ::core::option::Option<VectorConfig>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateCollectionResponse {
    /// Tenant-prefixed collection name
    #[prost(string, tag="1")]
    pub full_collection_name: ::prost::alloc::string::String,
    #[prost(bool, tag="2")]
    pub created: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteCollectionRequest {
    #[prost(message, optional, tag="1")]
    pub tenant: ::core::option::Option<TenantContext>,
    #[prost(string, tag="2")]
    pub collection_name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteCollectionResponse {
    #[prost(bool, tag="1")]
    pub deleted: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetCollectionRequest {
    #[prost(message, optional, tag="1")]
    pub tenant: ::core::option::Option<TenantContext>,
    #[prost(string, tag="2")]
    pub collection_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CollectionInfo {
    #[prost(string, tag="1")]
    pub collection_name: ::prost::alloc::string::String,
    #[prost(uint64, tag="2")]
    pub vectors_count: u64,
    #[prost(uint64, tag="3")]
    pub indexed_vectors_count: u64,
    #[prost(uint64, tag="4")]
    pub points_count: u64,
    #[prost(message, optional, tag="5")]
    pub config: ::core::option::Option<VectorConfig>,
    /// "green", "yellow", "grey"
    #[prost(string, tag="6")]
    pub status: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetCollectionResponse {
    #[prost(message, optional, tag="1")]
    pub info: ::core::option::Option<CollectionInfo>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListCollectionsRequest {
    #[prost(message, optional, tag="1")]
    pub tenant: ::core::option::Option<TenantContext>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCollectionsResponse {
    #[prost(message, repeated, tag="1")]
    pub collections: ::prost::alloc::vec::Vec<CollectionInfo>,
}
// ============= Vector Operations =============

/// Payload as JSON bytes (flexible schema)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Payload {
    /// JSON serialized payload
    #[prost(bytes="vec", tag="1")]
    pub json: ::prost::alloc::vec::Vec<u8>,
}
/// Sparse vector for hybrid search
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SparseVector {
    #[prost(uint32, repeated, tag="1")]
    pub indices: ::prost::alloc::vec::Vec<u32>,
    #[prost(float, repeated, tag="2")]
    pub values: ::prost::alloc::vec::Vec<f32>,
}
/// A single vector point
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Vector {
    /// UUID as bytes
    #[prost(bytes="vec", tag="1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    /// Dense vector values
    #[prost(float, repeated, tag="2")]
    pub values: ::prost::alloc::vec::Vec<f32>,
    /// JSON metadata
    #[prost(message, optional, tag="3")]
    pub payload: ::core::option::Option<Payload>,
    /// Optional sparse vector for hybrid search
    #[prost(message, optional, tag="4")]
    pub sparse: ::core::option::Option<SparseVector>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpsertRequest {
    #[prost(message, optional, tag="1")]
    pub tenant: ::core::option::Option<TenantContext>,
    #[prost(string, tag="2")]
    pub collection_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub vector: ::core::option::Option<Vector>,
    /// Wait for indexing
    #[prost(bool, tag="4")]
    pub wait: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpsertResponse {
    #[prost(bytes="vec", tag="1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    /// "completed" or "pending"
    #[prost(string, tag="2")]
    pub status: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpsertBatchRequest {
    #[prost(message, optional, tag="1")]
    pub tenant: ::core::option::Option<TenantContext>,
    #[prost(string, tag="2")]
    pub collection_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="3")]
    pub vectors: ::prost::alloc::vec::Vec<Vector>,
    #[prost(bool, tag="4")]
    pub wait: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpsertBatchResponse {
    #[prost(bytes="vec", repeated, tag="1")]
    pub ids: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(string, tag="2")]
    pub status: ::prost::alloc::string::String,
    #[prost(uint32, tag="3")]
    pub upserted_count: u32,
}
/// Filter conditions for search/get/delete
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Filter {
    /// Filter by specific ID
    #[prost(bytes="vec", optional, tag="1")]
    pub must_have_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// JSON filter conditions
    #[prost(message, optional, tag="2")]
    pub must_match: ::core::option::Option<Payload>,
    /// Filter within namespace
    #[prost(string, optional, tag="3")]
    pub namespace_filter: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchRequest {
    #[prost(message, optional, tag="1")]
    pub tenant: ::core::option::Option<TenantContext>,
    #[prost(string, tag="2")]
    pub collection_name: ::prost::alloc::string::String,
    /// Query vector
    #[prost(float, repeated, tag="3")]
    pub query_vector: ::prost::alloc::vec::Vec<f32>,
    /// Max results (default: 10)
    #[prost(uint32, tag="4")]
    pub limit: u32,
    /// Min similarity score
    #[prost(float, optional, tag="5")]
    pub score_threshold: ::core::option::Option<f32>,
    /// Metadata filters
    #[prost(message, optional, tag="6")]
    pub filter: ::core::option::Option<Filter>,
    /// Include vectors in response
    #[prost(bool, tag="7")]
    pub with_vectors: bool,
    /// Include payloads in response
    #[prost(bool, tag="8")]
    pub with_payloads: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchResult {
    #[prost(bytes="vec", tag="1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    #[prost(float, tag="2")]
    pub score: f32,
    #[prost(message, optional, tag="3")]
    pub payload: ::core::option::Option<Payload>,
    #[prost(message, optional, tag="4")]
    pub vector: ::core::option::Option<Vector>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchResponse {
    #[prost(message, repeated, tag="1")]
    pub results: ::prost::alloc::vec::Vec<SearchResult>,
    /// Query execution time
    #[prost(uint64, tag="2")]
    pub search_time_ms: u64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetRequest {
    #[prost(message, optional, tag="1")]
    pub tenant: ::core::option::Option<TenantContext>,
    #[prost(string, tag="2")]
    pub collection_name: ::prost::alloc::string::String,
    /// Vector IDs to retrieve
    #[prost(bytes="vec", repeated, tag="3")]
    pub ids: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, tag="4")]
    pub with_vectors: bool,
    #[prost(bool, tag="5")]
    pub with_payloads: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetResponse {
    #[prost(message, repeated, tag="1")]
    pub vectors: ::prost::alloc::vec::Vec<Vector>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteRequest {
    #[prost(message, optional, tag="1")]
    pub tenant: ::core::option::Option<TenantContext>,
    #[prost(string, tag="2")]
    pub collection_name: ::prost::alloc::string::String,
    /// IDs to delete
    #[prost(bytes="vec", repeated, tag="3")]
    pub ids: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// Or delete by filter
    #[prost(message, optional, tag="4")]
    pub filter: ::core::option::Option<Filter>,
    #[prost(bool, tag="5")]
    pub wait: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteResponse {
    #[prost(uint32, tag="1")]
    pub deleted_count: u32,
    #[prost(string, tag="2")]
    pub status: ::prost::alloc::string::String,
}
// ============= Embedding Generation =============

#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EmbedRequest {
    #[prost(string, tag="1")]
    pub text: ::prost::alloc::string::String,
    #[prost(enumeration="EmbeddingProvider", tag="2")]
    pub provider: i32,
    #[prost(enumeration="EmbeddingModel", tag="3")]
    pub model: i32,
    /// For CUSTOM model
    #[prost(uint32, optional, tag="4")]
    pub custom_dimension: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EmbedResponse {
    #[prost(float, repeated, tag="1")]
    pub embedding: ::prost::alloc::vec::Vec<f32>,
    #[prost(uint32, tag="2")]
    pub dimension: u32,
    #[prost(uint32, tag="3")]
    pub tokens_used: u32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EmbedBatchRequest {
    #[prost(string, repeated, tag="1")]
    pub texts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration="EmbeddingProvider", tag="2")]
    pub provider: i32,
    #[prost(enumeration="EmbeddingModel", tag="3")]
    pub model: i32,
    #[prost(uint32, optional, tag="4")]
    pub custom_dimension: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EmbedBatchResponse {
    #[prost(message, repeated, tag="1")]
    pub embeddings: ::prost::alloc::vec::Vec<EmbeddingResult>,
    #[prost(uint32, tag="2")]
    pub total_tokens: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EmbeddingResult {
    #[prost(float, repeated, tag="1")]
    pub values: ::prost::alloc::vec::Vec<f32>,
    #[prost(uint32, tag="2")]
    pub dimension: u32,
}
// ============= Combined Operations =============

#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpsertWithEmbeddingRequest {
    #[prost(message, optional, tag="1")]
    pub tenant: ::core::option::Option<TenantContext>,
    #[prost(string, tag="2")]
    pub collection_name: ::prost::alloc::string::String,
    /// Vector ID
    #[prost(bytes="vec", tag="3")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    /// Text to embed
    #[prost(string, tag="4")]
    pub text: ::prost::alloc::string::String,
    /// Metadata
    #[prost(message, optional, tag="5")]
    pub payload: ::core::option::Option<Payload>,
    #[prost(enumeration="EmbeddingProvider", tag="6")]
    pub provider: i32,
    #[prost(enumeration="EmbeddingModel", tag="7")]
    pub model: i32,
    #[prost(bool, tag="8")]
    pub wait: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchWithEmbeddingRequest {
    #[prost(message, optional, tag="1")]
    pub tenant: ::core::option::Option<TenantContext>,
    #[prost(string, tag="2")]
    pub collection_name: ::prost::alloc::string::String,
    /// Query text to embed
    #[prost(string, tag="3")]
    pub text: ::prost::alloc::string::String,
    #[prost(uint32, tag="4")]
    pub limit: u32,
    #[prost(float, optional, tag="5")]
    pub score_threshold: ::core::option::Option<f32>,
    #[prost(message, optional, tag="6")]
    pub filter: ::core::option::Option<Filter>,
    #[prost(bool, tag="7")]
    pub with_vectors: bool,
    #[prost(bool, tag="8")]
    pub with_payloads: bool,
    #[prost(enumeration="EmbeddingProvider", tag="9")]
    pub provider: i32,
    #[prost(enumeration="EmbeddingModel", tag="10")]
    pub model: i32,
}
// ============= Recommendations =============

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecommendRequest {
    #[prost(message, optional, tag="1")]
    pub tenant: ::core::option::Option<TenantContext>,
    #[prost(string, tag="2")]
    pub collection_name: ::prost::alloc::string::String,
    /// IDs to find similar to
    #[prost(bytes="vec", repeated, tag="3")]
    pub positive_ids: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// IDs to avoid
    #[prost(bytes="vec", repeated, tag="4")]
    pub negative_ids: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint32, tag="5")]
    pub limit: u32,
    #[prost(float, optional, tag="6")]
    pub score_threshold: ::core::option::Option<f32>,
    #[prost(message, optional, tag="7")]
    pub filter: ::core::option::Option<Filter>,
    #[prost(bool, tag="8")]
    pub with_vectors: bool,
    #[prost(bool, tag="9")]
    pub with_payloads: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecommendResponse {
    #[prost(message, repeated, tag="1")]
    pub results: ::prost::alloc::vec::Vec<SearchResult>,
    #[prost(uint64, tag="2")]
    pub search_time_ms: u64,
}
// ============= Enums =============

/// Embedding provider selection
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EmbeddingProvider {
    EmbeddingUnspecified = 0,
    EmbeddingOpenai = 1,
    EmbeddingAnthropic = 2,
    /// Self-hosted models
    EmbeddingLocal = 3,
    /// Google Vertex AI
    EmbeddingVertexai = 4,
    /// Cohere embeddings
    EmbeddingCohere = 5,
    /// Voyage AI
    EmbeddingVoyage = 6,
}
impl EmbeddingProvider {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::EmbeddingUnspecified => "EMBEDDING_UNSPECIFIED",
            Self::EmbeddingOpenai => "EMBEDDING_OPENAI",
            Self::EmbeddingAnthropic => "EMBEDDING_ANTHROPIC",
            Self::EmbeddingLocal => "EMBEDDING_LOCAL",
            Self::EmbeddingVertexai => "EMBEDDING_VERTEXAI",
            Self::EmbeddingCohere => "EMBEDDING_COHERE",
            Self::EmbeddingVoyage => "EMBEDDING_VOYAGE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EMBEDDING_UNSPECIFIED" => Some(Self::EmbeddingUnspecified),
            "EMBEDDING_OPENAI" => Some(Self::EmbeddingOpenai),
            "EMBEDDING_ANTHROPIC" => Some(Self::EmbeddingAnthropic),
            "EMBEDDING_LOCAL" => Some(Self::EmbeddingLocal),
            "EMBEDDING_VERTEXAI" => Some(Self::EmbeddingVertexai),
            "EMBEDDING_COHERE" => Some(Self::EmbeddingCohere),
            "EMBEDDING_VOYAGE" => Some(Self::EmbeddingVoyage),
            _ => None,
        }
    }
}
/// Embedding models (across providers)
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EmbeddingModel {
    Unspecified = 0,
    /// OpenAI models
    ///
    /// OpenAI text-embedding-3-small (1536 dimensions)
    Embedding3Small = 1,
    /// OpenAI text-embedding-3-large (3072 dimensions)
    Embedding3Large = 2,
    /// OpenAI text-embedding-ada-002 (1536 dimensions, legacy)
    EmbeddingAda002 = 3,
    /// Vertex AI models
    ///
    /// Vertex AI textembedding-gecko (768 dimensions)
    Gecko = 10,
    /// Vertex AI textembedding-gecko-multilingual (768 dimensions)
    GeckoMultilingual = 11,
    /// Vertex AI text-embedding-004 (768 dimensions)
    TextEmbedding004 = 12,
    /// Vertex AI text-embedding-005 (768 dimensions)
    TextEmbedding005 = 13,
    /// Vertex AI text-multilingual-embedding-002 (768 dimensions)
    TextMultilingualEmbedding002 = 14,
    /// Cohere models
    ///
    /// Cohere embed-english-v3.0 (1024 dimensions)
    CohereEmbedV3 = 20,
    /// Cohere embed-multilingual-v3.0 (1024 dimensions)
    CohereEmbedMultilingualV3 = 21,
    /// Voyage AI models
    ///
    /// Voyage voyage-3 (1024 dimensions)
    Voyage3 = 30,
    /// Voyage voyage-3-lite (512 dimensions)
    Voyage3Lite = 31,
    /// Voyage voyage-code-3 (1024 dimensions)
    VoyageCode3 = 32,
    /// Custom/local models
    ///
    /// User-specified dimension
    Custom = 100,
}
impl EmbeddingModel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "EMBEDDING_MODEL_UNSPECIFIED",
            Self::Embedding3Small => "EMBEDDING_MODEL_EMBEDDING_3_SMALL",
            Self::Embedding3Large => "EMBEDDING_MODEL_EMBEDDING_3_LARGE",
            Self::EmbeddingAda002 => "EMBEDDING_MODEL_EMBEDDING_ADA_002",
            Self::Gecko => "EMBEDDING_MODEL_GECKO",
            Self::GeckoMultilingual => "EMBEDDING_MODEL_GECKO_MULTILINGUAL",
            Self::TextEmbedding004 => "EMBEDDING_MODEL_TEXT_EMBEDDING_004",
            Self::TextEmbedding005 => "EMBEDDING_MODEL_TEXT_EMBEDDING_005",
            Self::TextMultilingualEmbedding002 => "EMBEDDING_MODEL_TEXT_MULTILINGUAL_EMBEDDING_002",
            Self::CohereEmbedV3 => "EMBEDDING_MODEL_COHERE_EMBED_V3",
            Self::CohereEmbedMultilingualV3 => "EMBEDDING_MODEL_COHERE_EMBED_MULTILINGUAL_V3",
            Self::Voyage3 => "EMBEDDING_MODEL_VOYAGE_3",
            Self::Voyage3Lite => "EMBEDDING_MODEL_VOYAGE_3_LITE",
            Self::VoyageCode3 => "EMBEDDING_MODEL_VOYAGE_CODE_3",
            Self::Custom => "EMBEDDING_MODEL_CUSTOM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EMBEDDING_MODEL_UNSPECIFIED" => Some(Self::Unspecified),
            "EMBEDDING_MODEL_EMBEDDING_3_SMALL" => Some(Self::Embedding3Small),
            "EMBEDDING_MODEL_EMBEDDING_3_LARGE" => Some(Self::Embedding3Large),
            "EMBEDDING_MODEL_EMBEDDING_ADA_002" => Some(Self::EmbeddingAda002),
            "EMBEDDING_MODEL_GECKO" => Some(Self::Gecko),
            "EMBEDDING_MODEL_GECKO_MULTILINGUAL" => Some(Self::GeckoMultilingual),
            "EMBEDDING_MODEL_TEXT_EMBEDDING_004" => Some(Self::TextEmbedding004),
            "EMBEDDING_MODEL_TEXT_EMBEDDING_005" => Some(Self::TextEmbedding005),
            "EMBEDDING_MODEL_TEXT_MULTILINGUAL_EMBEDDING_002" => Some(Self::TextMultilingualEmbedding002),
            "EMBEDDING_MODEL_COHERE_EMBED_V3" => Some(Self::CohereEmbedV3),
            "EMBEDDING_MODEL_COHERE_EMBED_MULTILINGUAL_V3" => Some(Self::CohereEmbedMultilingualV3),
            "EMBEDDING_MODEL_VOYAGE_3" => Some(Self::Voyage3),
            "EMBEDDING_MODEL_VOYAGE_3_LITE" => Some(Self::Voyage3Lite),
            "EMBEDDING_MODEL_VOYAGE_CODE_3" => Some(Self::VoyageCode3),
            "EMBEDDING_MODEL_CUSTOM" => Some(Self::Custom),
            _ => None,
        }
    }
}
/// Distance metric for similarity
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DistanceMetric {
    Unspecified = 0,
    Cosine = 1,
    Euclidean = 2,
    DotProduct = 3,
    Manhattan = 4,
}
impl DistanceMetric {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DISTANCE_METRIC_UNSPECIFIED",
            Self::Cosine => "DISTANCE_METRIC_COSINE",
            Self::Euclidean => "DISTANCE_METRIC_EUCLIDEAN",
            Self::DotProduct => "DISTANCE_METRIC_DOT_PRODUCT",
            Self::Manhattan => "DISTANCE_METRIC_MANHATTAN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DISTANCE_METRIC_UNSPECIFIED" => Some(Self::Unspecified),
            "DISTANCE_METRIC_COSINE" => Some(Self::Cosine),
            "DISTANCE_METRIC_EUCLIDEAN" => Some(Self::Euclidean),
            "DISTANCE_METRIC_DOT_PRODUCT" => Some(Self::DotProduct),
            "DISTANCE_METRIC_MANHATTAN" => Some(Self::Manhattan),
            _ => None,
        }
    }
}
include!("vector.v1.tonic.rs");
// @@protoc_insertion_point(module)