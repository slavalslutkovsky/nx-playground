apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: xnetwork
  labels:
    crossplane.io/xrd: xnetworks.network.platform.io
spec:
  compositeTypeRef:
    apiVersion: network.platform.io/v1alpha1
    kind: XNetwork
  mode: Pipeline
  pipeline:
    - step: compose-network
      functionRef:
        name: function-kcl
      input:
        apiVersion: krm.kcl.dev/v1alpha1
        kind: KCLRun
        metadata:
          name: compose-network
        spec:
          target: Default
          # OCI dependencies - models generated by 'up project generate', schemas published to registry
          dependencies: |
            model = { oci = "oci://docker.io/yurikrupnik/platform-models", tag = "0.0.1" }
            schemas = { oci = "oci://docker.io/yurikrupnik/platform-schemas", tag = "0.0.1" }

          source: |
            # --- Provider: aws ---
            """
            AWS S3 resource generation for bucket composition.
            """
            
            import model.io.upbound.aws.s3.v1beta2 as s3
            import model.io.upbound.aws.s3.v1beta1 as s3v1beta1
            import schemas.bucket as schema
            import schemas.labels as labels
            import schemas.helpers as h
            
            generate_aws = lambda spec: schema.BucketSpec, ocds: any -> [any] {
                """Generate AWS S3 resources from BucketSpec."""
                _bucket_name = spec.name
                _region = spec.region
                _storage_class = schema.map_storage_class("aws", spec.storageClass)
                _deletion_policy = spec.deletionPolicy
            
                _label_config = labels.LabelConfig {
                    name = _bucket_name
                    component = "storage"
                    provider = "aws"
                    environment = spec.environment
                }
                _tags = labels.generate_tags(_label_config, "aws") | spec.tags
            
                resources: [any] = []
            
                # Main S3 Bucket
                resources += [s3.Bucket {
                    metadata = h.metadata(_bucket_name)
                    spec = {
                        forProvider = {
                            region = _region
                            tags = _tags
                        }
                        deletionPolicy = _deletion_policy
                    }
                }]
            
                # Bucket versioning
                if spec.versioning:
                    resources += [s3.BucketVersioning {
                        metadata = h.metadata("${_bucket_name}-versioning")
                        spec = {
                            forProvider = {
                                region = _region
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                versioningConfiguration = {
                                    status = "Enabled"
                                }
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                # Server-side encryption
                if spec.encryption:
                    resources += [s3.BucketServerSideEncryptionConfiguration {
                        metadata = h.metadata("${_bucket_name}-encryption")
                        spec = {
                            forProvider = {
                                region = _region
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                $rule = [{
                                    applyServerSideEncryptionByDefault = {
                                        sseAlgorithm = "AES256"
                                    }
                                    bucketKeyEnabled = True
                                }]
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                # Public access block (default: block all public access)
                resources += [s3v1beta1.BucketPublicAccessBlock {
                    metadata = h.metadata("${_bucket_name}-public-access")
                    spec = {
                        forProvider = {
                            region = _region
                            bucketSelector = {
                                matchControllerRef = True
                            }
                            blockPublicAcls = not spec.publicAccess
                            blockPublicPolicy = not spec.publicAccess
                            ignorePublicAcls = not spec.publicAccess
                            restrictPublicBuckets = not spec.publicAccess
                        }
                        deletionPolicy = _deletion_policy
                    }
                }]
            
                # CORS configuration
                if spec.cors:
                    resources += [{
                        apiVersion = "s3.aws.upbound.io/v1beta1"
                        kind = "BucketCorsConfiguration"
                        metadata = h.metadata("${_bucket_name}-cors")
                        spec = {
                            forProvider = {
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                region = _region
                                corsRule = [
                                    {
                                        allowedOrigins = rule.allowedOrigins
                                        allowedMethods = rule.allowedMethods
                                        allowedHeaders = rule.allowedHeaders
                                        maxAgeSeconds = rule.maxAgeSeconds
                                    }
                                    for rule in spec.cors
                                ]
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                # Lifecycle rules
                if spec.lifecycle:
                    resources += [{
                        apiVersion = "s3.aws.upbound.io/v1beta1"
                        kind = "BucketLifecycleConfiguration"
                        metadata = h.metadata("${_bucket_name}-lifecycle")
                        spec = {
                            forProvider = {
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                region = _region
                                $rule = [
                                    _build_lifecycle_rule(rule)
                                    for rule in spec.lifecycle
                                ]
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                resources
            }
            
            _build_lifecycle_rule = lambda rule: schema.LifecycleRule -> any {
                """Build an AWS S3 lifecycle rule."""
                base: {str:any} = {
                    id = rule.name
                    status = "Enabled" if rule.enabled else "Disabled"
                }
            
                if rule.prefix:
                    base |= {filter = [{prefix = rule.prefix}]}
            
                if rule.expirationDays > 0:
                    base |= {expiration = [{days = rule.expirationDays}]}
            
                if rule.transitionDays > 0:
                    base |= {
                        transition = [{
                            days = rule.transitionDays
                            storageClass = schema.map_storage_class("aws", rule.transitionStorageClass)
                        }]
                    }
            
                base
            }
            
            get_status_aws = lambda spec: schema.BucketSpec, ocds: any -> schema.BucketStatus {
                """Extract status from observed composed resources."""
                _observed_bucket = ocds.get(spec.name, {})
                _observed_status = _observed_bucket.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _bucket_id = _observed_status.get("id", spec.name)
                _bucket_domain = _observed_status.get("bucketRegionalDomainName", "")
            
                schema.BucketStatus {
                    provider = "aws"
                    region = spec.region
                    bucketName = _bucket_id
                    url = "s3://${_bucket_id}"
                    id = _bucket_id
                    cloudUrl = "https://${_bucket_domain}" if _bucket_domain else "https://${spec.name}.s3.${spec.region}.amazonaws.com"
                }
            }
            """
            GCP Cloud Storage resource generation for bucket composition.
            """
            
            import model.io.upbound.gcp.storage.v1beta2 as gcs
            import schemas.bucket as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.common as c
            
            generate_gcp = lambda spec: schema.BucketSpec, ocds: any -> [any] {
                """Generate GCP Cloud Storage resources from BucketSpec."""
                _bucket_name = spec.name
                _location = c.map_region("gcp", spec.region).upper()
                _storage_class = schema.map_storage_class("gcp", spec.storageClass)
                _deletion_policy = spec.deletionPolicy
            
                _label_config = labels.LabelConfig {
                    name = _bucket_name
                    component = "storage"
                    provider = "gcp"
                    environment = spec.environment
                }
                _labels = labels.generate_tags(_label_config, "gcp") | {
                    k.lower().replace("-", "_"): v.lower()
                    for k, v in spec.tags
                    if len(k) <= 63 and len(v) <= 63
                }
            
                resources: [any] = []
            
                # Build bucket forProvider config
                _for_provider: {str:any} = {
                    location = _location
                    storageClass = _storage_class
                    labels = _labels
                    uniformBucketLevelAccess = True
                    publicAccessPrevention = "enforced" if not spec.publicAccess else "inherited"
                }
            
                # Add versioning if enabled
                if spec.versioning:
                    _for_provider |= {
                        versioning = [{
                            enabled = True
                        }]
                    }
            
                # Add CORS rules if specified
                if spec.cors:
                    _for_provider |= {
                        cors = [
                            {
                                origin = rule.allowedOrigins
                                method = rule.allowedMethods
                                responseHeader = rule.allowedHeaders
                                maxAgeSeconds = rule.maxAgeSeconds
                            }
                            for rule in spec.cors
                        ]
                    }
            
                # Add lifecycle rules if specified
                if spec.lifecycle:
                    _for_provider |= {
                        lifecycleRule = [
                            _build_lifecycle_rule(rule)
                            for rule in spec.lifecycle
                        ]
                    }
            
                # Main GCS Bucket
                resources += [gcs.Bucket {
                    metadata = h.metadata(_bucket_name)
                    spec = {
                        forProvider = _for_provider
                        deletionPolicy = _deletion_policy
                    }
                }]
            
                # IAM binding for public access if enabled
                if spec.publicAccess:
                    resources += [{
                        apiVersion = "storage.gcp.upbound.io/v1beta1"
                        kind = "BucketIAMMember"
                        metadata = h.metadata("${_bucket_name}-public-read")
                        spec = {
                            forProvider = {
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                role = "roles/storage.objectViewer"
                                member = "allUsers"
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                resources
            }
            
            _build_lifecycle_rule = lambda rule: schema.LifecycleRule -> any {
                """Build a GCP lifecycle rule."""
                result: {str:any} = {
                    action = {}
                    condition = {}
                }
            
                if rule.expirationDays > 0:
                    result.action |= {$type = "Delete"}
                    result.condition |= {age = rule.expirationDays}
                elif rule.transitionDays > 0:
                    result.action |= {
                        $type = "SetStorageClass"
                        storageClass = schema.map_storage_class("gcp", rule.transitionStorageClass)
                    }
                    result.condition |= {age = rule.transitionDays}
            
                if rule.prefix:
                    result.condition |= {matchesPrefix = [rule.prefix]}
            
                result
            }
            
            get_status_gcp = lambda spec: schema.BucketSpec, ocds: any -> schema.BucketStatus {
                """Extract status from observed composed resources."""
                _observed_bucket = ocds.get(spec.name, {})
                _observed_status = _observed_bucket.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _bucket_url = _observed_status.get("url", "")
                _bucket_self_link = _observed_status.get("selfLink", "")
            
                schema.BucketStatus {
                    provider = "gcp"
                    region = spec.region
                    bucketName = spec.name
                    url = _bucket_url if _bucket_url else "gs://${spec.name}"
                    id = spec.name
                    cloudUrl = _bucket_self_link if _bucket_self_link else "https://storage.googleapis.com/${spec.name}"
                }
            }
            """
            AWS RDS resource generation for database composition.
            """
            
            import crossplane_provider_upjet_aws.v1beta2.rds_aws_upbound_io_v1beta2_instance as rds
            import schemas.database as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            
            generate_aws = lambda spec: schema.DatabaseSpec, ocds: any -> [any] {
                """Generate AWS RDS resources from DatabaseSpec."""
                _db_name = spec.region  # use oxr metadata name
                _region = regions.get_aws_region(spec.region) if spec.region else ""
                _instance_class = schema.get_instance_class("aws", spec.size)
                _engine_version = schema.get_engine_version(spec.engine, "aws", spec.engineVersion)
                _storage_type = schema.get_storage_type("aws", spec.storageType)
            
                _label_config = labels.LabelConfig {
                    name = _db_name
                    component = "database"
                    provider = "aws"
                    environment = spec.environment
                }
                _tags = labels.generate_tags(_label_config, "aws") | spec.tags
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # Main RDS Instance using typed schema
                _rds_spec: {str:any} = {
                    forProvider = {
                        region = _region
                        engine = spec.engine
                        engineVersion = _engine_version
                        instanceClass = _instance_class
                        allocatedStorage = spec.storageGB
                        storageType = _storage_type
                        storageEncrypted = True
                        multiAz = spec.multiAZ
                        publiclyAccessible = spec.publiclyAccessible
                        skipFinalSnapshot = spec.environment != "prod"
                        copyTagsToSnapshot = True
                        tags = _tags
                    }
                    deletionPolicy = spec.deletionPolicy
                }
            
                # Add final snapshot identifier for prod
                if spec.environment == "prod":
                    _rds_spec.forProvider |= {
                        finalSnapshotIdentifier = "${_db_name}-final"
                    }
            
                # Add backup configuration
                if spec.backup.enabled:
                    _rds_spec.forProvider |= {
                        backupRetentionPeriod = spec.backup.retentionDays
                        backupWindow = spec.backup.preferredWindow
                    }
            
                # Add password configuration
                if spec.secrets.generatePassword:
                    _rds_spec.forProvider |= {
                        username = "admin"
                        autoGeneratePassword = True
                    }
                    _rds_spec |= {
                        writeConnectionSecretToRef = {
                            name = "${_db_name}-credentials"
                            namespace = "crossplane-system"
                        }
                    }
                elif spec.secrets.passwordSecretRef:
                    _rds_spec.forProvider |= {
                        username = "admin"
                        passwordSecretRef = {
                            name = spec.secrets.passwordSecretRef
                            namespace = "crossplane-system"
                            key = "password"
                        }
                    }
            
                resources += [rds.Instance {
                    metadata = h.metadata_with_labels("${_db_name}-rds", _k8s_labels)
                    spec = _rds_spec
                }]
            
                resources
            }
            
            get_status_aws = lambda spec: schema.DatabaseSpec, ocds: any -> schema.DatabaseStatus {
                """Extract status from observed composed resources."""
                _db_name = spec.region
                _observed_db = ocds.get("${_db_name}-rds", {})
                _observed_status = _observed_db.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _endpoint = _observed_status.get("endpoint", "")
            
                schema.DatabaseStatus {
                    provider = "aws"
                    region = spec.region
                    engine = spec.engine
                    endpoint = _endpoint
                }
            }
            """
            GCP Cloud SQL resource generation for database composition.
            """
            
            import schemas.database as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.common as c
            
            generate_gcp = lambda spec: schema.DatabaseSpec, ocds: any, name: str -> [any] {
                """Generate GCP Cloud SQL resources from DatabaseSpec."""
                _db_name = name
                _region = c.map_region("gcp", spec.region) if spec.region else ""
                _tier = schema.get_instance_class("gcp", spec.size)
                _database_version = _get_gcp_database_version(spec.engine, spec.engineVersion)
            
                _label_config = labels.LabelConfig {
                    name = _db_name
                    component = "database"
                    provider = "gcp"
                    environment = spec.environment
                }
                _user_labels = labels.generate_tags(_label_config, "gcp") | {
                    k.lower().replace("-", "_"): v.lower()
                    for k, v in spec.tags
                    if len(k) <= 63 and len(v) <= 63
                }
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # Build settings
                _settings: {str:any} = {
                    tier = _tier
                    diskSize = spec.storageGB
                    diskType = "PD_SSD"
                    diskAutoresize = True
                    diskAutoresizeLimit = spec.storageGB * 2
                    availabilityType = "REGIONAL" if spec.multiAZ else "ZONAL"
                    userLabels = _user_labels
                    ipConfiguration = {
                        ipv4Enabled = spec.publiclyAccessible
                        requireSsl = True
                    }
                }
            
                # Add backup configuration
                if spec.backup.enabled:
                    _settings |= {
                        backupConfiguration = {
                            enabled = True
                            startTime = spec.backup.preferredWindow.split("-")[0]
                            pointInTimeRecoveryEnabled = True
                            transactionLogRetentionDays = spec.backup.retentionDays
                            backupRetentionSettings = {
                                retainedBackups = spec.backup.retentionDays
                                retentionUnit = "COUNT"
                            }
                        }
                    }
            
                # Main Cloud SQL Instance
                _sql_spec: {str:any} = {
                    forProvider = {
                        region = _region
                        databaseVersion = _database_version
                        deletionProtection = spec.environment == "prod"
                        settings = _settings
                    }
                    deletionPolicy = spec.deletionPolicy
                }
            
                # Add write connection secret if auto-generating password
                if spec.secrets.generatePassword:
                    _sql_spec |= {
                        writeConnectionSecretToRef = {
                            name = "${_db_name}-credentials"
                            namespace = "crossplane-system"
                        }
                    }
            
                resources += [{
                    apiVersion = "sql.gcp.upbound.io/v1beta2"
                    kind = "DatabaseInstance"
                    metadata = h.metadata_with_labels("${_db_name}-cloudsql", _k8s_labels)
                    spec = _sql_spec
                }]
            
                # Create database
                resources += [{
                    apiVersion = "sql.gcp.upbound.io/v1beta1"
                    kind = "Database"
                    metadata = h.metadata_with_labels("${_db_name}-db", _k8s_labels)
                    spec = {
                        forProvider = {
                            instanceSelector = {
                                matchControllerRef = True
                            }
                            charset = "UTF8" if spec.engine == "postgres" else "utf8mb4"
                            collation = "en_US.UTF8" if spec.engine == "postgres" else "utf8mb4_general_ci"
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Create user
                _user_spec: {str:any} = {
                    forProvider = {
                        instanceSelector = {
                            matchControllerRef = True
                        }
                        $type = "BUILT_IN"
                    }
                    deletionPolicy = spec.deletionPolicy
                }
            
                if spec.secrets.generatePassword:
                    _user_spec.forProvider |= {
                        passwordSecretRef = {
                            name = "${_db_name}-user-password"
                            namespace = "crossplane-system"
                            key = "password"
                        }
                    }
                elif spec.secrets.passwordSecretRef:
                    _user_spec.forProvider |= {
                        passwordSecretRef = {
                            name = spec.secrets.passwordSecretRef
                            namespace = "crossplane-system"
                            key = "password"
                        }
                    }
            
                resources += [{
                    apiVersion = "sql.gcp.upbound.io/v1beta1"
                    kind = "User"
                    metadata = h.metadata_with_labels("${_db_name}-user", _k8s_labels)
                    spec = _user_spec
                }]
            
                resources
            }
            
            _get_gcp_database_version = lambda engine: str, version: str -> str {
                """Get the GCP Cloud SQL database version string."""
                if engine == "postgres":
                    "POSTGRES_${version}"
                else:
                    "MYSQL_8_0"
            }
            
            get_status_gcp = lambda spec: schema.DatabaseSpec, ocds: any, name: str -> schema.DatabaseStatus {
                """Extract status from observed composed resources."""
                _db_name = name
                _observed_db = ocds.get("${_db_name}-cloudsql", {})
                _observed_status = _observed_db.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _connection_name = _observed_status.get("connectionName", "")
            
                schema.DatabaseStatus {
                    provider = "gcp"
                    region = spec.region
                    engine = spec.engine
                    endpoint = _connection_name
                }
            }
            """
            Kubernetes CloudNative-PG resource generation for database composition.
            """
            
            import schemas.database as schema
            import schemas.labels as labels
            import schemas.helpers as h
            
            generate_kubernetes = lambda spec: schema.DatabaseSpec, ocds: any, name: str -> [any] {
                """Generate CloudNative-PG Cluster from DatabaseSpec."""
                _db_name = name
                _namespace = spec.namespace
                _resources = schema.get_instance_class("kubernetes", spec.size)
            
                _label_config = labels.LabelConfig {
                    name = _db_name
                    component = "database"
                    provider = "kubernetes"
                    environment = spec.environment
                }
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # CloudNative-PG Cluster
                _cnpg_spec: {str:any} = {
                    instances = spec.instances
                    imageName = "ghcr.io/cloudnative-pg/postgresql:${spec.engineVersion}"
                    postgresql = {
                        parameters = {
                            max_connections = "100"
                            shared_buffers = "128MB"
                        }
                    }
                    bootstrap = {
                        initdb = {
                            database = "app"
                            owner = "app"
                        }
                    }
                    storage = {
                        size = "${spec.storageGB}Gi"
                    }
                    resources = {
                        requests = _resources
                        limits = _resources
                    }
                    monitoring = {
                        enablePodMonitor = spec.environment != "dev"
                    }
                }
            
                # Add backup configuration if enabled
                if spec.backup.enabled:
                    _cnpg_spec |= {
                        backup = {
                            barmanObjectStore = {
                                destinationPath = "s3://${_db_name}-backups/"
                                s3Credentials = {
                                    accessKeyId = {
                                        name = "${_db_name}-backup-creds"
                                        key = "ACCESS_KEY_ID"
                                    }
                                    secretAccessKey = {
                                        name = "${_db_name}-backup-creds"
                                        key = "SECRET_ACCESS_KEY"
                                    }
                                }
                            }
                            retentionPolicy = "${spec.backup.retentionDays}d"
                        }
                    }
            
                resources += [{
                    apiVersion = "postgresql.cnpg.io/v1"
                    kind = "Cluster"
                    metadata = {
                        name = "${_db_name}-cnpg"
                        namespace = _namespace
                        annotations = {
                            "krm.kcl.dev/composition-resource-name" = "${_db_name}-cnpg"
                        }
                        labels = _k8s_labels
                    }
                    spec = _cnpg_spec
                }]
            
                resources
            }
            
            get_status_kubernetes = lambda spec: schema.DatabaseSpec, ocds: any, name: str -> schema.DatabaseStatus {
                """Extract status from observed composed resources."""
                _db_name = name
                _observed_db = ocds.get("${_db_name}-cnpg", {})
                _observed_status = _observed_db.get("Resource", {}).get("status", {}) or {}
            
                _instances_ready = _observed_status.get("instancesReady", 0)
            
                schema.DatabaseStatus {
                    provider = "kubernetes"
                    region = "in-cluster"
                    engine = spec.engine
                    endpoint = "${_db_name}-cnpg-rw.${spec.namespace}.svc.cluster.local:5432" if _instances_ready > 0 else ""
                }
            }
            """
            AWS ECR resource generation for registry composition.
            """
            
            import crossplane_provider_upjet_aws.v1beta2.ecr_aws_upbound_io_v1beta2_repository as ecr
            import crossplane_provider_upjet_aws.v1beta1.ecr_aws_upbound_io_v1beta1_lifecycle_policy as ecr_lifecycle
            import schemas.registry as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            
            generate_aws = lambda spec: schema.RegistrySpec, ocds: any -> [any] {
                """Generate AWS ECR resources from RegistrySpec."""
                _name = spec.name
                _region = regions.get_aws_region(spec.region) if spec.region else ""
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "registry"
                    provider = "aws"
                    environment = spec.environment
                }
                _tags = labels.generate_tags(_label_config, "aws")
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # AWS ECR Repository
                resources += [ecr.Repository {
                    metadata = h.metadata_with_labels("${_name}-ecr", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            imageTagMutability = "IMMUTABLE" if spec.immutableTags else "MUTABLE"
                            imageScanningConfiguration = {
                                scanOnPush = spec.scanOnPush
                            }
                            encryptionConfiguration = [{
                                encryptionType = "AES256"
                            }] if spec.encryption else []
                            tags = _tags
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # AWS ECR Lifecycle Policy for retention
                if spec.retentionDays > 0:
                    resources += [ecr_lifecycle.LifecyclePolicy {
                        metadata = h.metadata_with_labels("${_name}-ecr-lifecycle", _k8s_labels)
                        spec = {
                            forProvider = {
                                region = _region
                                repositorySelector = {
                                    matchControllerRef = True
                                }
                                policy = '''{
                                    "rules": [
                                        {
                                            "rulePriority": 1,
                                            "description": "Expire untagged images older than ''' + str(spec.retentionDays) + ''' days",
                                            "selection": {
                                                "tagStatus": "untagged",
                                                "countType": "sinceImagePushed",
                                                "countUnit": "days",
                                                "countNumber": ''' + str(spec.retentionDays) + '''
                                            },
                                            "action": {
                                                "type": "expire"
                                            }
                                        }
                                    ]
                                }'''
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }]
            
                resources
            }
            
            get_status_aws = lambda spec: schema.RegistrySpec, ocds: any -> schema.RegistryStatus {
                """Extract status from observed composed resources."""
                _observed_ecr = ocds.get("${spec.name}-ecr", {})
                _observed_status = _observed_ecr.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _registry_url = _observed_status.get("repositoryUrl", "")
            
                schema.RegistryStatus {
                    provider = "aws"
                    region = spec.region
                    registryUrl = _registry_url
                    repositoryName = spec.name
                }
            }
            """
            GCP Artifact Registry resource generation for registry composition.
            """
            
            import crossplane_provider_upjet_gcp.v1beta1.artifact_gcp_upbound_io_v1beta1_registry_repository as artifact
            import schemas.registry as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            
            generate_gcp = lambda spec: schema.RegistrySpec, ocds: any -> [any] {
                """Generate GCP Artifact Registry resources from RegistrySpec."""
                _name = spec.name
                _region = regions.get_gcp_region(spec.region) if spec.region else ""
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "registry"
                    provider = "gcp"
                    environment = spec.environment
                }
                _gcp_labels = labels.generate_tags(_label_config, "gcp")
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # GCP Artifact Registry Repository
                resources += [artifact.RegistryRepository {
                    metadata = h.metadata_with_labels("${_name}-artifactregistry", _k8s_labels)
                    spec = {
                        forProvider = {
                            location = _region
                            format = spec.format.upper()
                            mode = "STANDARD_REPOSITORY"
                            labels = _gcp_labels
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                resources
            }
            
            get_status_gcp = lambda spec: schema.RegistrySpec, ocds: any -> schema.RegistryStatus {
                """Extract status from observed composed resources."""
                _observed_artifact = ocds.get("${spec.name}-artifactregistry", {})
                _observed_status = _observed_artifact.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _name = _observed_status.get("name", "")
                _region = spec.region
            
                schema.RegistryStatus {
                    provider = "gcp"
                    region = _region
                    registryUrl = "${_region}-docker.pkg.dev/${_name}" if _name else ""
                    repositoryName = spec.name
                }
            }
            """
            Kubernetes Harbor resource generation for registry composition.
            """
            
            import schemas.registry as schema
            import schemas.labels as labels
            import schemas.helpers as h
            
            generate_kubernetes = lambda spec: schema.RegistrySpec, ocds: any -> [any] {
                """Generate Harbor resources from RegistrySpec."""
                _name = spec.name
                _namespace = spec.namespace
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "registry"
                    provider = "kubernetes"
                    environment = spec.environment
                }
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # Harbor Cluster (using goharbor-operator)
                resources += [{
                    apiVersion = "goharbor.io/v1beta1"
                    kind = "HarborCluster"
                    metadata = {
                        name = "${_name}-harbor"
                        namespace = _namespace
                        annotations = {
                            "krm.kcl.dev/composition-resource-name" = "${_name}-harbor"
                        }
                        labels = _k8s_labels
                    }
                    spec = {
                        version = "2.11.0"
                        externalURL = "https://${_name}-harbor.${_namespace}.svc.cluster.local"
                        expose = {
                            core = {
                                ingress = {
                                    host = "${_name}-harbor.local"
                                }
                            }
                        }
                        database = {
                            kind = "PostgreSQL"
                            spec = {
                                embedded = {}
                            }
                        }
                        storage = {
                            kind = "FileSystem"
                            spec = {
                                fileSystem = {
                                    rootdirectory = "/storage"
                                }
                            }
                        }
                        cache = {
                            kind = "Redis"
                            spec = {
                                embedded = {}
                            }
                        }
                    }
                }]
            
                resources
            }
            
            get_status_kubernetes = lambda spec: schema.RegistrySpec, ocds: any -> schema.RegistryStatus {
                """Extract status from observed composed resources."""
                _observed_harbor = ocds.get("${spec.name}-harbor", {})
                _observed_status = _observed_harbor.get("Resource", {}).get("status", {}) or {}
            
                _external_url = _observed_status.get("externalURL", "")
            
                schema.RegistryStatus {
                    provider = "kubernetes"
                    region = "in-cluster"
                    registryUrl = _external_url if _external_url else "https://${spec.name}-harbor.${spec.namespace}.svc.cluster.local"
                    repositoryName = spec.name
                }
            }
            """
            AWS VPC resource generation for network composition.
            """
            
            import schemas.network as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            import schemas.mappings as m
            
            generate_aws = lambda spec: schema.NetworkSpec, ocds: any -> [any] {
                """Generate AWS VPC resources from NetworkSpec."""
                _name = spec.name
                _region = regions.get_aws_region(spec.region) if spec.region else ""
                _cidr = spec.cidrBlock
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "network"
                    provider = "aws"
                    environment = spec.environment
                }
                _tags = labels.generate_tags(_label_config, "aws")
                _k8s_labels = labels.generate_labels(_label_config)
            
                # Get subnets (use defaults if not provided)
                _subnets = spec.subnets or m.get_default_subnets("aws")
            
                resources: [any] = []
            
                # AWS VPC
                resources += [{
                    apiVersion = "ec2.aws.upbound.io/v1beta1"
                    kind = "VPC"
                    metadata = h.metadata_with_labels("${_name}-vpc", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            cidrBlock = _cidr
                            enableDnsSupport = spec.enableDnsSupport
                            enableDnsHostnames = spec.enableDnsHostnames
                            tags = _tags | {"Name": "${_name}-vpc", "network": _name}
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Internet Gateway
                resources += [{
                    apiVersion = "ec2.aws.upbound.io/v1beta1"
                    kind = "InternetGateway"
                    metadata = h.metadata_with_labels("${_name}-igw", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            vpcIdRef = {
                                name = "${_name}-vpc"
                            }
                            tags = _tags | {"Name": "${_name}-igw", "network": _name}
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Subnets
                resources += [
                    {
                        apiVersion = "ec2.aws.upbound.io/v1beta1"
                        kind = "Subnet"
                        metadata = h.metadata_with_labels("${_name}-${subnet.name}", _k8s_labels | {
                            "crossplane.io/network" = _name
                            "crossplane.io/visibility" = subnet.type
                        })
                        spec = {
                            forProvider = {
                                region = _region
                                cidrBlock = subnet.cidrBlock
                                vpcIdRef = {
                                    name = "${_name}-vpc"
                                }
                                availabilityZone = "${_region}${subnet.availabilityZone}" if subnet.availabilityZone else None
                                mapPublicIpOnLaunch = subnet.type == "public"
                                tags = _tags | {"Name": "${_name}-${subnet.name}", "Type": subnet.type, "network": _name}
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }
                    for subnet in _subnets
                ]
            
                # Public Route Table
                resources += [{
                    apiVersion = "ec2.aws.upbound.io/v1beta1"
                    kind = "RouteTable"
                    metadata = h.metadata_with_labels("${_name}-public-rt", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            vpcIdRef = {
                                name = "${_name}-vpc"
                            }
                            tags = _tags | {"Name": "${_name}-public-rt", "network": _name}
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Route to Internet Gateway
                resources += [{
                    apiVersion = "ec2.aws.upbound.io/v1beta1"
                    kind = "Route"
                    metadata = h.metadata_with_labels("${_name}-public-route", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            routeTableIdRef = {
                                name = "${_name}-public-rt"
                            }
                            destinationCidrBlock = "0.0.0.0/0"
                            gatewayIdRef = {
                                name = "${_name}-igw"
                            }
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Route Table Associations for public subnets
                resources += [
                    {
                        apiVersion = "ec2.aws.upbound.io/v1beta1"
                        kind = "RouteTableAssociation"
                        metadata = h.metadata_with_labels("${_name}-${subnet.name}-rta", _k8s_labels)
                        spec = {
                            forProvider = {
                                region = _region
                                routeTableIdRef = {
                                    name = "${_name}-public-rt"
                                }
                                subnetIdRef = {
                                    name = "${_name}-${subnet.name}"
                                }
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }
                    for subnet in _subnets if subnet.type == "public"
                ]
            
                resources
            }
            
            get_status_aws = lambda spec: schema.NetworkSpec, ocds: any -> schema.NetworkStatus {
                """Extract status from observed composed resources."""
                _observed_vpc = ocds.get("${spec.name}-vpc", {})
                _observed_status = _observed_vpc.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _vpc_id = _observed_status.get("id", "")
            
                schema.NetworkStatus {
                    provider = "aws"
                    region = spec.region
                    networkId = _vpc_id
                    cidrBlock = spec.cidrBlock
                }
            }
            """
            GCP Network resource generation for network composition.
            """
            
            import schemas.network as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            import schemas.mappings as m
            
            generate_gcp = lambda spec: schema.NetworkSpec, ocds: any -> [any] {
                """Generate GCP Network resources from NetworkSpec."""
                _name = spec.name
                _region = regions.get_gcp_region(spec.region) if spec.region else ""
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "network"
                    provider = "gcp"
                    environment = spec.environment
                }
                _k8s_labels = labels.generate_labels(_label_config)
            
                # Get subnets (use defaults if not provided)
                _subnets = spec.subnets or m.get_default_subnets("gcp")
            
                resources: [any] = []
            
                # GCP Network (VPC)
                resources += [{
                    apiVersion = "compute.gcp.upbound.io/v1beta1"
                    kind = "Network"
                    metadata = h.metadata_with_labels("${_name}-network", _k8s_labels)
                    spec = {
                        forProvider = {
                            autoCreateSubnetworks = False
                            routingMode = "REGIONAL"
                            description = "Managed by Crossplane - ${_name}"
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Subnetworks
                resources += [
                    {
                        apiVersion = "compute.gcp.upbound.io/v1beta1"
                        kind = "Subnetwork"
                        metadata = h.metadata_with_labels("${_name}-${subnet.name}", _k8s_labels | {
                            "crossplane.io/network" = _name
                            "crossplane.io/visibility" = subnet.type
                        })
                        spec = {
                            forProvider = {
                                region = _region
                                ipCidrRange = subnet.cidrBlock
                                networkRef = {
                                    name = "${_name}-network"
                                }
                                privateIpGoogleAccess = subnet.type == "private"
                                description = "${subnet.type} subnet - ${subnet.name}"
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }
                    for subnet in _subnets
                ]
            
                # Cloud Router for NAT (if there are private subnets)
                _has_private_subnets = any(subnet.type == "private" for subnet in _subnets)
                if _has_private_subnets:
                    resources += [{
                        apiVersion = "compute.gcp.upbound.io/v1beta1"
                        kind = "Router"
                        metadata = h.metadata_with_labels("${_name}-router", _k8s_labels)
                        spec = {
                            forProvider = {
                                region = _region
                                networkRef = {
                                    name = "${_name}-network"
                                }
                                description = "NAT router for ${_name}"
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }]
            
                    # Cloud NAT for private subnet internet access
                    resources += [{
                        apiVersion = "compute.gcp.upbound.io/v1beta1"
                        kind = "RouterNAT"
                        metadata = h.metadata_with_labels("${_name}-nat", _k8s_labels)
                        spec = {
                            forProvider = {
                                region = _region
                                routerRef = {
                                    name = "${_name}-router"
                                }
                                natIpAllocateOption = "AUTO_ONLY"
                                sourceSubnetworkIpRangesToNat = "ALL_SUBNETWORKS_ALL_IP_RANGES"
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }]
            
                resources
            }
            
            get_status_gcp = lambda spec: schema.NetworkSpec, ocds: any -> schema.NetworkStatus {
                """Extract status from observed composed resources."""
                _observed_network = ocds.get("${spec.name}-network", {})
                _observed_status = _observed_network.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _network_id = _observed_status.get("id", "")
            
                schema.NetworkStatus {
                    provider = "gcp"
                    region = spec.region
                    networkId = _network_id
                    cidrBlock = spec.cidrBlock
                }
            }
            """
            AWS S3 resource generation for bucket composition.
            """
            
            import model.io.upbound.aws.s3.v1beta2 as s3
            import model.io.upbound.aws.s3.v1beta1 as s3v1beta1
            import schemas.bucket as schema
            import schemas.labels as labels
            import schemas.helpers as h
            
            generate_aws = lambda spec: schema.BucketSpec, ocds: any -> [any] {
                """Generate AWS S3 resources from BucketSpec."""
                _bucket_name = spec.name
                _region = spec.region
                _storage_class = schema.map_storage_class("aws", spec.storageClass)
                _deletion_policy = spec.deletionPolicy
            
                _label_config = labels.LabelConfig {
                    name = _bucket_name
                    component = "storage"
                    provider = "aws"
                    environment = spec.environment
                }
                _tags = labels.generate_tags(_label_config, "aws") | spec.tags
            
                resources: [any] = []
            
                # Main S3 Bucket
                resources += [s3.Bucket {
                    metadata = h.metadata(_bucket_name)
                    spec = {
                        forProvider = {
                            region = _region
                            tags = _tags
                        }
                        deletionPolicy = _deletion_policy
                    }
                }]
            
                # Bucket versioning
                if spec.versioning:
                    resources += [s3.BucketVersioning {
                        metadata = h.metadata("${_bucket_name}-versioning")
                        spec = {
                            forProvider = {
                                region = _region
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                versioningConfiguration = {
                                    status = "Enabled"
                                }
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                # Server-side encryption
                if spec.encryption:
                    resources += [s3.BucketServerSideEncryptionConfiguration {
                        metadata = h.metadata("${_bucket_name}-encryption")
                        spec = {
                            forProvider = {
                                region = _region
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                $rule = [{
                                    applyServerSideEncryptionByDefault = {
                                        sseAlgorithm = "AES256"
                                    }
                                    bucketKeyEnabled = True
                                }]
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                # Public access block (default: block all public access)
                resources += [s3v1beta1.BucketPublicAccessBlock {
                    metadata = h.metadata("${_bucket_name}-public-access")
                    spec = {
                        forProvider = {
                            region = _region
                            bucketSelector = {
                                matchControllerRef = True
                            }
                            blockPublicAcls = not spec.publicAccess
                            blockPublicPolicy = not spec.publicAccess
                            ignorePublicAcls = not spec.publicAccess
                            restrictPublicBuckets = not spec.publicAccess
                        }
                        deletionPolicy = _deletion_policy
                    }
                }]
            
                # CORS configuration
                if spec.cors:
                    resources += [{
                        apiVersion = "s3.aws.upbound.io/v1beta1"
                        kind = "BucketCorsConfiguration"
                        metadata = h.metadata("${_bucket_name}-cors")
                        spec = {
                            forProvider = {
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                region = _region
                                corsRule = [
                                    {
                                        allowedOrigins = rule.allowedOrigins
                                        allowedMethods = rule.allowedMethods
                                        allowedHeaders = rule.allowedHeaders
                                        maxAgeSeconds = rule.maxAgeSeconds
                                    }
                                    for rule in spec.cors
                                ]
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                # Lifecycle rules
                if spec.lifecycle:
                    resources += [{
                        apiVersion = "s3.aws.upbound.io/v1beta1"
                        kind = "BucketLifecycleConfiguration"
                        metadata = h.metadata("${_bucket_name}-lifecycle")
                        spec = {
                            forProvider = {
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                region = _region
                                $rule = [
                                    _build_lifecycle_rule(rule)
                                    for rule in spec.lifecycle
                                ]
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                resources
            }
            
            _build_lifecycle_rule = lambda rule: schema.LifecycleRule -> any {
                """Build an AWS S3 lifecycle rule."""
                base: {str:any} = {
                    id = rule.name
                    status = "Enabled" if rule.enabled else "Disabled"
                }
            
                if rule.prefix:
                    base |= {filter = [{prefix = rule.prefix}]}
            
                if rule.expirationDays > 0:
                    base |= {expiration = [{days = rule.expirationDays}]}
            
                if rule.transitionDays > 0:
                    base |= {
                        transition = [{
                            days = rule.transitionDays
                            storageClass = schema.map_storage_class("aws", rule.transitionStorageClass)
                        }]
                    }
            
                base
            }
            
            get_status_aws = lambda spec: schema.BucketSpec, ocds: any -> schema.BucketStatus {
                """Extract status from observed composed resources."""
                _observed_bucket = ocds.get(spec.name, {})
                _observed_status = _observed_bucket.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _bucket_id = _observed_status.get("id", spec.name)
                _bucket_domain = _observed_status.get("bucketRegionalDomainName", "")
            
                schema.BucketStatus {
                    provider = "aws"
                    region = spec.region
                    bucketName = _bucket_id
                    url = "s3://${_bucket_id}"
                    id = _bucket_id
                    cloudUrl = "https://${_bucket_domain}" if _bucket_domain else "https://${spec.name}.s3.${spec.region}.amazonaws.com"
                }
            }
            """
            GCP Cloud Storage resource generation for bucket composition.
            """
            
            import model.io.upbound.gcp.storage.v1beta2 as gcs
            import schemas.bucket as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.common as c
            
            generate_gcp = lambda spec: schema.BucketSpec, ocds: any -> [any] {
                """Generate GCP Cloud Storage resources from BucketSpec."""
                _bucket_name = spec.name
                _location = c.map_region("gcp", spec.region).upper()
                _storage_class = schema.map_storage_class("gcp", spec.storageClass)
                _deletion_policy = spec.deletionPolicy
            
                _label_config = labels.LabelConfig {
                    name = _bucket_name
                    component = "storage"
                    provider = "gcp"
                    environment = spec.environment
                }
                _labels = labels.generate_tags(_label_config, "gcp") | {
                    k.lower().replace("-", "_"): v.lower()
                    for k, v in spec.tags
                    if len(k) <= 63 and len(v) <= 63
                }
            
                resources: [any] = []
            
                # Build bucket forProvider config
                _for_provider: {str:any} = {
                    location = _location
                    storageClass = _storage_class
                    labels = _labels
                    uniformBucketLevelAccess = True
                    publicAccessPrevention = "enforced" if not spec.publicAccess else "inherited"
                }
            
                # Add versioning if enabled
                if spec.versioning:
                    _for_provider |= {
                        versioning = [{
                            enabled = True
                        }]
                    }
            
                # Add CORS rules if specified
                if spec.cors:
                    _for_provider |= {
                        cors = [
                            {
                                origin = rule.allowedOrigins
                                method = rule.allowedMethods
                                responseHeader = rule.allowedHeaders
                                maxAgeSeconds = rule.maxAgeSeconds
                            }
                            for rule in spec.cors
                        ]
                    }
            
                # Add lifecycle rules if specified
                if spec.lifecycle:
                    _for_provider |= {
                        lifecycleRule = [
                            _build_lifecycle_rule(rule)
                            for rule in spec.lifecycle
                        ]
                    }
            
                # Main GCS Bucket
                resources += [gcs.Bucket {
                    metadata = h.metadata(_bucket_name)
                    spec = {
                        forProvider = _for_provider
                        deletionPolicy = _deletion_policy
                    }
                }]
            
                # IAM binding for public access if enabled
                if spec.publicAccess:
                    resources += [{
                        apiVersion = "storage.gcp.upbound.io/v1beta1"
                        kind = "BucketIAMMember"
                        metadata = h.metadata("${_bucket_name}-public-read")
                        spec = {
                            forProvider = {
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                role = "roles/storage.objectViewer"
                                member = "allUsers"
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                resources
            }
            
            _build_lifecycle_rule = lambda rule: schema.LifecycleRule -> any {
                """Build a GCP lifecycle rule."""
                result: {str:any} = {
                    action = {}
                    condition = {}
                }
            
                if rule.expirationDays > 0:
                    result.action |= {$type = "Delete"}
                    result.condition |= {age = rule.expirationDays}
                elif rule.transitionDays > 0:
                    result.action |= {
                        $type = "SetStorageClass"
                        storageClass = schema.map_storage_class("gcp", rule.transitionStorageClass)
                    }
                    result.condition |= {age = rule.transitionDays}
            
                if rule.prefix:
                    result.condition |= {matchesPrefix = [rule.prefix]}
            
                result
            }
            
            get_status_gcp = lambda spec: schema.BucketSpec, ocds: any -> schema.BucketStatus {
                """Extract status from observed composed resources."""
                _observed_bucket = ocds.get(spec.name, {})
                _observed_status = _observed_bucket.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _bucket_url = _observed_status.get("url", "")
                _bucket_self_link = _observed_status.get("selfLink", "")
            
                schema.BucketStatus {
                    provider = "gcp"
                    region = spec.region
                    bucketName = spec.name
                    url = _bucket_url if _bucket_url else "gs://${spec.name}"
                    id = spec.name
                    cloudUrl = _bucket_self_link if _bucket_self_link else "https://storage.googleapis.com/${spec.name}"
                }
            }
            """
            AWS RDS resource generation for database composition.
            """
            
            import crossplane_provider_upjet_aws.v1beta2.rds_aws_upbound_io_v1beta2_instance as rds
            import schemas.database as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            
            generate_aws = lambda spec: schema.DatabaseSpec, ocds: any -> [any] {
                """Generate AWS RDS resources from DatabaseSpec."""
                _db_name = spec.region  # use oxr metadata name
                _region = regions.get_aws_region(spec.region) if spec.region else ""
                _instance_class = schema.get_instance_class("aws", spec.size)
                _engine_version = schema.get_engine_version(spec.engine, "aws", spec.engineVersion)
                _storage_type = schema.get_storage_type("aws", spec.storageType)
            
                _label_config = labels.LabelConfig {
                    name = _db_name
                    component = "database"
                    provider = "aws"
                    environment = spec.environment
                }
                _tags = labels.generate_tags(_label_config, "aws") | spec.tags
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # Main RDS Instance using typed schema
                _rds_spec: {str:any} = {
                    forProvider = {
                        region = _region
                        engine = spec.engine
                        engineVersion = _engine_version
                        instanceClass = _instance_class
                        allocatedStorage = spec.storageGB
                        storageType = _storage_type
                        storageEncrypted = True
                        multiAz = spec.multiAZ
                        publiclyAccessible = spec.publiclyAccessible
                        skipFinalSnapshot = spec.environment != "prod"
                        copyTagsToSnapshot = True
                        tags = _tags
                    }
                    deletionPolicy = spec.deletionPolicy
                }
            
                # Add final snapshot identifier for prod
                if spec.environment == "prod":
                    _rds_spec.forProvider |= {
                        finalSnapshotIdentifier = "${_db_name}-final"
                    }
            
                # Add backup configuration
                if spec.backup.enabled:
                    _rds_spec.forProvider |= {
                        backupRetentionPeriod = spec.backup.retentionDays
                        backupWindow = spec.backup.preferredWindow
                    }
            
                # Add password configuration
                if spec.secrets.generatePassword:
                    _rds_spec.forProvider |= {
                        username = "admin"
                        autoGeneratePassword = True
                    }
                    _rds_spec |= {
                        writeConnectionSecretToRef = {
                            name = "${_db_name}-credentials"
                            namespace = "crossplane-system"
                        }
                    }
                elif spec.secrets.passwordSecretRef:
                    _rds_spec.forProvider |= {
                        username = "admin"
                        passwordSecretRef = {
                            name = spec.secrets.passwordSecretRef
                            namespace = "crossplane-system"
                            key = "password"
                        }
                    }
            
                resources += [rds.Instance {
                    metadata = h.metadata_with_labels("${_db_name}-rds", _k8s_labels)
                    spec = _rds_spec
                }]
            
                resources
            }
            
            get_status_aws = lambda spec: schema.DatabaseSpec, ocds: any -> schema.DatabaseStatus {
                """Extract status from observed composed resources."""
                _db_name = spec.region
                _observed_db = ocds.get("${_db_name}-rds", {})
                _observed_status = _observed_db.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _endpoint = _observed_status.get("endpoint", "")
            
                schema.DatabaseStatus {
                    provider = "aws"
                    region = spec.region
                    engine = spec.engine
                    endpoint = _endpoint
                }
            }
            """
            GCP Cloud SQL resource generation for database composition.
            """
            
            import schemas.database as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.common as c
            
            generate_gcp = lambda spec: schema.DatabaseSpec, ocds: any, name: str -> [any] {
                """Generate GCP Cloud SQL resources from DatabaseSpec."""
                _db_name = name
                _region = c.map_region("gcp", spec.region) if spec.region else ""
                _tier = schema.get_instance_class("gcp", spec.size)
                _database_version = _get_gcp_database_version(spec.engine, spec.engineVersion)
            
                _label_config = labels.LabelConfig {
                    name = _db_name
                    component = "database"
                    provider = "gcp"
                    environment = spec.environment
                }
                _user_labels = labels.generate_tags(_label_config, "gcp") | {
                    k.lower().replace("-", "_"): v.lower()
                    for k, v in spec.tags
                    if len(k) <= 63 and len(v) <= 63
                }
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # Build settings
                _settings: {str:any} = {
                    tier = _tier
                    diskSize = spec.storageGB
                    diskType = "PD_SSD"
                    diskAutoresize = True
                    diskAutoresizeLimit = spec.storageGB * 2
                    availabilityType = "REGIONAL" if spec.multiAZ else "ZONAL"
                    userLabels = _user_labels
                    ipConfiguration = {
                        ipv4Enabled = spec.publiclyAccessible
                        requireSsl = True
                    }
                }
            
                # Add backup configuration
                if spec.backup.enabled:
                    _settings |= {
                        backupConfiguration = {
                            enabled = True
                            startTime = spec.backup.preferredWindow.split("-")[0]
                            pointInTimeRecoveryEnabled = True
                            transactionLogRetentionDays = spec.backup.retentionDays
                            backupRetentionSettings = {
                                retainedBackups = spec.backup.retentionDays
                                retentionUnit = "COUNT"
                            }
                        }
                    }
            
                # Main Cloud SQL Instance
                _sql_spec: {str:any} = {
                    forProvider = {
                        region = _region
                        databaseVersion = _database_version
                        deletionProtection = spec.environment == "prod"
                        settings = _settings
                    }
                    deletionPolicy = spec.deletionPolicy
                }
            
                # Add write connection secret if auto-generating password
                if spec.secrets.generatePassword:
                    _sql_spec |= {
                        writeConnectionSecretToRef = {
                            name = "${_db_name}-credentials"
                            namespace = "crossplane-system"
                        }
                    }
            
                resources += [{
                    apiVersion = "sql.gcp.upbound.io/v1beta2"
                    kind = "DatabaseInstance"
                    metadata = h.metadata_with_labels("${_db_name}-cloudsql", _k8s_labels)
                    spec = _sql_spec
                }]
            
                # Create database
                resources += [{
                    apiVersion = "sql.gcp.upbound.io/v1beta1"
                    kind = "Database"
                    metadata = h.metadata_with_labels("${_db_name}-db", _k8s_labels)
                    spec = {
                        forProvider = {
                            instanceSelector = {
                                matchControllerRef = True
                            }
                            charset = "UTF8" if spec.engine == "postgres" else "utf8mb4"
                            collation = "en_US.UTF8" if spec.engine == "postgres" else "utf8mb4_general_ci"
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Create user
                _user_spec: {str:any} = {
                    forProvider = {
                        instanceSelector = {
                            matchControllerRef = True
                        }
                        $type = "BUILT_IN"
                    }
                    deletionPolicy = spec.deletionPolicy
                }
            
                if spec.secrets.generatePassword:
                    _user_spec.forProvider |= {
                        passwordSecretRef = {
                            name = "${_db_name}-user-password"
                            namespace = "crossplane-system"
                            key = "password"
                        }
                    }
                elif spec.secrets.passwordSecretRef:
                    _user_spec.forProvider |= {
                        passwordSecretRef = {
                            name = spec.secrets.passwordSecretRef
                            namespace = "crossplane-system"
                            key = "password"
                        }
                    }
            
                resources += [{
                    apiVersion = "sql.gcp.upbound.io/v1beta1"
                    kind = "User"
                    metadata = h.metadata_with_labels("${_db_name}-user", _k8s_labels)
                    spec = _user_spec
                }]
            
                resources
            }
            
            _get_gcp_database_version = lambda engine: str, version: str -> str {
                """Get the GCP Cloud SQL database version string."""
                if engine == "postgres":
                    "POSTGRES_${version}"
                else:
                    "MYSQL_8_0"
            }
            
            get_status_gcp = lambda spec: schema.DatabaseSpec, ocds: any, name: str -> schema.DatabaseStatus {
                """Extract status from observed composed resources."""
                _db_name = name
                _observed_db = ocds.get("${_db_name}-cloudsql", {})
                _observed_status = _observed_db.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _connection_name = _observed_status.get("connectionName", "")
            
                schema.DatabaseStatus {
                    provider = "gcp"
                    region = spec.region
                    engine = spec.engine
                    endpoint = _connection_name
                }
            }
            """
            Kubernetes CloudNative-PG resource generation for database composition.
            """
            
            import schemas.database as schema
            import schemas.labels as labels
            import schemas.helpers as h
            
            generate_kubernetes = lambda spec: schema.DatabaseSpec, ocds: any, name: str -> [any] {
                """Generate CloudNative-PG Cluster from DatabaseSpec."""
                _db_name = name
                _namespace = spec.namespace
                _resources = schema.get_instance_class("kubernetes", spec.size)
            
                _label_config = labels.LabelConfig {
                    name = _db_name
                    component = "database"
                    provider = "kubernetes"
                    environment = spec.environment
                }
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # CloudNative-PG Cluster
                _cnpg_spec: {str:any} = {
                    instances = spec.instances
                    imageName = "ghcr.io/cloudnative-pg/postgresql:${spec.engineVersion}"
                    postgresql = {
                        parameters = {
                            max_connections = "100"
                            shared_buffers = "128MB"
                        }
                    }
                    bootstrap = {
                        initdb = {
                            database = "app"
                            owner = "app"
                        }
                    }
                    storage = {
                        size = "${spec.storageGB}Gi"
                    }
                    resources = {
                        requests = _resources
                        limits = _resources
                    }
                    monitoring = {
                        enablePodMonitor = spec.environment != "dev"
                    }
                }
            
                # Add backup configuration if enabled
                if spec.backup.enabled:
                    _cnpg_spec |= {
                        backup = {
                            barmanObjectStore = {
                                destinationPath = "s3://${_db_name}-backups/"
                                s3Credentials = {
                                    accessKeyId = {
                                        name = "${_db_name}-backup-creds"
                                        key = "ACCESS_KEY_ID"
                                    }
                                    secretAccessKey = {
                                        name = "${_db_name}-backup-creds"
                                        key = "SECRET_ACCESS_KEY"
                                    }
                                }
                            }
                            retentionPolicy = "${spec.backup.retentionDays}d"
                        }
                    }
            
                resources += [{
                    apiVersion = "postgresql.cnpg.io/v1"
                    kind = "Cluster"
                    metadata = {
                        name = "${_db_name}-cnpg"
                        namespace = _namespace
                        annotations = {
                            "krm.kcl.dev/composition-resource-name" = "${_db_name}-cnpg"
                        }
                        labels = _k8s_labels
                    }
                    spec = _cnpg_spec
                }]
            
                resources
            }
            
            get_status_kubernetes = lambda spec: schema.DatabaseSpec, ocds: any, name: str -> schema.DatabaseStatus {
                """Extract status from observed composed resources."""
                _db_name = name
                _observed_db = ocds.get("${_db_name}-cnpg", {})
                _observed_status = _observed_db.get("Resource", {}).get("status", {}) or {}
            
                _instances_ready = _observed_status.get("instancesReady", 0)
            
                schema.DatabaseStatus {
                    provider = "kubernetes"
                    region = "in-cluster"
                    engine = spec.engine
                    endpoint = "${_db_name}-cnpg-rw.${spec.namespace}.svc.cluster.local:5432" if _instances_ready > 0 else ""
                }
            }
            """
            AWS ECR resource generation for registry composition.
            """
            
            import crossplane_provider_upjet_aws.v1beta2.ecr_aws_upbound_io_v1beta2_repository as ecr
            import crossplane_provider_upjet_aws.v1beta1.ecr_aws_upbound_io_v1beta1_lifecycle_policy as ecr_lifecycle
            import schemas.registry as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            
            generate_aws = lambda spec: schema.RegistrySpec, ocds: any -> [any] {
                """Generate AWS ECR resources from RegistrySpec."""
                _name = spec.name
                _region = regions.get_aws_region(spec.region) if spec.region else ""
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "registry"
                    provider = "aws"
                    environment = spec.environment
                }
                _tags = labels.generate_tags(_label_config, "aws")
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # AWS ECR Repository
                resources += [ecr.Repository {
                    metadata = h.metadata_with_labels("${_name}-ecr", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            imageTagMutability = "IMMUTABLE" if spec.immutableTags else "MUTABLE"
                            imageScanningConfiguration = {
                                scanOnPush = spec.scanOnPush
                            }
                            encryptionConfiguration = [{
                                encryptionType = "AES256"
                            }] if spec.encryption else []
                            tags = _tags
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # AWS ECR Lifecycle Policy for retention
                if spec.retentionDays > 0:
                    resources += [ecr_lifecycle.LifecyclePolicy {
                        metadata = h.metadata_with_labels("${_name}-ecr-lifecycle", _k8s_labels)
                        spec = {
                            forProvider = {
                                region = _region
                                repositorySelector = {
                                    matchControllerRef = True
                                }
                                policy = '''{
                                    "rules": [
                                        {
                                            "rulePriority": 1,
                                            "description": "Expire untagged images older than ''' + str(spec.retentionDays) + ''' days",
                                            "selection": {
                                                "tagStatus": "untagged",
                                                "countType": "sinceImagePushed",
                                                "countUnit": "days",
                                                "countNumber": ''' + str(spec.retentionDays) + '''
                                            },
                                            "action": {
                                                "type": "expire"
                                            }
                                        }
                                    ]
                                }'''
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }]
            
                resources
            }
            
            get_status_aws = lambda spec: schema.RegistrySpec, ocds: any -> schema.RegistryStatus {
                """Extract status from observed composed resources."""
                _observed_ecr = ocds.get("${spec.name}-ecr", {})
                _observed_status = _observed_ecr.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _registry_url = _observed_status.get("repositoryUrl", "")
            
                schema.RegistryStatus {
                    provider = "aws"
                    region = spec.region
                    registryUrl = _registry_url
                    repositoryName = spec.name
                }
            }
            """
            GCP Artifact Registry resource generation for registry composition.
            """
            
            import crossplane_provider_upjet_gcp.v1beta1.artifact_gcp_upbound_io_v1beta1_registry_repository as artifact
            import schemas.registry as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            
            generate_gcp = lambda spec: schema.RegistrySpec, ocds: any -> [any] {
                """Generate GCP Artifact Registry resources from RegistrySpec."""
                _name = spec.name
                _region = regions.get_gcp_region(spec.region) if spec.region else ""
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "registry"
                    provider = "gcp"
                    environment = spec.environment
                }
                _gcp_labels = labels.generate_tags(_label_config, "gcp")
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # GCP Artifact Registry Repository
                resources += [artifact.RegistryRepository {
                    metadata = h.metadata_with_labels("${_name}-artifactregistry", _k8s_labels)
                    spec = {
                        forProvider = {
                            location = _region
                            format = spec.format.upper()
                            mode = "STANDARD_REPOSITORY"
                            labels = _gcp_labels
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                resources
            }
            
            get_status_gcp = lambda spec: schema.RegistrySpec, ocds: any -> schema.RegistryStatus {
                """Extract status from observed composed resources."""
                _observed_artifact = ocds.get("${spec.name}-artifactregistry", {})
                _observed_status = _observed_artifact.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _name = _observed_status.get("name", "")
                _region = spec.region
            
                schema.RegistryStatus {
                    provider = "gcp"
                    region = _region
                    registryUrl = "${_region}-docker.pkg.dev/${_name}" if _name else ""
                    repositoryName = spec.name
                }
            }
            """
            Kubernetes Harbor resource generation for registry composition.
            """
            
            import schemas.registry as schema
            import schemas.labels as labels
            import schemas.helpers as h
            
            generate_kubernetes = lambda spec: schema.RegistrySpec, ocds: any -> [any] {
                """Generate Harbor resources from RegistrySpec."""
                _name = spec.name
                _namespace = spec.namespace
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "registry"
                    provider = "kubernetes"
                    environment = spec.environment
                }
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # Harbor Cluster (using goharbor-operator)
                resources += [{
                    apiVersion = "goharbor.io/v1beta1"
                    kind = "HarborCluster"
                    metadata = {
                        name = "${_name}-harbor"
                        namespace = _namespace
                        annotations = {
                            "krm.kcl.dev/composition-resource-name" = "${_name}-harbor"
                        }
                        labels = _k8s_labels
                    }
                    spec = {
                        version = "2.11.0"
                        externalURL = "https://${_name}-harbor.${_namespace}.svc.cluster.local"
                        expose = {
                            core = {
                                ingress = {
                                    host = "${_name}-harbor.local"
                                }
                            }
                        }
                        database = {
                            kind = "PostgreSQL"
                            spec = {
                                embedded = {}
                            }
                        }
                        storage = {
                            kind = "FileSystem"
                            spec = {
                                fileSystem = {
                                    rootdirectory = "/storage"
                                }
                            }
                        }
                        cache = {
                            kind = "Redis"
                            spec = {
                                embedded = {}
                            }
                        }
                    }
                }]
            
                resources
            }
            
            get_status_kubernetes = lambda spec: schema.RegistrySpec, ocds: any -> schema.RegistryStatus {
                """Extract status from observed composed resources."""
                _observed_harbor = ocds.get("${spec.name}-harbor", {})
                _observed_status = _observed_harbor.get("Resource", {}).get("status", {}) or {}
            
                _external_url = _observed_status.get("externalURL", "")
            
                schema.RegistryStatus {
                    provider = "kubernetes"
                    region = "in-cluster"
                    registryUrl = _external_url if _external_url else "https://${spec.name}-harbor.${spec.namespace}.svc.cluster.local"
                    repositoryName = spec.name
                }
            }
            """
            AWS VPC resource generation for network composition.
            """
            
            import schemas.network as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            import schemas.mappings as m
            
            generate_aws = lambda spec: schema.NetworkSpec, ocds: any -> [any] {
                """Generate AWS VPC resources from NetworkSpec."""
                _name = spec.name
                _region = regions.get_aws_region(spec.region) if spec.region else ""
                _cidr = spec.cidrBlock
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "network"
                    provider = "aws"
                    environment = spec.environment
                }
                _tags = labels.generate_tags(_label_config, "aws")
                _k8s_labels = labels.generate_labels(_label_config)
            
                # Get subnets (use defaults if not provided)
                _subnets = spec.subnets or m.get_default_subnets("aws")
            
                resources: [any] = []
            
                # AWS VPC
                resources += [{
                    apiVersion = "ec2.aws.upbound.io/v1beta1"
                    kind = "VPC"
                    metadata = h.metadata_with_labels("${_name}-vpc", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            cidrBlock = _cidr
                            enableDnsSupport = spec.enableDnsSupport
                            enableDnsHostnames = spec.enableDnsHostnames
                            tags = _tags | {"Name": "${_name}-vpc", "network": _name}
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Internet Gateway
                resources += [{
                    apiVersion = "ec2.aws.upbound.io/v1beta1"
                    kind = "InternetGateway"
                    metadata = h.metadata_with_labels("${_name}-igw", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            vpcIdRef = {
                                name = "${_name}-vpc"
                            }
                            tags = _tags | {"Name": "${_name}-igw", "network": _name}
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Subnets
                resources += [
                    {
                        apiVersion = "ec2.aws.upbound.io/v1beta1"
                        kind = "Subnet"
                        metadata = h.metadata_with_labels("${_name}-${subnet.name}", _k8s_labels | {
                            "crossplane.io/network" = _name
                            "crossplane.io/visibility" = subnet.type
                        })
                        spec = {
                            forProvider = {
                                region = _region
                                cidrBlock = subnet.cidrBlock
                                vpcIdRef = {
                                    name = "${_name}-vpc"
                                }
                                availabilityZone = "${_region}${subnet.availabilityZone}" if subnet.availabilityZone else None
                                mapPublicIpOnLaunch = subnet.type == "public"
                                tags = _tags | {"Name": "${_name}-${subnet.name}", "Type": subnet.type, "network": _name}
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }
                    for subnet in _subnets
                ]
            
                # Public Route Table
                resources += [{
                    apiVersion = "ec2.aws.upbound.io/v1beta1"
                    kind = "RouteTable"
                    metadata = h.metadata_with_labels("${_name}-public-rt", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            vpcIdRef = {
                                name = "${_name}-vpc"
                            }
                            tags = _tags | {"Name": "${_name}-public-rt", "network": _name}
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Route to Internet Gateway
                resources += [{
                    apiVersion = "ec2.aws.upbound.io/v1beta1"
                    kind = "Route"
                    metadata = h.metadata_with_labels("${_name}-public-route", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            routeTableIdRef = {
                                name = "${_name}-public-rt"
                            }
                            destinationCidrBlock = "0.0.0.0/0"
                            gatewayIdRef = {
                                name = "${_name}-igw"
                            }
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Route Table Associations for public subnets
                resources += [
                    {
                        apiVersion = "ec2.aws.upbound.io/v1beta1"
                        kind = "RouteTableAssociation"
                        metadata = h.metadata_with_labels("${_name}-${subnet.name}-rta", _k8s_labels)
                        spec = {
                            forProvider = {
                                region = _region
                                routeTableIdRef = {
                                    name = "${_name}-public-rt"
                                }
                                subnetIdRef = {
                                    name = "${_name}-${subnet.name}"
                                }
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }
                    for subnet in _subnets if subnet.type == "public"
                ]
            
                resources
            }
            
            get_status_aws = lambda spec: schema.NetworkSpec, ocds: any -> schema.NetworkStatus {
                """Extract status from observed composed resources."""
                _observed_vpc = ocds.get("${spec.name}-vpc", {})
                _observed_status = _observed_vpc.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _vpc_id = _observed_status.get("id", "")
            
                schema.NetworkStatus {
                    provider = "aws"
                    region = spec.region
                    networkId = _vpc_id
                    cidrBlock = spec.cidrBlock
                }
            }
            """
            GCP Network resource generation for network composition.
            """
            
            import schemas.network as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            import schemas.mappings as m
            
            generate_gcp = lambda spec: schema.NetworkSpec, ocds: any -> [any] {
                """Generate GCP Network resources from NetworkSpec."""
                _name = spec.name
                _region = regions.get_gcp_region(spec.region) if spec.region else ""
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "network"
                    provider = "gcp"
                    environment = spec.environment
                }
                _k8s_labels = labels.generate_labels(_label_config)
            
                # Get subnets (use defaults if not provided)
                _subnets = spec.subnets or m.get_default_subnets("gcp")
            
                resources: [any] = []
            
                # GCP Network (VPC)
                resources += [{
                    apiVersion = "compute.gcp.upbound.io/v1beta1"
                    kind = "Network"
                    metadata = h.metadata_with_labels("${_name}-network", _k8s_labels)
                    spec = {
                        forProvider = {
                            autoCreateSubnetworks = False
                            routingMode = "REGIONAL"
                            description = "Managed by Crossplane - ${_name}"
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Subnetworks
                resources += [
                    {
                        apiVersion = "compute.gcp.upbound.io/v1beta1"
                        kind = "Subnetwork"
                        metadata = h.metadata_with_labels("${_name}-${subnet.name}", _k8s_labels | {
                            "crossplane.io/network" = _name
                            "crossplane.io/visibility" = subnet.type
                        })
                        spec = {
                            forProvider = {
                                region = _region
                                ipCidrRange = subnet.cidrBlock
                                networkRef = {
                                    name = "${_name}-network"
                                }
                                privateIpGoogleAccess = subnet.type == "private"
                                description = "${subnet.type} subnet - ${subnet.name}"
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }
                    for subnet in _subnets
                ]
            
                # Cloud Router for NAT (if there are private subnets)
                _has_private_subnets = any(subnet.type == "private" for subnet in _subnets)
                if _has_private_subnets:
                    resources += [{
                        apiVersion = "compute.gcp.upbound.io/v1beta1"
                        kind = "Router"
                        metadata = h.metadata_with_labels("${_name}-router", _k8s_labels)
                        spec = {
                            forProvider = {
                                region = _region
                                networkRef = {
                                    name = "${_name}-network"
                                }
                                description = "NAT router for ${_name}"
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }]
            
                    # Cloud NAT for private subnet internet access
                    resources += [{
                        apiVersion = "compute.gcp.upbound.io/v1beta1"
                        kind = "RouterNAT"
                        metadata = h.metadata_with_labels("${_name}-nat", _k8s_labels)
                        spec = {
                            forProvider = {
                                region = _region
                                routerRef = {
                                    name = "${_name}-router"
                                }
                                natIpAllocateOption = "AUTO_ONLY"
                                sourceSubnetworkIpRangesToNat = "ALL_SUBNETWORKS_ALL_IP_RANGES"
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }]
            
                resources
            }
            
            get_status_gcp = lambda spec: schema.NetworkSpec, ocds: any -> schema.NetworkStatus {
                """Extract status from observed composed resources."""
                _observed_network = ocds.get("${spec.name}-network", {})
                _observed_status = _observed_network.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _network_id = _observed_status.get("id", "")
            
                schema.NetworkStatus {
                    provider = "gcp"
                    region = spec.region
                    networkId = _network_id
                    cidrBlock = spec.cidrBlock
                }
            }
            """
            AWS S3 resource generation for bucket composition.
            """
            
            import model.io.upbound.aws.s3.v1beta2 as s3
            import model.io.upbound.aws.s3.v1beta1 as s3v1beta1
            import schemas.bucket as schema
            import schemas.labels as labels
            import schemas.helpers as h
            
            generate_aws = lambda spec: schema.BucketSpec, ocds: any -> [any] {
                """Generate AWS S3 resources from BucketSpec."""
                _bucket_name = spec.name
                _region = spec.region
                _storage_class = schema.map_storage_class("aws", spec.storageClass)
                _deletion_policy = spec.deletionPolicy
            
                _label_config = labels.LabelConfig {
                    name = _bucket_name
                    component = "storage"
                    provider = "aws"
                    environment = spec.environment
                }
                _tags = labels.generate_tags(_label_config, "aws") | spec.tags
            
                resources: [any] = []
            
                # Main S3 Bucket
                resources += [s3.Bucket {
                    metadata = h.metadata(_bucket_name)
                    spec = {
                        forProvider = {
                            region = _region
                            tags = _tags
                        }
                        deletionPolicy = _deletion_policy
                    }
                }]
            
                # Bucket versioning
                if spec.versioning:
                    resources += [s3.BucketVersioning {
                        metadata = h.metadata("${_bucket_name}-versioning")
                        spec = {
                            forProvider = {
                                region = _region
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                versioningConfiguration = {
                                    status = "Enabled"
                                }
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                # Server-side encryption
                if spec.encryption:
                    resources += [s3.BucketServerSideEncryptionConfiguration {
                        metadata = h.metadata("${_bucket_name}-encryption")
                        spec = {
                            forProvider = {
                                region = _region
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                $rule = [{
                                    applyServerSideEncryptionByDefault = {
                                        sseAlgorithm = "AES256"
                                    }
                                    bucketKeyEnabled = True
                                }]
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                # Public access block (default: block all public access)
                resources += [s3v1beta1.BucketPublicAccessBlock {
                    metadata = h.metadata("${_bucket_name}-public-access")
                    spec = {
                        forProvider = {
                            region = _region
                            bucketSelector = {
                                matchControllerRef = True
                            }
                            blockPublicAcls = not spec.publicAccess
                            blockPublicPolicy = not spec.publicAccess
                            ignorePublicAcls = not spec.publicAccess
                            restrictPublicBuckets = not spec.publicAccess
                        }
                        deletionPolicy = _deletion_policy
                    }
                }]
            
                # CORS configuration
                if spec.cors:
                    resources += [{
                        apiVersion = "s3.aws.upbound.io/v1beta1"
                        kind = "BucketCorsConfiguration"
                        metadata = h.metadata("${_bucket_name}-cors")
                        spec = {
                            forProvider = {
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                region = _region
                                corsRule = [
                                    {
                                        allowedOrigins = rule.allowedOrigins
                                        allowedMethods = rule.allowedMethods
                                        allowedHeaders = rule.allowedHeaders
                                        maxAgeSeconds = rule.maxAgeSeconds
                                    }
                                    for rule in spec.cors
                                ]
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                # Lifecycle rules
                if spec.lifecycle:
                    resources += [{
                        apiVersion = "s3.aws.upbound.io/v1beta1"
                        kind = "BucketLifecycleConfiguration"
                        metadata = h.metadata("${_bucket_name}-lifecycle")
                        spec = {
                            forProvider = {
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                region = _region
                                $rule = [
                                    _build_lifecycle_rule(rule)
                                    for rule in spec.lifecycle
                                ]
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                resources
            }
            
            _build_lifecycle_rule = lambda rule: schema.LifecycleRule -> any {
                """Build an AWS S3 lifecycle rule."""
                base: {str:any} = {
                    id = rule.name
                    status = "Enabled" if rule.enabled else "Disabled"
                }
            
                if rule.prefix:
                    base |= {$filter = [{prefix = rule.prefix}]}
            
                if rule.expirationDays > 0:
                    base |= {$expiration = [{days = rule.expirationDays}]}
            
                if rule.transitionDays > 0:
                    base |= {
                        $transition = [{
                            days = rule.transitionDays
                            storageClass = schema.map_storage_class("aws", rule.transitionStorageClass)
                        }]
                    }
            
                base
            }
            
            get_status_aws = lambda spec: schema.BucketSpec, ocds: any -> schema.BucketStatus {
                """Extract status from observed composed resources."""
                _observed_bucket = ocds.get(spec.name, {})
                _observed_status = _observed_bucket.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _bucket_id = _observed_status.get("id", spec.name)
                _bucket_domain = _observed_status.get("bucketRegionalDomainName", "")
            
                schema.BucketStatus {
                    provider = "aws"
                    region = spec.region
                    bucketName = _bucket_id
                    url = "s3://${_bucket_id}"
                    id = _bucket_id
                    cloudUrl = "https://${_bucket_domain}" if _bucket_domain else "https://${spec.name}.s3.${spec.region}.amazonaws.com"
                }
            }
            """
            GCP Cloud Storage resource generation for bucket composition.
            """
            
            import model.io.upbound.gcp.storage.v1beta2 as gcs
            import schemas.bucket as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.common as c
            
            generate_gcp = lambda spec: schema.BucketSpec, ocds: any -> [any] {
                """Generate GCP Cloud Storage resources from BucketSpec."""
                _bucket_name = spec.name
                _location = c.map_region("gcp", spec.region).upper()
                _storage_class = schema.map_storage_class("gcp", spec.storageClass)
                _deletion_policy = spec.deletionPolicy
            
                _label_config = labels.LabelConfig {
                    name = _bucket_name
                    component = "storage"
                    provider = "gcp"
                    environment = spec.environment
                }
                _labels = labels.generate_tags(_label_config, "gcp") | {
                    k.lower().replace("-", "_"): v.lower()
                    for k, v in spec.tags
                    if len(k) <= 63 and len(v) <= 63
                }
            
                resources: [any] = []
            
                # Build bucket forProvider config
                _for_provider: {str:any} = {
                    location = _location
                    storageClass = _storage_class
                    labels = _labels
                    uniformBucketLevelAccess = True
                    publicAccessPrevention = "enforced" if not spec.publicAccess else "inherited"
                }
            
                # Add versioning if enabled
                if spec.versioning:
                    _for_provider |= {
                        versioning = [{
                            enabled = True
                        }]
                    }
            
                # Add CORS rules if specified
                if spec.cors:
                    _for_provider |= {
                        cors = [
                            {
                                origin = rule.allowedOrigins
                                method = rule.allowedMethods
                                responseHeader = rule.allowedHeaders
                                maxAgeSeconds = rule.maxAgeSeconds
                            }
                            for rule in spec.cors
                        ]
                    }
            
                # Add lifecycle rules if specified
                if spec.lifecycle:
                    _for_provider |= {
                        lifecycleRule = [
                            _build_lifecycle_rule(rule)
                            for rule in spec.lifecycle
                        ]
                    }
            
                # Main GCS Bucket
                resources += [gcs.Bucket {
                    metadata = h.metadata(_bucket_name)
                    spec = {
                        forProvider = _for_provider
                        deletionPolicy = _deletion_policy
                    }
                }]
            
                # IAM binding for public access if enabled
                if spec.publicAccess:
                    resources += [{
                        apiVersion = "storage.gcp.upbound.io/v1beta1"
                        kind = "BucketIAMMember"
                        metadata = h.metadata("${_bucket_name}-public-read")
                        spec = {
                            forProvider = {
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                role = "roles/storage.objectViewer"
                                member = "allUsers"
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                resources
            }
            
            _build_lifecycle_rule = lambda rule: schema.LifecycleRule -> any {
                """Build a GCP lifecycle rule."""
                result: {str:any} = {
                    action = {}
                    condition = {}
                }
            
                if rule.expirationDays > 0:
                    result.action |= {$type = "Delete"}
                    result.condition |= {age = rule.expirationDays}
                elif rule.transitionDays > 0:
                    result.action |= {
                        $type = "SetStorageClass"
                        storageClass = schema.map_storage_class("gcp", rule.transitionStorageClass)
                    }
                    result.condition |= {age = rule.transitionDays}
            
                if rule.prefix:
                    result.condition |= {matchesPrefix = [rule.prefix]}
            
                result
            }
            
            get_status_gcp = lambda spec: schema.BucketSpec, ocds: any -> schema.BucketStatus {
                """Extract status from observed composed resources."""
                _observed_bucket = ocds.get(spec.name, {})
                _observed_status = _observed_bucket.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _bucket_url = _observed_status.get("url", "")
                _bucket_self_link = _observed_status.get("selfLink", "")
            
                schema.BucketStatus {
                    provider = "gcp"
                    region = spec.region
                    bucketName = spec.name
                    url = _bucket_url if _bucket_url else "gs://${spec.name}"
                    id = spec.name
                    cloudUrl = _bucket_self_link if _bucket_self_link else "https://storage.googleapis.com/${spec.name}"
                }
            }
            """
            AWS RDS resource generation for database composition.
            """
            
            import crossplane_provider_upjet_aws.v1beta2.rds_aws_upbound_io_v1beta2_instance as rds
            import schemas.database as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            
            generate_aws = lambda spec: schema.DatabaseSpec, ocds: any -> [any] {
                """Generate AWS RDS resources from DatabaseSpec."""
                _db_name = spec.region  # use oxr metadata name
                _region = regions.get_aws_region(spec.region) if spec.region else ""
                _instance_class = schema.get_instance_class("aws", spec.size)
                _engine_version = schema.get_engine_version(spec.engine, "aws", spec.engineVersion)
                _storage_type = schema.get_storage_type("aws", spec.storageType)
            
                _label_config = labels.LabelConfig {
                    name = _db_name
                    component = "database"
                    provider = "aws"
                    environment = spec.environment
                }
                _tags = labels.generate_tags(_label_config, "aws") | spec.tags
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # Main RDS Instance using typed schema
                _rds_spec: {str:any} = {
                    forProvider = {
                        region = _region
                        engine = spec.engine
                        engineVersion = _engine_version
                        instanceClass = _instance_class
                        allocatedStorage = spec.storageGB
                        storageType = _storage_type
                        storageEncrypted = True
                        multiAz = spec.multiAZ
                        publiclyAccessible = spec.publiclyAccessible
                        skipFinalSnapshot = spec.environment != "prod"
                        copyTagsToSnapshot = True
                        tags = _tags
                    }
                    deletionPolicy = spec.deletionPolicy
                }
            
                # Add final snapshot identifier for prod
                if spec.environment == "prod":
                    _rds_spec.forProvider |= {
                        finalSnapshotIdentifier = "${_db_name}-final"
                    }
            
                # Add backup configuration
                if spec.backup.enabled:
                    _rds_spec.forProvider |= {
                        backupRetentionPeriod = spec.backup.retentionDays
                        backupWindow = spec.backup.preferredWindow
                    }
            
                # Add password configuration
                if spec.secrets.generatePassword:
                    _rds_spec.forProvider |= {
                        username = "admin"
                        autoGeneratePassword = True
                    }
                    _rds_spec |= {
                        writeConnectionSecretToRef = {
                            name = "${_db_name}-credentials"
                            namespace = "crossplane-system"
                        }
                    }
                elif spec.secrets.passwordSecretRef:
                    _rds_spec.forProvider |= {
                        username = "admin"
                        passwordSecretRef = {
                            name = spec.secrets.passwordSecretRef
                            namespace = "crossplane-system"
                            key = "password"
                        }
                    }
            
                resources += [rds.Instance {
                    metadata = h.metadata_with_labels("${_db_name}-rds", _k8s_labels)
                    spec = _rds_spec
                }]
            
                resources
            }
            
            get_status_aws = lambda spec: schema.DatabaseSpec, ocds: any -> schema.DatabaseStatus {
                """Extract status from observed composed resources."""
                _db_name = spec.region
                _observed_db = ocds.get("${_db_name}-rds", {})
                _observed_status = _observed_db.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _endpoint = _observed_status.get("endpoint", "")
            
                schema.DatabaseStatus {
                    provider = "aws"
                    region = spec.region
                    engine = spec.engine
                    endpoint = _endpoint
                }
            }
            """
            GCP Cloud SQL resource generation for database composition.
            """
            
            import schemas.database as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.common as c
            
            generate_gcp = lambda spec: schema.DatabaseSpec, ocds: any, name: str -> [any] {
                """Generate GCP Cloud SQL resources from DatabaseSpec."""
                _db_name = name
                _region = c.map_region("gcp", spec.region) if spec.region else ""
                _tier = schema.get_instance_class("gcp", spec.size)
                _database_version = _get_gcp_database_version(spec.engine, spec.engineVersion)
            
                _label_config = labels.LabelConfig {
                    name = _db_name
                    component = "database"
                    provider = "gcp"
                    environment = spec.environment
                }
                _user_labels = labels.generate_tags(_label_config, "gcp") | {
                    k.lower().replace("-", "_"): v.lower()
                    for k, v in spec.tags
                    if len(k) <= 63 and len(v) <= 63
                }
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # Build settings
                _settings: {str:any} = {
                    tier = _tier
                    diskSize = spec.storageGB
                    diskType = "PD_SSD"
                    diskAutoresize = True
                    diskAutoresizeLimit = spec.storageGB * 2
                    availabilityType = "REGIONAL" if spec.multiAZ else "ZONAL"
                    userLabels = _user_labels
                    ipConfiguration = {
                        ipv4Enabled = spec.publiclyAccessible
                        requireSsl = True
                    }
                }
            
                # Add backup configuration
                if spec.backup.enabled:
                    _settings |= {
                        backupConfiguration = {
                            enabled = True
                            startTime = spec.backup.preferredWindow.split("-")[0]
                            pointInTimeRecoveryEnabled = True
                            transactionLogRetentionDays = spec.backup.retentionDays
                            backupRetentionSettings = {
                                retainedBackups = spec.backup.retentionDays
                                retentionUnit = "COUNT"
                            }
                        }
                    }
            
                # Main Cloud SQL Instance
                _sql_spec: {str:any} = {
                    forProvider = {
                        region = _region
                        databaseVersion = _database_version
                        deletionProtection = spec.environment == "prod"
                        settings = _settings
                    }
                    deletionPolicy = spec.deletionPolicy
                }
            
                # Add write connection secret if auto-generating password
                if spec.secrets.generatePassword:
                    _sql_spec |= {
                        writeConnectionSecretToRef = {
                            name = "${_db_name}-credentials"
                            namespace = "crossplane-system"
                        }
                    }
            
                resources += [{
                    apiVersion = "sql.gcp.upbound.io/v1beta2"
                    kind = "DatabaseInstance"
                    metadata = h.metadata_with_labels("${_db_name}-cloudsql", _k8s_labels)
                    spec = _sql_spec
                }]
            
                # Create database
                resources += [{
                    apiVersion = "sql.gcp.upbound.io/v1beta1"
                    kind = "Database"
                    metadata = h.metadata_with_labels("${_db_name}-db", _k8s_labels)
                    spec = {
                        forProvider = {
                            instanceSelector = {
                                matchControllerRef = True
                            }
                            charset = "UTF8" if spec.engine == "postgres" else "utf8mb4"
                            collation = "en_US.UTF8" if spec.engine == "postgres" else "utf8mb4_general_ci"
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Create user
                _user_spec: {str:any} = {
                    forProvider = {
                        instanceSelector = {
                            matchControllerRef = True
                        }
                        $type = "BUILT_IN"
                    }
                    deletionPolicy = spec.deletionPolicy
                }
            
                if spec.secrets.generatePassword:
                    _user_spec.forProvider |= {
                        passwordSecretRef = {
                            name = "${_db_name}-user-password"
                            namespace = "crossplane-system"
                            key = "password"
                        }
                    }
                elif spec.secrets.passwordSecretRef:
                    _user_spec.forProvider |= {
                        passwordSecretRef = {
                            name = spec.secrets.passwordSecretRef
                            namespace = "crossplane-system"
                            key = "password"
                        }
                    }
            
                resources += [{
                    apiVersion = "sql.gcp.upbound.io/v1beta1"
                    kind = "User"
                    metadata = h.metadata_with_labels("${_db_name}-user", _k8s_labels)
                    spec = _user_spec
                }]
            
                resources
            }
            
            _get_gcp_database_version = lambda engine: str, version: str -> str {
                """Get the GCP Cloud SQL database version string."""
                if engine == "postgres":
                    "POSTGRES_${version}"
                else:
                    "MYSQL_8_0"
            }
            
            get_status_gcp = lambda spec: schema.DatabaseSpec, ocds: any, name: str -> schema.DatabaseStatus {
                """Extract status from observed composed resources."""
                _db_name = name
                _observed_db = ocds.get("${_db_name}-cloudsql", {})
                _observed_status = _observed_db.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _connection_name = _observed_status.get("connectionName", "")
            
                schema.DatabaseStatus {
                    provider = "gcp"
                    region = spec.region
                    engine = spec.engine
                    endpoint = _connection_name
                }
            }
            """
            Kubernetes CloudNative-PG resource generation for database composition.
            """
            
            import schemas.database as schema
            import schemas.labels as labels
            import schemas.helpers as h
            
            generate_kubernetes = lambda spec: schema.DatabaseSpec, ocds: any, name: str -> [any] {
                """Generate CloudNative-PG Cluster from DatabaseSpec."""
                _db_name = name
                _namespace = spec.namespace
                _resources = schema.get_instance_class("kubernetes", spec.size)
            
                _label_config = labels.LabelConfig {
                    name = _db_name
                    component = "database"
                    provider = "kubernetes"
                    environment = spec.environment
                }
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # CloudNative-PG Cluster
                _cnpg_spec: {str:any} = {
                    instances = spec.instances
                    imageName = "ghcr.io/cloudnative-pg/postgresql:${spec.engineVersion}"
                    postgresql = {
                        parameters = {
                            max_connections = "100"
                            shared_buffers = "128MB"
                        }
                    }
                    bootstrap = {
                        initdb = {
                            database = "app"
                            owner = "app"
                        }
                    }
                    storage = {
                        size = "${spec.storageGB}Gi"
                    }
                    resources = {
                        requests = _resources
                        limits = _resources
                    }
                    monitoring = {
                        enablePodMonitor = spec.environment != "dev"
                    }
                }
            
                # Add backup configuration if enabled
                if spec.backup.enabled:
                    _cnpg_spec |= {
                        backup = {
                            barmanObjectStore = {
                                destinationPath = "s3://${_db_name}-backups/"
                                s3Credentials = {
                                    accessKeyId = {
                                        name = "${_db_name}-backup-creds"
                                        key = "ACCESS_KEY_ID"
                                    }
                                    secretAccessKey = {
                                        name = "${_db_name}-backup-creds"
                                        key = "SECRET_ACCESS_KEY"
                                    }
                                }
                            }
                            retentionPolicy = "${spec.backup.retentionDays}d"
                        }
                    }
            
                resources += [{
                    apiVersion = "postgresql.cnpg.io/v1"
                    kind = "Cluster"
                    metadata = {
                        name = "${_db_name}-cnpg"
                        namespace = _namespace
                        annotations = {
                            "krm.kcl.dev/composition-resource-name" = "${_db_name}-cnpg"
                        }
                        labels = _k8s_labels
                    }
                    spec = _cnpg_spec
                }]
            
                resources
            }
            
            get_status_kubernetes = lambda spec: schema.DatabaseSpec, ocds: any, name: str -> schema.DatabaseStatus {
                """Extract status from observed composed resources."""
                _db_name = name
                _observed_db = ocds.get("${_db_name}-cnpg", {})
                _observed_status = _observed_db.get("Resource", {}).get("status", {}) or {}
            
                _instances_ready = _observed_status.get("instancesReady", 0)
            
                schema.DatabaseStatus {
                    provider = "kubernetes"
                    region = "in-cluster"
                    engine = spec.engine
                    endpoint = "${_db_name}-cnpg-rw.${spec.namespace}.svc.cluster.local:5432" if _instances_ready > 0 else ""
                }
            }
            """
            AWS ECR resource generation for registry composition.
            """
            
            import crossplane_provider_upjet_aws.v1beta2.ecr_aws_upbound_io_v1beta2_repository as ecr
            import crossplane_provider_upjet_aws.v1beta1.ecr_aws_upbound_io_v1beta1_lifecycle_policy as ecr_lifecycle
            import schemas.registry as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            
            generate_aws = lambda spec: schema.RegistrySpec, ocds: any -> [any] {
                """Generate AWS ECR resources from RegistrySpec."""
                _name = spec.name
                _region = regions.get_aws_region(spec.region) if spec.region else ""
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "registry"
                    provider = "aws"
                    environment = spec.environment
                }
                _tags = labels.generate_tags(_label_config, "aws")
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # AWS ECR Repository
                resources += [ecr.Repository {
                    metadata = h.metadata_with_labels("${_name}-ecr", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            imageTagMutability = "IMMUTABLE" if spec.immutableTags else "MUTABLE"
                            imageScanningConfiguration = {
                                scanOnPush = spec.scanOnPush
                            }
                            encryptionConfiguration = [{
                                encryptionType = "AES256"
                            }] if spec.encryption else []
                            tags = _tags
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # AWS ECR Lifecycle Policy for retention
                if spec.retentionDays > 0:
                    resources += [ecr_lifecycle.LifecyclePolicy {
                        metadata = h.metadata_with_labels("${_name}-ecr-lifecycle", _k8s_labels)
                        spec = {
                            forProvider = {
                                region = _region
                                repositorySelector = {
                                    matchControllerRef = True
                                }
                                policy = '''{
                                    "rules": [
                                        {
                                            "rulePriority": 1,
                                            "description": "Expire untagged images older than ''' + str(spec.retentionDays) + ''' days",
                                            "selection": {
                                                "tagStatus": "untagged",
                                                "countType": "sinceImagePushed",
                                                "countUnit": "days",
                                                "countNumber": ''' + str(spec.retentionDays) + '''
                                            },
                                            "action": {
                                                "type": "expire"
                                            }
                                        }
                                    ]
                                }'''
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }]
            
                resources
            }
            
            get_status_aws = lambda spec: schema.RegistrySpec, ocds: any -> schema.RegistryStatus {
                """Extract status from observed composed resources."""
                _observed_ecr = ocds.get("${spec.name}-ecr", {})
                _observed_status = _observed_ecr.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _registry_url = _observed_status.get("repositoryUrl", "")
            
                schema.RegistryStatus {
                    provider = "aws"
                    region = spec.region
                    registryUrl = _registry_url
                    repositoryName = spec.name
                }
            }
            """
            GCP Artifact Registry resource generation for registry composition.
            """
            
            import crossplane_provider_upjet_gcp.v1beta1.artifact_gcp_upbound_io_v1beta1_registry_repository as artifact
            import schemas.registry as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            
            generate_gcp = lambda spec: schema.RegistrySpec, ocds: any -> [any] {
                """Generate GCP Artifact Registry resources from RegistrySpec."""
                _name = spec.name
                _region = regions.get_gcp_region(spec.region) if spec.region else ""
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "registry"
                    provider = "gcp"
                    environment = spec.environment
                }
                _gcp_labels = labels.generate_tags(_label_config, "gcp")
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # GCP Artifact Registry Repository
                resources += [artifact.RegistryRepository {
                    metadata = h.metadata_with_labels("${_name}-artifactregistry", _k8s_labels)
                    spec = {
                        forProvider = {
                            location = _region
                            format = spec.format.upper()
                            mode = "STANDARD_REPOSITORY"
                            labels = _gcp_labels
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                resources
            }
            
            get_status_gcp = lambda spec: schema.RegistrySpec, ocds: any -> schema.RegistryStatus {
                """Extract status from observed composed resources."""
                _observed_artifact = ocds.get("${spec.name}-artifactregistry", {})
                _observed_status = _observed_artifact.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _name = _observed_status.get("name", "")
                _region = spec.region
            
                schema.RegistryStatus {
                    provider = "gcp"
                    region = _region
                    registryUrl = "${_region}-docker.pkg.dev/${_name}" if _name else ""
                    repositoryName = spec.name
                }
            }
            """
            Kubernetes Harbor resource generation for registry composition.
            """
            
            import schemas.registry as schema
            import schemas.labels as labels
            import schemas.helpers as h
            
            generate_kubernetes = lambda spec: schema.RegistrySpec, ocds: any -> [any] {
                """Generate Harbor resources from RegistrySpec."""
                _name = spec.name
                _namespace = spec.namespace
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "registry"
                    provider = "kubernetes"
                    environment = spec.environment
                }
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # Harbor Cluster (using goharbor-operator)
                resources += [{
                    apiVersion = "goharbor.io/v1beta1"
                    kind = "HarborCluster"
                    metadata = {
                        name = "${_name}-harbor"
                        namespace = _namespace
                        annotations = {
                            "krm.kcl.dev/composition-resource-name" = "${_name}-harbor"
                        }
                        labels = _k8s_labels
                    }
                    spec = {
                        version = "2.11.0"
                        externalURL = "https://${_name}-harbor.${_namespace}.svc.cluster.local"
                        expose = {
                            core = {
                                ingress = {
                                    host = "${_name}-harbor.local"
                                }
                            }
                        }
                        database = {
                            kind = "PostgreSQL"
                            spec = {
                                embedded = {}
                            }
                        }
                        storage = {
                            kind = "FileSystem"
                            spec = {
                                fileSystem = {
                                    rootdirectory = "/storage"
                                }
                            }
                        }
                        cache = {
                            kind = "Redis"
                            spec = {
                                embedded = {}
                            }
                        }
                    }
                }]
            
                resources
            }
            
            get_status_kubernetes = lambda spec: schema.RegistrySpec, ocds: any -> schema.RegistryStatus {
                """Extract status from observed composed resources."""
                _observed_harbor = ocds.get("${spec.name}-harbor", {})
                _observed_status = _observed_harbor.get("Resource", {}).get("status", {}) or {}
            
                _external_url = _observed_status.get("externalURL", "")
            
                schema.RegistryStatus {
                    provider = "kubernetes"
                    region = "in-cluster"
                    registryUrl = _external_url if _external_url else "https://${spec.name}-harbor.${spec.namespace}.svc.cluster.local"
                    repositoryName = spec.name
                }
            }
            """
            AWS VPC resource generation for network composition.
            """
            
            import schemas.network as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            import schemas.mappings as m
            
            generate_aws = lambda spec: schema.NetworkSpec, ocds: any -> [any] {
                """Generate AWS VPC resources from NetworkSpec."""
                _name = spec.name
                _region = regions.get_aws_region(spec.region) if spec.region else ""
                _cidr = spec.cidrBlock
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "network"
                    provider = "aws"
                    environment = spec.environment
                }
                _tags = labels.generate_tags(_label_config, "aws")
                _k8s_labels = labels.generate_labels(_label_config)
            
                # Get subnets (use defaults if not provided)
                _subnets = spec.subnets or m.get_default_subnets("aws")
            
                resources: [any] = []
            
                # AWS VPC
                resources += [{
                    apiVersion = "ec2.aws.upbound.io/v1beta1"
                    kind = "VPC"
                    metadata = h.metadata_with_labels("${_name}-vpc", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            cidrBlock = _cidr
                            enableDnsSupport = spec.enableDnsSupport
                            enableDnsHostnames = spec.enableDnsHostnames
                            tags = _tags | {"Name": "${_name}-vpc", "network": _name}
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Internet Gateway
                resources += [{
                    apiVersion = "ec2.aws.upbound.io/v1beta1"
                    kind = "InternetGateway"
                    metadata = h.metadata_with_labels("${_name}-igw", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            vpcIdRef = {
                                name = "${_name}-vpc"
                            }
                            tags = _tags | {"Name": "${_name}-igw", "network": _name}
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Subnets
                resources += [
                    {
                        apiVersion = "ec2.aws.upbound.io/v1beta1"
                        kind = "Subnet"
                        metadata = h.metadata_with_labels("${_name}-${subnet.name}", _k8s_labels | {
                            "crossplane.io/network" = _name
                            "crossplane.io/visibility" = subnet.type
                        })
                        spec = {
                            forProvider = {
                                region = _region
                                cidrBlock = subnet.cidrBlock
                                vpcIdRef = {
                                    name = "${_name}-vpc"
                                }
                                availabilityZone = "${_region}${subnet.availabilityZone}" if subnet.availabilityZone else None
                                mapPublicIpOnLaunch = subnet.type == "public"
                                tags = _tags | {"Name": "${_name}-${subnet.name}", "Type": subnet.type, "network": _name}
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }
                    for subnet in _subnets
                ]
            
                # Public Route Table
                resources += [{
                    apiVersion = "ec2.aws.upbound.io/v1beta1"
                    kind = "RouteTable"
                    metadata = h.metadata_with_labels("${_name}-public-rt", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            vpcIdRef = {
                                name = "${_name}-vpc"
                            }
                            tags = _tags | {"Name": "${_name}-public-rt", "network": _name}
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Route to Internet Gateway
                resources += [{
                    apiVersion = "ec2.aws.upbound.io/v1beta1"
                    kind = "Route"
                    metadata = h.metadata_with_labels("${_name}-public-route", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            routeTableIdRef = {
                                name = "${_name}-public-rt"
                            }
                            destinationCidrBlock = "0.0.0.0/0"
                            gatewayIdRef = {
                                name = "${_name}-igw"
                            }
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Route Table Associations for public subnets
                resources += [
                    {
                        apiVersion = "ec2.aws.upbound.io/v1beta1"
                        kind = "RouteTableAssociation"
                        metadata = h.metadata_with_labels("${_name}-${subnet.name}-rta", _k8s_labels)
                        spec = {
                            forProvider = {
                                region = _region
                                routeTableIdRef = {
                                    name = "${_name}-public-rt"
                                }
                                subnetIdRef = {
                                    name = "${_name}-${subnet.name}"
                                }
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }
                    for subnet in _subnets if subnet.type == "public"
                ]
            
                resources
            }
            
            get_status_aws = lambda spec: schema.NetworkSpec, ocds: any -> schema.NetworkStatus {
                """Extract status from observed composed resources."""
                _observed_vpc = ocds.get("${spec.name}-vpc", {})
                _observed_status = _observed_vpc.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _vpc_id = _observed_status.get("id", "")
            
                schema.NetworkStatus {
                    provider = "aws"
                    region = spec.region
                    networkId = _vpc_id
                    cidrBlock = spec.cidrBlock
                }
            }
            """
            GCP Network resource generation for network composition.
            """
            
            import schemas.network as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            import schemas.mappings as m
            
            generate_gcp = lambda spec: schema.NetworkSpec, ocds: any -> [any] {
                """Generate GCP Network resources from NetworkSpec."""
                _name = spec.name
                _region = regions.get_gcp_region(spec.region) if spec.region else ""
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "network"
                    provider = "gcp"
                    environment = spec.environment
                }
                _k8s_labels = labels.generate_labels(_label_config)
            
                # Get subnets (use defaults if not provided)
                _subnets = spec.subnets or m.get_default_subnets("gcp")
            
                resources: [any] = []
            
                # GCP Network (VPC)
                resources += [{
                    apiVersion = "compute.gcp.upbound.io/v1beta1"
                    kind = "Network"
                    metadata = h.metadata_with_labels("${_name}-network", _k8s_labels)
                    spec = {
                        forProvider = {
                            autoCreateSubnetworks = False
                            routingMode = "REGIONAL"
                            description = "Managed by Crossplane - ${_name}"
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Subnetworks
                resources += [
                    {
                        apiVersion = "compute.gcp.upbound.io/v1beta1"
                        kind = "Subnetwork"
                        metadata = h.metadata_with_labels("${_name}-${subnet.name}", _k8s_labels | {
                            "crossplane.io/network" = _name
                            "crossplane.io/visibility" = subnet.type
                        })
                        spec = {
                            forProvider = {
                                region = _region
                                ipCidrRange = subnet.cidrBlock
                                networkRef = {
                                    name = "${_name}-network"
                                }
                                privateIpGoogleAccess = subnet.type == "private"
                                description = "${subnet.type} subnet - ${subnet.name}"
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }
                    for subnet in _subnets
                ]
            
                # Cloud Router for NAT (if there are private subnets)
                _has_private_subnets = any(subnet.type == "private" for subnet in _subnets)
                if _has_private_subnets:
                    resources += [{
                        apiVersion = "compute.gcp.upbound.io/v1beta1"
                        kind = "Router"
                        metadata = h.metadata_with_labels("${_name}-router", _k8s_labels)
                        spec = {
                            forProvider = {
                                region = _region
                                networkRef = {
                                    name = "${_name}-network"
                                }
                                description = "NAT router for ${_name}"
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }]
            
                    # Cloud NAT for private subnet internet access
                    resources += [{
                        apiVersion = "compute.gcp.upbound.io/v1beta1"
                        kind = "RouterNAT"
                        metadata = h.metadata_with_labels("${_name}-nat", _k8s_labels)
                        spec = {
                            forProvider = {
                                region = _region
                                routerRef = {
                                    name = "${_name}-router"
                                }
                                natIpAllocateOption = "AUTO_ONLY"
                                sourceSubnetworkIpRangesToNat = "ALL_SUBNETWORKS_ALL_IP_RANGES"
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }]
            
                resources
            }
            
            get_status_gcp = lambda spec: schema.NetworkSpec, ocds: any -> schema.NetworkStatus {
                """Extract status from observed composed resources."""
                _observed_network = ocds.get("${spec.name}-network", {})
                _observed_status = _observed_network.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _network_id = _observed_status.get("id", "")
            
                schema.NetworkStatus {
                    provider = "gcp"
                    region = spec.region
                    networkId = _network_id
                    cidrBlock = spec.cidrBlock
                }
            }
            """
            AWS S3 resource generation for bucket composition.
            """
            
            import model.io.upbound.aws.s3.v1beta2 as s3
            import model.io.upbound.aws.s3.v1beta1 as s3v1beta1
            import schemas.bucket as schema
            import schemas.labels as labels
            import schemas.helpers as h
            
            generate_aws = lambda spec: schema.BucketSpec, ocds: any -> [any] {
                """Generate AWS S3 resources from BucketSpec."""
                _bucket_name = spec.name
                _region = spec.region
                _storage_class = schema.map_storage_class("aws", spec.storageClass)
                _deletion_policy = spec.deletionPolicy
            
                _label_config = labels.LabelConfig {
                    name = _bucket_name
                    component = "storage"
                    provider = "aws"
                    environment = spec.environment
                }
                _tags = labels.generate_tags(_label_config, "aws") | spec.tags
            
                resources: [any] = []
            
                # Main S3 Bucket
                resources += [s3.Bucket {
                    metadata = h.metadata(_bucket_name)
                    spec = {
                        forProvider = {
                            region = _region
                            tags = _tags
                        }
                        deletionPolicy = _deletion_policy
                    }
                }]
            
                # Bucket versioning
                if spec.versioning:
                    resources += [s3.BucketVersioning {
                        metadata = h.metadata("${_bucket_name}-versioning")
                        spec = {
                            forProvider = {
                                region = _region
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                versioningConfiguration = {
                                    status = "Enabled"
                                }
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                # Server-side encryption
                if spec.encryption:
                    resources += [s3.BucketServerSideEncryptionConfiguration {
                        metadata = h.metadata("${_bucket_name}-encryption")
                        spec = {
                            forProvider = {
                                region = _region
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                $rule = [{
                                    applyServerSideEncryptionByDefault = {
                                        sseAlgorithm = "AES256"
                                    }
                                    bucketKeyEnabled = True
                                }]
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                # Public access block (default: block all public access)
                resources += [s3v1beta1.BucketPublicAccessBlock {
                    metadata = h.metadata("${_bucket_name}-public-access")
                    spec = {
                        forProvider = {
                            region = _region
                            bucketSelector = {
                                matchControllerRef = True
                            }
                            blockPublicAcls = not spec.publicAccess
                            blockPublicPolicy = not spec.publicAccess
                            ignorePublicAcls = not spec.publicAccess
                            restrictPublicBuckets = not spec.publicAccess
                        }
                        deletionPolicy = _deletion_policy
                    }
                }]
            
                # CORS configuration
                if spec.cors:
                    resources += [{
                        apiVersion = "s3.aws.upbound.io/v1beta1"
                        kind = "BucketCorsConfiguration"
                        metadata = h.metadata("${_bucket_name}-cors")
                        spec = {
                            forProvider = {
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                region = _region
                                corsRule = [
                                    {
                                        allowedOrigins = rule.allowedOrigins
                                        allowedMethods = rule.allowedMethods
                                        allowedHeaders = rule.allowedHeaders
                                        maxAgeSeconds = rule.maxAgeSeconds
                                    }
                                    for rule in spec.cors
                                ]
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                # Lifecycle rules
                if spec.lifecycle:
                    resources += [{
                        apiVersion = "s3.aws.upbound.io/v1beta1"
                        kind = "BucketLifecycleConfiguration"
                        metadata = h.metadata("${_bucket_name}-lifecycle")
                        spec = {
                            forProvider = {
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                region = _region
                                $rule = [
                                    _build_lifecycle_rule(rule)
                                    for rule in spec.lifecycle
                                ]
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                resources
            }
            
            _build_lifecycle_rule = lambda rule: schema.LifecycleRule -> any {
                """Build an AWS S3 lifecycle rule."""
                base: {str:any} = {
                    id = rule.name
                    status = "Enabled" if rule.enabled else "Disabled"
                }
            
                if rule.prefix:
                    base |= {$filter = [{prefix = rule.prefix}]}
            
                if rule.expirationDays > 0:
                    base |= {$expiration = [{days = rule.expirationDays}]}
            
                if rule.transitionDays > 0:
                    base |= {
                        $transition = [{
                            days = rule.transitionDays
                            storageClass = schema.map_storage_class("aws", rule.transitionStorageClass)
                        }]
                    }
            
                base
            }
            
            get_status_aws = lambda spec: schema.BucketSpec, ocds: any -> schema.BucketStatus {
                """Extract status from observed composed resources."""
                _observed_bucket = ocds.get(spec.name, {})
                _observed_status = _observed_bucket.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _bucket_id = _observed_status.get("id", spec.name)
                _bucket_domain = _observed_status.get("bucketRegionalDomainName", "")
            
                schema.BucketStatus {
                    provider = "aws"
                    region = spec.region
                    bucketName = _bucket_id
                    url = "s3://${_bucket_id}"
                    id = _bucket_id
                    cloudUrl = "https://${_bucket_domain}" if _bucket_domain else "https://${spec.name}.s3.${spec.region}.amazonaws.com"
                }
            }
            """
            GCP Cloud Storage resource generation for bucket composition.
            """
            
            import model.io.upbound.gcp.storage.v1beta2 as gcs
            import schemas.bucket as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.common as c
            
            generate_gcp = lambda spec: schema.BucketSpec, ocds: any -> [any] {
                """Generate GCP Cloud Storage resources from BucketSpec."""
                _bucket_name = spec.name
                _location = c.map_region("gcp", spec.region).upper()
                _storage_class = schema.map_storage_class("gcp", spec.storageClass)
                _deletion_policy = spec.deletionPolicy
            
                _label_config = labels.LabelConfig {
                    name = _bucket_name
                    component = "storage"
                    provider = "gcp"
                    environment = spec.environment
                }
                _labels = labels.generate_tags(_label_config, "gcp") | {
                    k.lower().replace("-", "_"): v.lower()
                    for k, v in spec.tags
                    if len(k) <= 63 and len(v) <= 63
                }
            
                resources: [any] = []
            
                # Build bucket forProvider config
                _for_provider: {str:any} = {
                    location = _location
                    storageClass = _storage_class
                    labels = _labels
                    uniformBucketLevelAccess = True
                    publicAccessPrevention = "enforced" if not spec.publicAccess else "inherited"
                }
            
                # Add versioning if enabled
                if spec.versioning:
                    _for_provider |= {
                        versioning = [{
                            enabled = True
                        }]
                    }
            
                # Add CORS rules if specified
                if spec.cors:
                    _for_provider |= {
                        cors = [
                            {
                                origin = rule.allowedOrigins
                                method = rule.allowedMethods
                                responseHeader = rule.allowedHeaders
                                maxAgeSeconds = rule.maxAgeSeconds
                            }
                            for rule in spec.cors
                        ]
                    }
            
                # Add lifecycle rules if specified
                if spec.lifecycle:
                    _for_provider |= {
                        lifecycleRule = [
                            _build_lifecycle_rule(rule)
                            for rule in spec.lifecycle
                        ]
                    }
            
                # Main GCS Bucket
                resources += [gcs.Bucket {
                    metadata = h.metadata(_bucket_name)
                    spec = {
                        forProvider = _for_provider
                        deletionPolicy = _deletion_policy
                    }
                }]
            
                # IAM binding for public access if enabled
                if spec.publicAccess:
                    resources += [{
                        apiVersion = "storage.gcp.upbound.io/v1beta1"
                        kind = "BucketIAMMember"
                        metadata = h.metadata("${_bucket_name}-public-read")
                        spec = {
                            forProvider = {
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                role = "roles/storage.objectViewer"
                                member = "allUsers"
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                resources
            }
            
            _build_lifecycle_rule = lambda rule: schema.LifecycleRule -> any {
                """Build a GCP lifecycle rule."""
                result: {str:any} = {
                    action = {}
                    condition = {}
                }
            
                if rule.expirationDays > 0:
                    result.action |= {$type = "Delete"}
                    result.condition |= {age = rule.expirationDays}
                elif rule.transitionDays > 0:
                    result.action |= {
                        $type = "SetStorageClass"
                        storageClass = schema.map_storage_class("gcp", rule.transitionStorageClass)
                    }
                    result.condition |= {age = rule.transitionDays}
            
                if rule.prefix:
                    result.condition |= {matchesPrefix = [rule.prefix]}
            
                result
            }
            
            get_status_gcp = lambda spec: schema.BucketSpec, ocds: any -> schema.BucketStatus {
                """Extract status from observed composed resources."""
                _observed_bucket = ocds.get(spec.name, {})
                _observed_status = _observed_bucket.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _bucket_url = _observed_status.get("url", "")
                _bucket_self_link = _observed_status.get("selfLink", "")
            
                schema.BucketStatus {
                    provider = "gcp"
                    region = spec.region
                    bucketName = spec.name
                    url = _bucket_url if _bucket_url else "gs://${spec.name}"
                    id = spec.name
                    cloudUrl = _bucket_self_link if _bucket_self_link else "https://storage.googleapis.com/${spec.name}"
                }
            }
            """
            AWS RDS resource generation for database composition.
            """
            
            import crossplane_provider_upjet_aws.v1beta2.rds_aws_upbound_io_v1beta2_instance as rds
            import schemas.database as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            
            generate_aws = lambda spec: schema.DatabaseSpec, ocds: any -> [any] {
                """Generate AWS RDS resources from DatabaseSpec."""
                _db_name = spec.region  # use oxr metadata name
                _region = regions.get_aws_region(spec.region) if spec.region else ""
                _instance_class = schema.get_instance_class("aws", spec.size)
                _engine_version = schema.get_engine_version(spec.engine, "aws", spec.engineVersion)
                _storage_type = schema.get_storage_type("aws", spec.storageType)
            
                _label_config = labels.LabelConfig {
                    name = _db_name
                    component = "database"
                    provider = "aws"
                    environment = spec.environment
                }
                _tags = labels.generate_tags(_label_config, "aws") | spec.tags
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # Main RDS Instance using typed schema
                _rds_spec: {str:any} = {
                    forProvider = {
                        region = _region
                        engine = spec.engine
                        engineVersion = _engine_version
                        instanceClass = _instance_class
                        allocatedStorage = spec.storageGB
                        storageType = _storage_type
                        storageEncrypted = True
                        multiAz = spec.multiAZ
                        publiclyAccessible = spec.publiclyAccessible
                        skipFinalSnapshot = spec.environment != "prod"
                        copyTagsToSnapshot = True
                        tags = _tags
                    }
                    deletionPolicy = spec.deletionPolicy
                }
            
                # Add final snapshot identifier for prod
                if spec.environment == "prod":
                    _rds_spec.forProvider |= {
                        finalSnapshotIdentifier = "${_db_name}-final"
                    }
            
                # Add backup configuration
                if spec.backup.enabled:
                    _rds_spec.forProvider |= {
                        backupRetentionPeriod = spec.backup.retentionDays
                        backupWindow = spec.backup.preferredWindow
                    }
            
                # Add password configuration
                if spec.secrets.generatePassword:
                    _rds_spec.forProvider |= {
                        username = "admin"
                        autoGeneratePassword = True
                    }
                    _rds_spec |= {
                        writeConnectionSecretToRef = {
                            name = "${_db_name}-credentials"
                            namespace = "crossplane-system"
                        }
                    }
                elif spec.secrets.passwordSecretRef:
                    _rds_spec.forProvider |= {
                        username = "admin"
                        passwordSecretRef = {
                            name = spec.secrets.passwordSecretRef
                            namespace = "crossplane-system"
                            key = "password"
                        }
                    }
            
                resources += [rds.Instance {
                    metadata = h.metadata_with_labels("${_db_name}-rds", _k8s_labels)
                    spec = _rds_spec
                }]
            
                resources
            }
            
            get_status_aws = lambda spec: schema.DatabaseSpec, ocds: any -> schema.DatabaseStatus {
                """Extract status from observed composed resources."""
                _db_name = spec.region
                _observed_db = ocds.get("${_db_name}-rds", {})
                _observed_status = _observed_db.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _endpoint = _observed_status.get("endpoint", "")
            
                schema.DatabaseStatus {
                    provider = "aws"
                    region = spec.region
                    engine = spec.engine
                    endpoint = _endpoint
                }
            }
            """
            GCP Cloud SQL resource generation for database composition.
            """
            
            import schemas.database as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.common as c
            
            generate_gcp = lambda spec: schema.DatabaseSpec, ocds: any, name: str -> [any] {
                """Generate GCP Cloud SQL resources from DatabaseSpec."""
                _db_name = name
                _region = c.map_region("gcp", spec.region) if spec.region else ""
                _tier = schema.get_instance_class("gcp", spec.size)
                _database_version = _get_gcp_database_version(spec.engine, spec.engineVersion)
            
                _label_config = labels.LabelConfig {
                    name = _db_name
                    component = "database"
                    provider = "gcp"
                    environment = spec.environment
                }
                _user_labels = labels.generate_tags(_label_config, "gcp") | {
                    k.lower().replace("-", "_"): v.lower()
                    for k, v in spec.tags
                    if len(k) <= 63 and len(v) <= 63
                }
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # Build settings
                _settings: {str:any} = {
                    tier = _tier
                    diskSize = spec.storageGB
                    diskType = "PD_SSD"
                    diskAutoresize = True
                    diskAutoresizeLimit = spec.storageGB * 2
                    availabilityType = "REGIONAL" if spec.multiAZ else "ZONAL"
                    userLabels = _user_labels
                    ipConfiguration = {
                        ipv4Enabled = spec.publiclyAccessible
                        requireSsl = True
                    }
                }
            
                # Add backup configuration
                if spec.backup.enabled:
                    _settings |= {
                        backupConfiguration = {
                            enabled = True
                            startTime = spec.backup.preferredWindow.split("-")[0]
                            pointInTimeRecoveryEnabled = True
                            transactionLogRetentionDays = spec.backup.retentionDays
                            backupRetentionSettings = {
                                retainedBackups = spec.backup.retentionDays
                                retentionUnit = "COUNT"
                            }
                        }
                    }
            
                # Main Cloud SQL Instance
                _sql_spec: {str:any} = {
                    forProvider = {
                        region = _region
                        databaseVersion = _database_version
                        deletionProtection = spec.environment == "prod"
                        settings = _settings
                    }
                    deletionPolicy = spec.deletionPolicy
                }
            
                # Add write connection secret if auto-generating password
                if spec.secrets.generatePassword:
                    _sql_spec |= {
                        writeConnectionSecretToRef = {
                            name = "${_db_name}-credentials"
                            namespace = "crossplane-system"
                        }
                    }
            
                resources += [{
                    apiVersion = "sql.gcp.upbound.io/v1beta2"
                    kind = "DatabaseInstance"
                    metadata = h.metadata_with_labels("${_db_name}-cloudsql", _k8s_labels)
                    spec = _sql_spec
                }]
            
                # Create database
                resources += [{
                    apiVersion = "sql.gcp.upbound.io/v1beta1"
                    kind = "Database"
                    metadata = h.metadata_with_labels("${_db_name}-db", _k8s_labels)
                    spec = {
                        forProvider = {
                            instanceSelector = {
                                matchControllerRef = True
                            }
                            charset = "UTF8" if spec.engine == "postgres" else "utf8mb4"
                            collation = "en_US.UTF8" if spec.engine == "postgres" else "utf8mb4_general_ci"
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Create user
                _user_spec: {str:any} = {
                    forProvider = {
                        instanceSelector = {
                            matchControllerRef = True
                        }
                        $type = "BUILT_IN"
                    }
                    deletionPolicy = spec.deletionPolicy
                }
            
                if spec.secrets.generatePassword:
                    _user_spec.forProvider |= {
                        passwordSecretRef = {
                            name = "${_db_name}-user-password"
                            namespace = "crossplane-system"
                            key = "password"
                        }
                    }
                elif spec.secrets.passwordSecretRef:
                    _user_spec.forProvider |= {
                        passwordSecretRef = {
                            name = spec.secrets.passwordSecretRef
                            namespace = "crossplane-system"
                            key = "password"
                        }
                    }
            
                resources += [{
                    apiVersion = "sql.gcp.upbound.io/v1beta1"
                    kind = "User"
                    metadata = h.metadata_with_labels("${_db_name}-user", _k8s_labels)
                    spec = _user_spec
                }]
            
                resources
            }
            
            _get_gcp_database_version = lambda engine: str, version: str -> str {
                """Get the GCP Cloud SQL database version string."""
                if engine == "postgres":
                    "POSTGRES_${version}"
                else:
                    "MYSQL_8_0"
            }
            
            get_status_gcp = lambda spec: schema.DatabaseSpec, ocds: any, name: str -> schema.DatabaseStatus {
                """Extract status from observed composed resources."""
                _db_name = name
                _observed_db = ocds.get("${_db_name}-cloudsql", {})
                _observed_status = _observed_db.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _connection_name = _observed_status.get("connectionName", "")
            
                schema.DatabaseStatus {
                    provider = "gcp"
                    region = spec.region
                    engine = spec.engine
                    endpoint = _connection_name
                }
            }
            """
            Kubernetes CloudNative-PG resource generation for database composition.
            """
            
            import schemas.database as schema
            import schemas.labels as labels
            import schemas.helpers as h
            
            generate_kubernetes = lambda spec: schema.DatabaseSpec, ocds: any, name: str -> [any] {
                """Generate CloudNative-PG Cluster from DatabaseSpec."""
                _db_name = name
                _namespace = spec.namespace
                _resources = schema.get_instance_class("kubernetes", spec.size)
            
                _label_config = labels.LabelConfig {
                    name = _db_name
                    component = "database"
                    provider = "kubernetes"
                    environment = spec.environment
                }
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # CloudNative-PG Cluster
                _cnpg_spec: {str:any} = {
                    instances = spec.instances
                    imageName = "ghcr.io/cloudnative-pg/postgresql:${spec.engineVersion}"
                    postgresql = {
                        parameters = {
                            max_connections = "100"
                            shared_buffers = "128MB"
                        }
                    }
                    bootstrap = {
                        initdb = {
                            database = "app"
                            owner = "app"
                        }
                    }
                    storage = {
                        size = "${spec.storageGB}Gi"
                    }
                    resources = {
                        requests = _resources
                        limits = _resources
                    }
                    monitoring = {
                        enablePodMonitor = spec.environment != "dev"
                    }
                }
            
                # Add backup configuration if enabled
                if spec.backup.enabled:
                    _cnpg_spec |= {
                        backup = {
                            barmanObjectStore = {
                                destinationPath = "s3://${_db_name}-backups/"
                                s3Credentials = {
                                    accessKeyId = {
                                        name = "${_db_name}-backup-creds"
                                        key = "ACCESS_KEY_ID"
                                    }
                                    secretAccessKey = {
                                        name = "${_db_name}-backup-creds"
                                        key = "SECRET_ACCESS_KEY"
                                    }
                                }
                            }
                            retentionPolicy = "${spec.backup.retentionDays}d"
                        }
                    }
            
                resources += [{
                    apiVersion = "postgresql.cnpg.io/v1"
                    kind = "Cluster"
                    metadata = {
                        name = "${_db_name}-cnpg"
                        namespace = _namespace
                        annotations = {
                            "krm.kcl.dev/composition-resource-name" = "${_db_name}-cnpg"
                        }
                        labels = _k8s_labels
                    }
                    spec = _cnpg_spec
                }]
            
                resources
            }
            
            get_status_kubernetes = lambda spec: schema.DatabaseSpec, ocds: any, name: str -> schema.DatabaseStatus {
                """Extract status from observed composed resources."""
                _db_name = name
                _observed_db = ocds.get("${_db_name}-cnpg", {})
                _observed_status = _observed_db.get("Resource", {}).get("status", {}) or {}
            
                _instances_ready = _observed_status.get("instancesReady", 0)
            
                schema.DatabaseStatus {
                    provider = "kubernetes"
                    region = "in-cluster"
                    engine = spec.engine
                    endpoint = "${_db_name}-cnpg-rw.${spec.namespace}.svc.cluster.local:5432" if _instances_ready > 0 else ""
                }
            }
            """
            AWS ECR resource generation for registry composition.
            """
            
            import crossplane_provider_upjet_aws.v1beta2.ecr_aws_upbound_io_v1beta2_repository as ecr
            import crossplane_provider_upjet_aws.v1beta1.ecr_aws_upbound_io_v1beta1_lifecycle_policy as ecr_lifecycle
            import schemas.registry as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            
            generate_aws = lambda spec: schema.RegistrySpec, ocds: any -> [any] {
                """Generate AWS ECR resources from RegistrySpec."""
                _name = spec.name
                _region = regions.get_aws_region(spec.region) if spec.region else ""
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "registry"
                    provider = "aws"
                    environment = spec.environment
                }
                _tags = labels.generate_tags(_label_config, "aws")
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # AWS ECR Repository
                resources += [ecr.Repository {
                    metadata = h.metadata_with_labels("${_name}-ecr", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            imageTagMutability = "IMMUTABLE" if spec.immutableTags else "MUTABLE"
                            imageScanningConfiguration = {
                                scanOnPush = spec.scanOnPush
                            }
                            encryptionConfiguration = [{
                                encryptionType = "AES256"
                            }] if spec.encryption else []
                            tags = _tags
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # AWS ECR Lifecycle Policy for retention
                if spec.retentionDays > 0:
                    resources += [ecr_lifecycle.LifecyclePolicy {
                        metadata = h.metadata_with_labels("${_name}-ecr-lifecycle", _k8s_labels)
                        spec = {
                            forProvider = {
                                region = _region
                                repositorySelector = {
                                    matchControllerRef = True
                                }
                                policy = '''{
                                    "rules": [
                                        {
                                            "rulePriority": 1,
                                            "description": "Expire untagged images older than ''' + str(spec.retentionDays) + ''' days",
                                            "selection": {
                                                "tagStatus": "untagged",
                                                "countType": "sinceImagePushed",
                                                "countUnit": "days",
                                                "countNumber": ''' + str(spec.retentionDays) + '''
                                            },
                                            "action": {
                                                "type": "expire"
                                            }
                                        }
                                    ]
                                }'''
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }]
            
                resources
            }
            
            get_status_aws = lambda spec: schema.RegistrySpec, ocds: any -> schema.RegistryStatus {
                """Extract status from observed composed resources."""
                _observed_ecr = ocds.get("${spec.name}-ecr", {})
                _observed_status = _observed_ecr.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _registry_url = _observed_status.get("repositoryUrl", "")
            
                schema.RegistryStatus {
                    provider = "aws"
                    region = spec.region
                    registryUrl = _registry_url
                    repositoryName = spec.name
                }
            }
            """
            GCP Artifact Registry resource generation for registry composition.
            """
            
            import crossplane_provider_upjet_gcp.v1beta1.artifact_gcp_upbound_io_v1beta1_registry_repository as artifact
            import schemas.registry as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            
            generate_gcp = lambda spec: schema.RegistrySpec, ocds: any -> [any] {
                """Generate GCP Artifact Registry resources from RegistrySpec."""
                _name = spec.name
                _region = regions.get_gcp_region(spec.region) if spec.region else ""
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "registry"
                    provider = "gcp"
                    environment = spec.environment
                }
                _gcp_labels = labels.generate_tags(_label_config, "gcp")
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # GCP Artifact Registry Repository
                resources += [artifact.RegistryRepository {
                    metadata = h.metadata_with_labels("${_name}-artifactregistry", _k8s_labels)
                    spec = {
                        forProvider = {
                            location = _region
                            format = spec.format.upper()
                            mode = "STANDARD_REPOSITORY"
                            labels = _gcp_labels
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                resources
            }
            
            get_status_gcp = lambda spec: schema.RegistrySpec, ocds: any -> schema.RegistryStatus {
                """Extract status from observed composed resources."""
                _observed_artifact = ocds.get("${spec.name}-artifactregistry", {})
                _observed_status = _observed_artifact.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _name = _observed_status.get("name", "")
                _region = spec.region
            
                schema.RegistryStatus {
                    provider = "gcp"
                    region = _region
                    registryUrl = "${_region}-docker.pkg.dev/${_name}" if _name else ""
                    repositoryName = spec.name
                }
            }
            """
            Kubernetes Harbor resource generation for registry composition.
            """
            
            import schemas.registry as schema
            import schemas.labels as labels
            import schemas.helpers as h
            
            generate_kubernetes = lambda spec: schema.RegistrySpec, ocds: any -> [any] {
                """Generate Harbor resources from RegistrySpec."""
                _name = spec.name
                _namespace = spec.namespace
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "registry"
                    provider = "kubernetes"
                    environment = spec.environment
                }
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # Harbor Cluster (using goharbor-operator)
                resources += [{
                    apiVersion = "goharbor.io/v1beta1"
                    kind = "HarborCluster"
                    metadata = {
                        name = "${_name}-harbor"
                        namespace = _namespace
                        annotations = {
                            "krm.kcl.dev/composition-resource-name" = "${_name}-harbor"
                        }
                        labels = _k8s_labels
                    }
                    spec = {
                        version = "2.11.0"
                        externalURL = "https://${_name}-harbor.${_namespace}.svc.cluster.local"
                        expose = {
                            core = {
                                ingress = {
                                    host = "${_name}-harbor.local"
                                }
                            }
                        }
                        database = {
                            kind = "PostgreSQL"
                            spec = {
                                embedded = {}
                            }
                        }
                        storage = {
                            kind = "FileSystem"
                            spec = {
                                fileSystem = {
                                    rootdirectory = "/storage"
                                }
                            }
                        }
                        cache = {
                            kind = "Redis"
                            spec = {
                                embedded = {}
                            }
                        }
                    }
                }]
            
                resources
            }
            
            get_status_kubernetes = lambda spec: schema.RegistrySpec, ocds: any -> schema.RegistryStatus {
                """Extract status from observed composed resources."""
                _observed_harbor = ocds.get("${spec.name}-harbor", {})
                _observed_status = _observed_harbor.get("Resource", {}).get("status", {}) or {}
            
                _external_url = _observed_status.get("externalURL", "")
            
                schema.RegistryStatus {
                    provider = "kubernetes"
                    region = "in-cluster"
                    registryUrl = _external_url if _external_url else "https://${spec.name}-harbor.${spec.namespace}.svc.cluster.local"
                    repositoryName = spec.name
                }
            }
            """
            AWS VPC resource generation for network composition.
            """
            
            import schemas.network as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            import schemas.mappings as m
            
            generate_aws = lambda spec: schema.NetworkSpec, ocds: any -> [any] {
                """Generate AWS VPC resources from NetworkSpec."""
                _name = spec.name
                _region = regions.get_aws_region(spec.region) if spec.region else ""
                _cidr = spec.cidrBlock
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "network"
                    provider = "aws"
                    environment = spec.environment
                }
                _tags = labels.generate_tags(_label_config, "aws")
                _k8s_labels = labels.generate_labels(_label_config)
            
                # Get subnets (use defaults if not provided)
                _subnets = spec.subnets or m.get_default_subnets("aws")
            
                resources: [any] = []
            
                # AWS VPC
                resources += [{
                    apiVersion = "ec2.aws.upbound.io/v1beta1"
                    kind = "VPC"
                    metadata = h.metadata_with_labels("${_name}-vpc", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            cidrBlock = _cidr
                            enableDnsSupport = spec.enableDnsSupport
                            enableDnsHostnames = spec.enableDnsHostnames
                            tags = _tags | {"Name": "${_name}-vpc", "network": _name}
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Internet Gateway
                resources += [{
                    apiVersion = "ec2.aws.upbound.io/v1beta1"
                    kind = "InternetGateway"
                    metadata = h.metadata_with_labels("${_name}-igw", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            vpcIdRef = {
                                name = "${_name}-vpc"
                            }
                            tags = _tags | {"Name": "${_name}-igw", "network": _name}
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Subnets
                resources += [
                    {
                        apiVersion = "ec2.aws.upbound.io/v1beta1"
                        kind = "Subnet"
                        metadata = h.metadata_with_labels("${_name}-${subnet.name}", _k8s_labels | {
                            "crossplane.io/network" = _name
                            "crossplane.io/visibility" = subnet.type
                        })
                        spec = {
                            forProvider = {
                                region = _region
                                cidrBlock = subnet.cidrBlock
                                vpcIdRef = {
                                    name = "${_name}-vpc"
                                }
                                availabilityZone = "${_region}${subnet.availabilityZone}" if subnet.availabilityZone else None
                                mapPublicIpOnLaunch = subnet.type == "public"
                                tags = _tags | {"Name": "${_name}-${subnet.name}", "Type": subnet.type, "network": _name}
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }
                    for subnet in _subnets
                ]
            
                # Public Route Table
                resources += [{
                    apiVersion = "ec2.aws.upbound.io/v1beta1"
                    kind = "RouteTable"
                    metadata = h.metadata_with_labels("${_name}-public-rt", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            vpcIdRef = {
                                name = "${_name}-vpc"
                            }
                            tags = _tags | {"Name": "${_name}-public-rt", "network": _name}
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Route to Internet Gateway
                resources += [{
                    apiVersion = "ec2.aws.upbound.io/v1beta1"
                    kind = "Route"
                    metadata = h.metadata_with_labels("${_name}-public-route", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            routeTableIdRef = {
                                name = "${_name}-public-rt"
                            }
                            destinationCidrBlock = "0.0.0.0/0"
                            gatewayIdRef = {
                                name = "${_name}-igw"
                            }
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Route Table Associations for public subnets
                resources += [
                    {
                        apiVersion = "ec2.aws.upbound.io/v1beta1"
                        kind = "RouteTableAssociation"
                        metadata = h.metadata_with_labels("${_name}-${subnet.name}-rta", _k8s_labels)
                        spec = {
                            forProvider = {
                                region = _region
                                routeTableIdRef = {
                                    name = "${_name}-public-rt"
                                }
                                subnetIdRef = {
                                    name = "${_name}-${subnet.name}"
                                }
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }
                    for subnet in _subnets if subnet.type == "public"
                ]
            
                resources
            }
            
            get_status_aws = lambda spec: schema.NetworkSpec, ocds: any -> schema.NetworkStatus {
                """Extract status from observed composed resources."""
                _observed_vpc = ocds.get("${spec.name}-vpc", {})
                _observed_status = _observed_vpc.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _vpc_id = _observed_status.get("id", "")
            
                schema.NetworkStatus {
                    provider = "aws"
                    region = spec.region
                    networkId = _vpc_id
                    cidrBlock = spec.cidrBlock
                }
            }
            
            # --- Provider: gcp ---
            """
            AWS S3 resource generation for bucket composition.
            """
            
            import model.io.upbound.aws.s3.v1beta2 as s3
            import model.io.upbound.aws.s3.v1beta1 as s3v1beta1
            import schemas.bucket as schema
            import schemas.labels as labels
            import schemas.helpers as h
            
            generate_aws = lambda spec: schema.BucketSpec, ocds: any -> [any] {
                """Generate AWS S3 resources from BucketSpec."""
                _bucket_name = spec.name
                _region = spec.region
                _storage_class = schema.map_storage_class("aws", spec.storageClass)
                _deletion_policy = spec.deletionPolicy
            
                _label_config = labels.LabelConfig {
                    name = _bucket_name
                    component = "storage"
                    provider = "aws"
                    environment = spec.environment
                }
                _tags = labels.generate_tags(_label_config, "aws") | spec.tags
            
                resources: [any] = []
            
                # Main S3 Bucket
                resources += [s3.Bucket {
                    metadata = h.metadata(_bucket_name)
                    spec = {
                        forProvider = {
                            region = _region
                            tags = _tags
                        }
                        deletionPolicy = _deletion_policy
                    }
                }]
            
                # Bucket versioning
                if spec.versioning:
                    resources += [s3.BucketVersioning {
                        metadata = h.metadata("${_bucket_name}-versioning")
                        spec = {
                            forProvider = {
                                region = _region
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                versioningConfiguration = {
                                    status = "Enabled"
                                }
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                # Server-side encryption
                if spec.encryption:
                    resources += [s3.BucketServerSideEncryptionConfiguration {
                        metadata = h.metadata("${_bucket_name}-encryption")
                        spec = {
                            forProvider = {
                                region = _region
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                $rule = [{
                                    applyServerSideEncryptionByDefault = {
                                        sseAlgorithm = "AES256"
                                    }
                                    bucketKeyEnabled = True
                                }]
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                # Public access block (default: block all public access)
                resources += [s3v1beta1.BucketPublicAccessBlock {
                    metadata = h.metadata("${_bucket_name}-public-access")
                    spec = {
                        forProvider = {
                            region = _region
                            bucketSelector = {
                                matchControllerRef = True
                            }
                            blockPublicAcls = not spec.publicAccess
                            blockPublicPolicy = not spec.publicAccess
                            ignorePublicAcls = not spec.publicAccess
                            restrictPublicBuckets = not spec.publicAccess
                        }
                        deletionPolicy = _deletion_policy
                    }
                }]
            
                # CORS configuration
                if spec.cors:
                    resources += [{
                        apiVersion = "s3.aws.upbound.io/v1beta1"
                        kind = "BucketCorsConfiguration"
                        metadata = h.metadata("${_bucket_name}-cors")
                        spec = {
                            forProvider = {
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                region = _region
                                corsRule = [
                                    {
                                        allowedOrigins = rule.allowedOrigins
                                        allowedMethods = rule.allowedMethods
                                        allowedHeaders = rule.allowedHeaders
                                        maxAgeSeconds = rule.maxAgeSeconds
                                    }
                                    for rule in spec.cors
                                ]
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                # Lifecycle rules
                if spec.lifecycle:
                    resources += [{
                        apiVersion = "s3.aws.upbound.io/v1beta1"
                        kind = "BucketLifecycleConfiguration"
                        metadata = h.metadata("${_bucket_name}-lifecycle")
                        spec = {
                            forProvider = {
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                region = _region
                                $rule = [
                                    _build_lifecycle_rule(rule)
                                    for rule in spec.lifecycle
                                ]
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                resources
            }
            
            _build_lifecycle_rule = lambda rule: schema.LifecycleRule -> any {
                """Build an AWS S3 lifecycle rule."""
                base: {str:any} = {
                    id = rule.name
                    status = "Enabled" if rule.enabled else "Disabled"
                }
            
                if rule.prefix:
                    base |= {filter = [{prefix = rule.prefix}]}
            
                if rule.expirationDays > 0:
                    base |= {expiration = [{days = rule.expirationDays}]}
            
                if rule.transitionDays > 0:
                    base |= {
                        transition = [{
                            days = rule.transitionDays
                            storageClass = schema.map_storage_class("aws", rule.transitionStorageClass)
                        }]
                    }
            
                base
            }
            
            get_status_aws = lambda spec: schema.BucketSpec, ocds: any -> schema.BucketStatus {
                """Extract status from observed composed resources."""
                _observed_bucket = ocds.get(spec.name, {})
                _observed_status = _observed_bucket.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _bucket_id = _observed_status.get("id", spec.name)
                _bucket_domain = _observed_status.get("bucketRegionalDomainName", "")
            
                schema.BucketStatus {
                    provider = "aws"
                    region = spec.region
                    bucketName = _bucket_id
                    url = "s3://${_bucket_id}"
                    id = _bucket_id
                    cloudUrl = "https://${_bucket_domain}" if _bucket_domain else "https://${spec.name}.s3.${spec.region}.amazonaws.com"
                }
            }
            """
            GCP Cloud Storage resource generation for bucket composition.
            """
            
            import model.io.upbound.gcp.storage.v1beta2 as gcs
            import schemas.bucket as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.common as c
            
            generate_gcp = lambda spec: schema.BucketSpec, ocds: any -> [any] {
                """Generate GCP Cloud Storage resources from BucketSpec."""
                _bucket_name = spec.name
                _location = c.map_region("gcp", spec.region).upper()
                _storage_class = schema.map_storage_class("gcp", spec.storageClass)
                _deletion_policy = spec.deletionPolicy
            
                _label_config = labels.LabelConfig {
                    name = _bucket_name
                    component = "storage"
                    provider = "gcp"
                    environment = spec.environment
                }
                _labels = labels.generate_tags(_label_config, "gcp") | {
                    k.lower().replace("-", "_"): v.lower()
                    for k, v in spec.tags
                    if len(k) <= 63 and len(v) <= 63
                }
            
                resources: [any] = []
            
                # Build bucket forProvider config
                _for_provider: {str:any} = {
                    location = _location
                    storageClass = _storage_class
                    labels = _labels
                    uniformBucketLevelAccess = True
                    publicAccessPrevention = "enforced" if not spec.publicAccess else "inherited"
                }
            
                # Add versioning if enabled
                if spec.versioning:
                    _for_provider |= {
                        versioning = [{
                            enabled = True
                        }]
                    }
            
                # Add CORS rules if specified
                if spec.cors:
                    _for_provider |= {
                        cors = [
                            {
                                origin = rule.allowedOrigins
                                method = rule.allowedMethods
                                responseHeader = rule.allowedHeaders
                                maxAgeSeconds = rule.maxAgeSeconds
                            }
                            for rule in spec.cors
                        ]
                    }
            
                # Add lifecycle rules if specified
                if spec.lifecycle:
                    _for_provider |= {
                        lifecycleRule = [
                            _build_lifecycle_rule(rule)
                            for rule in spec.lifecycle
                        ]
                    }
            
                # Main GCS Bucket
                resources += [gcs.Bucket {
                    metadata = h.metadata(_bucket_name)
                    spec = {
                        forProvider = _for_provider
                        deletionPolicy = _deletion_policy
                    }
                }]
            
                # IAM binding for public access if enabled
                if spec.publicAccess:
                    resources += [{
                        apiVersion = "storage.gcp.upbound.io/v1beta1"
                        kind = "BucketIAMMember"
                        metadata = h.metadata("${_bucket_name}-public-read")
                        spec = {
                            forProvider = {
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                role = "roles/storage.objectViewer"
                                member = "allUsers"
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                resources
            }
            
            _build_lifecycle_rule = lambda rule: schema.LifecycleRule -> any {
                """Build a GCP lifecycle rule."""
                result: {str:any} = {
                    action = {}
                    condition = {}
                }
            
                if rule.expirationDays > 0:
                    result.action |= {$type = "Delete"}
                    result.condition |= {age = rule.expirationDays}
                elif rule.transitionDays > 0:
                    result.action |= {
                        $type = "SetStorageClass"
                        storageClass = schema.map_storage_class("gcp", rule.transitionStorageClass)
                    }
                    result.condition |= {age = rule.transitionDays}
            
                if rule.prefix:
                    result.condition |= {matchesPrefix = [rule.prefix]}
            
                result
            }
            
            get_status_gcp = lambda spec: schema.BucketSpec, ocds: any -> schema.BucketStatus {
                """Extract status from observed composed resources."""
                _observed_bucket = ocds.get(spec.name, {})
                _observed_status = _observed_bucket.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _bucket_url = _observed_status.get("url", "")
                _bucket_self_link = _observed_status.get("selfLink", "")
            
                schema.BucketStatus {
                    provider = "gcp"
                    region = spec.region
                    bucketName = spec.name
                    url = _bucket_url if _bucket_url else "gs://${spec.name}"
                    id = spec.name
                    cloudUrl = _bucket_self_link if _bucket_self_link else "https://storage.googleapis.com/${spec.name}"
                }
            }
            """
            AWS RDS resource generation for database composition.
            """
            
            import crossplane_provider_upjet_aws.v1beta2.rds_aws_upbound_io_v1beta2_instance as rds
            import schemas.database as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            
            generate_aws = lambda spec: schema.DatabaseSpec, ocds: any -> [any] {
                """Generate AWS RDS resources from DatabaseSpec."""
                _db_name = spec.region  # use oxr metadata name
                _region = regions.get_aws_region(spec.region) if spec.region else ""
                _instance_class = schema.get_instance_class("aws", spec.size)
                _engine_version = schema.get_engine_version(spec.engine, "aws", spec.engineVersion)
                _storage_type = schema.get_storage_type("aws", spec.storageType)
            
                _label_config = labels.LabelConfig {
                    name = _db_name
                    component = "database"
                    provider = "aws"
                    environment = spec.environment
                }
                _tags = labels.generate_tags(_label_config, "aws") | spec.tags
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # Main RDS Instance using typed schema
                _rds_spec: {str:any} = {
                    forProvider = {
                        region = _region
                        engine = spec.engine
                        engineVersion = _engine_version
                        instanceClass = _instance_class
                        allocatedStorage = spec.storageGB
                        storageType = _storage_type
                        storageEncrypted = True
                        multiAz = spec.multiAZ
                        publiclyAccessible = spec.publiclyAccessible
                        skipFinalSnapshot = spec.environment != "prod"
                        copyTagsToSnapshot = True
                        tags = _tags
                    }
                    deletionPolicy = spec.deletionPolicy
                }
            
                # Add final snapshot identifier for prod
                if spec.environment == "prod":
                    _rds_spec.forProvider |= {
                        finalSnapshotIdentifier = "${_db_name}-final"
                    }
            
                # Add backup configuration
                if spec.backup.enabled:
                    _rds_spec.forProvider |= {
                        backupRetentionPeriod = spec.backup.retentionDays
                        backupWindow = spec.backup.preferredWindow
                    }
            
                # Add password configuration
                if spec.secrets.generatePassword:
                    _rds_spec.forProvider |= {
                        username = "admin"
                        autoGeneratePassword = True
                    }
                    _rds_spec |= {
                        writeConnectionSecretToRef = {
                            name = "${_db_name}-credentials"
                            namespace = "crossplane-system"
                        }
                    }
                elif spec.secrets.passwordSecretRef:
                    _rds_spec.forProvider |= {
                        username = "admin"
                        passwordSecretRef = {
                            name = spec.secrets.passwordSecretRef
                            namespace = "crossplane-system"
                            key = "password"
                        }
                    }
            
                resources += [rds.Instance {
                    metadata = h.metadata_with_labels("${_db_name}-rds", _k8s_labels)
                    spec = _rds_spec
                }]
            
                resources
            }
            
            get_status_aws = lambda spec: schema.DatabaseSpec, ocds: any -> schema.DatabaseStatus {
                """Extract status from observed composed resources."""
                _db_name = spec.region
                _observed_db = ocds.get("${_db_name}-rds", {})
                _observed_status = _observed_db.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _endpoint = _observed_status.get("endpoint", "")
            
                schema.DatabaseStatus {
                    provider = "aws"
                    region = spec.region
                    engine = spec.engine
                    endpoint = _endpoint
                }
            }
            """
            GCP Cloud SQL resource generation for database composition.
            """
            
            import schemas.database as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.common as c
            
            generate_gcp = lambda spec: schema.DatabaseSpec, ocds: any, name: str -> [any] {
                """Generate GCP Cloud SQL resources from DatabaseSpec."""
                _db_name = name
                _region = c.map_region("gcp", spec.region) if spec.region else ""
                _tier = schema.get_instance_class("gcp", spec.size)
                _database_version = _get_gcp_database_version(spec.engine, spec.engineVersion)
            
                _label_config = labels.LabelConfig {
                    name = _db_name
                    component = "database"
                    provider = "gcp"
                    environment = spec.environment
                }
                _user_labels = labels.generate_tags(_label_config, "gcp") | {
                    k.lower().replace("-", "_"): v.lower()
                    for k, v in spec.tags
                    if len(k) <= 63 and len(v) <= 63
                }
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # Build settings
                _settings: {str:any} = {
                    tier = _tier
                    diskSize = spec.storageGB
                    diskType = "PD_SSD"
                    diskAutoresize = True
                    diskAutoresizeLimit = spec.storageGB * 2
                    availabilityType = "REGIONAL" if spec.multiAZ else "ZONAL"
                    userLabels = _user_labels
                    ipConfiguration = {
                        ipv4Enabled = spec.publiclyAccessible
                        requireSsl = True
                    }
                }
            
                # Add backup configuration
                if spec.backup.enabled:
                    _settings |= {
                        backupConfiguration = {
                            enabled = True
                            startTime = spec.backup.preferredWindow.split("-")[0]
                            pointInTimeRecoveryEnabled = True
                            transactionLogRetentionDays = spec.backup.retentionDays
                            backupRetentionSettings = {
                                retainedBackups = spec.backup.retentionDays
                                retentionUnit = "COUNT"
                            }
                        }
                    }
            
                # Main Cloud SQL Instance
                _sql_spec: {str:any} = {
                    forProvider = {
                        region = _region
                        databaseVersion = _database_version
                        deletionProtection = spec.environment == "prod"
                        settings = _settings
                    }
                    deletionPolicy = spec.deletionPolicy
                }
            
                # Add write connection secret if auto-generating password
                if spec.secrets.generatePassword:
                    _sql_spec |= {
                        writeConnectionSecretToRef = {
                            name = "${_db_name}-credentials"
                            namespace = "crossplane-system"
                        }
                    }
            
                resources += [{
                    apiVersion = "sql.gcp.upbound.io/v1beta2"
                    kind = "DatabaseInstance"
                    metadata = h.metadata_with_labels("${_db_name}-cloudsql", _k8s_labels)
                    spec = _sql_spec
                }]
            
                # Create database
                resources += [{
                    apiVersion = "sql.gcp.upbound.io/v1beta1"
                    kind = "Database"
                    metadata = h.metadata_with_labels("${_db_name}-db", _k8s_labels)
                    spec = {
                        forProvider = {
                            instanceSelector = {
                                matchControllerRef = True
                            }
                            charset = "UTF8" if spec.engine == "postgres" else "utf8mb4"
                            collation = "en_US.UTF8" if spec.engine == "postgres" else "utf8mb4_general_ci"
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Create user
                _user_spec: {str:any} = {
                    forProvider = {
                        instanceSelector = {
                            matchControllerRef = True
                        }
                        $type = "BUILT_IN"
                    }
                    deletionPolicy = spec.deletionPolicy
                }
            
                if spec.secrets.generatePassword:
                    _user_spec.forProvider |= {
                        passwordSecretRef = {
                            name = "${_db_name}-user-password"
                            namespace = "crossplane-system"
                            key = "password"
                        }
                    }
                elif spec.secrets.passwordSecretRef:
                    _user_spec.forProvider |= {
                        passwordSecretRef = {
                            name = spec.secrets.passwordSecretRef
                            namespace = "crossplane-system"
                            key = "password"
                        }
                    }
            
                resources += [{
                    apiVersion = "sql.gcp.upbound.io/v1beta1"
                    kind = "User"
                    metadata = h.metadata_with_labels("${_db_name}-user", _k8s_labels)
                    spec = _user_spec
                }]
            
                resources
            }
            
            _get_gcp_database_version = lambda engine: str, version: str -> str {
                """Get the GCP Cloud SQL database version string."""
                if engine == "postgres":
                    "POSTGRES_${version}"
                else:
                    "MYSQL_8_0"
            }
            
            get_status_gcp = lambda spec: schema.DatabaseSpec, ocds: any, name: str -> schema.DatabaseStatus {
                """Extract status from observed composed resources."""
                _db_name = name
                _observed_db = ocds.get("${_db_name}-cloudsql", {})
                _observed_status = _observed_db.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _connection_name = _observed_status.get("connectionName", "")
            
                schema.DatabaseStatus {
                    provider = "gcp"
                    region = spec.region
                    engine = spec.engine
                    endpoint = _connection_name
                }
            }
            """
            Kubernetes CloudNative-PG resource generation for database composition.
            """
            
            import schemas.database as schema
            import schemas.labels as labels
            import schemas.helpers as h
            
            generate_kubernetes = lambda spec: schema.DatabaseSpec, ocds: any, name: str -> [any] {
                """Generate CloudNative-PG Cluster from DatabaseSpec."""
                _db_name = name
                _namespace = spec.namespace
                _resources = schema.get_instance_class("kubernetes", spec.size)
            
                _label_config = labels.LabelConfig {
                    name = _db_name
                    component = "database"
                    provider = "kubernetes"
                    environment = spec.environment
                }
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # CloudNative-PG Cluster
                _cnpg_spec: {str:any} = {
                    instances = spec.instances
                    imageName = "ghcr.io/cloudnative-pg/postgresql:${spec.engineVersion}"
                    postgresql = {
                        parameters = {
                            max_connections = "100"
                            shared_buffers = "128MB"
                        }
                    }
                    bootstrap = {
                        initdb = {
                            database = "app"
                            owner = "app"
                        }
                    }
                    storage = {
                        size = "${spec.storageGB}Gi"
                    }
                    resources = {
                        requests = _resources
                        limits = _resources
                    }
                    monitoring = {
                        enablePodMonitor = spec.environment != "dev"
                    }
                }
            
                # Add backup configuration if enabled
                if spec.backup.enabled:
                    _cnpg_spec |= {
                        backup = {
                            barmanObjectStore = {
                                destinationPath = "s3://${_db_name}-backups/"
                                s3Credentials = {
                                    accessKeyId = {
                                        name = "${_db_name}-backup-creds"
                                        key = "ACCESS_KEY_ID"
                                    }
                                    secretAccessKey = {
                                        name = "${_db_name}-backup-creds"
                                        key = "SECRET_ACCESS_KEY"
                                    }
                                }
                            }
                            retentionPolicy = "${spec.backup.retentionDays}d"
                        }
                    }
            
                resources += [{
                    apiVersion = "postgresql.cnpg.io/v1"
                    kind = "Cluster"
                    metadata = {
                        name = "${_db_name}-cnpg"
                        namespace = _namespace
                        annotations = {
                            "krm.kcl.dev/composition-resource-name" = "${_db_name}-cnpg"
                        }
                        labels = _k8s_labels
                    }
                    spec = _cnpg_spec
                }]
            
                resources
            }
            
            get_status_kubernetes = lambda spec: schema.DatabaseSpec, ocds: any, name: str -> schema.DatabaseStatus {
                """Extract status from observed composed resources."""
                _db_name = name
                _observed_db = ocds.get("${_db_name}-cnpg", {})
                _observed_status = _observed_db.get("Resource", {}).get("status", {}) or {}
            
                _instances_ready = _observed_status.get("instancesReady", 0)
            
                schema.DatabaseStatus {
                    provider = "kubernetes"
                    region = "in-cluster"
                    engine = spec.engine
                    endpoint = "${_db_name}-cnpg-rw.${spec.namespace}.svc.cluster.local:5432" if _instances_ready > 0 else ""
                }
            }
            """
            AWS ECR resource generation for registry composition.
            """
            
            import crossplane_provider_upjet_aws.v1beta2.ecr_aws_upbound_io_v1beta2_repository as ecr
            import crossplane_provider_upjet_aws.v1beta1.ecr_aws_upbound_io_v1beta1_lifecycle_policy as ecr_lifecycle
            import schemas.registry as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            
            generate_aws = lambda spec: schema.RegistrySpec, ocds: any -> [any] {
                """Generate AWS ECR resources from RegistrySpec."""
                _name = spec.name
                _region = regions.get_aws_region(spec.region) if spec.region else ""
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "registry"
                    provider = "aws"
                    environment = spec.environment
                }
                _tags = labels.generate_tags(_label_config, "aws")
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # AWS ECR Repository
                resources += [ecr.Repository {
                    metadata = h.metadata_with_labels("${_name}-ecr", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            imageTagMutability = "IMMUTABLE" if spec.immutableTags else "MUTABLE"
                            imageScanningConfiguration = {
                                scanOnPush = spec.scanOnPush
                            }
                            encryptionConfiguration = [{
                                encryptionType = "AES256"
                            }] if spec.encryption else []
                            tags = _tags
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # AWS ECR Lifecycle Policy for retention
                if spec.retentionDays > 0:
                    resources += [ecr_lifecycle.LifecyclePolicy {
                        metadata = h.metadata_with_labels("${_name}-ecr-lifecycle", _k8s_labels)
                        spec = {
                            forProvider = {
                                region = _region
                                repositorySelector = {
                                    matchControllerRef = True
                                }
                                policy = '''{
                                    "rules": [
                                        {
                                            "rulePriority": 1,
                                            "description": "Expire untagged images older than ''' + str(spec.retentionDays) + ''' days",
                                            "selection": {
                                                "tagStatus": "untagged",
                                                "countType": "sinceImagePushed",
                                                "countUnit": "days",
                                                "countNumber": ''' + str(spec.retentionDays) + '''
                                            },
                                            "action": {
                                                "type": "expire"
                                            }
                                        }
                                    ]
                                }'''
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }]
            
                resources
            }
            
            get_status_aws = lambda spec: schema.RegistrySpec, ocds: any -> schema.RegistryStatus {
                """Extract status from observed composed resources."""
                _observed_ecr = ocds.get("${spec.name}-ecr", {})
                _observed_status = _observed_ecr.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _registry_url = _observed_status.get("repositoryUrl", "")
            
                schema.RegistryStatus {
                    provider = "aws"
                    region = spec.region
                    registryUrl = _registry_url
                    repositoryName = spec.name
                }
            }
            """
            GCP Artifact Registry resource generation for registry composition.
            """
            
            import crossplane_provider_upjet_gcp.v1beta1.artifact_gcp_upbound_io_v1beta1_registry_repository as artifact
            import schemas.registry as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            
            generate_gcp = lambda spec: schema.RegistrySpec, ocds: any -> [any] {
                """Generate GCP Artifact Registry resources from RegistrySpec."""
                _name = spec.name
                _region = regions.get_gcp_region(spec.region) if spec.region else ""
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "registry"
                    provider = "gcp"
                    environment = spec.environment
                }
                _gcp_labels = labels.generate_tags(_label_config, "gcp")
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # GCP Artifact Registry Repository
                resources += [artifact.RegistryRepository {
                    metadata = h.metadata_with_labels("${_name}-artifactregistry", _k8s_labels)
                    spec = {
                        forProvider = {
                            location = _region
                            format = spec.format.upper()
                            mode = "STANDARD_REPOSITORY"
                            labels = _gcp_labels
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                resources
            }
            
            get_status_gcp = lambda spec: schema.RegistrySpec, ocds: any -> schema.RegistryStatus {
                """Extract status from observed composed resources."""
                _observed_artifact = ocds.get("${spec.name}-artifactregistry", {})
                _observed_status = _observed_artifact.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _name = _observed_status.get("name", "")
                _region = spec.region
            
                schema.RegistryStatus {
                    provider = "gcp"
                    region = _region
                    registryUrl = "${_region}-docker.pkg.dev/${_name}" if _name else ""
                    repositoryName = spec.name
                }
            }
            """
            Kubernetes Harbor resource generation for registry composition.
            """
            
            import schemas.registry as schema
            import schemas.labels as labels
            import schemas.helpers as h
            
            generate_kubernetes = lambda spec: schema.RegistrySpec, ocds: any -> [any] {
                """Generate Harbor resources from RegistrySpec."""
                _name = spec.name
                _namespace = spec.namespace
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "registry"
                    provider = "kubernetes"
                    environment = spec.environment
                }
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # Harbor Cluster (using goharbor-operator)
                resources += [{
                    apiVersion = "goharbor.io/v1beta1"
                    kind = "HarborCluster"
                    metadata = {
                        name = "${_name}-harbor"
                        namespace = _namespace
                        annotations = {
                            "krm.kcl.dev/composition-resource-name" = "${_name}-harbor"
                        }
                        labels = _k8s_labels
                    }
                    spec = {
                        version = "2.11.0"
                        externalURL = "https://${_name}-harbor.${_namespace}.svc.cluster.local"
                        expose = {
                            core = {
                                ingress = {
                                    host = "${_name}-harbor.local"
                                }
                            }
                        }
                        database = {
                            kind = "PostgreSQL"
                            spec = {
                                embedded = {}
                            }
                        }
                        storage = {
                            kind = "FileSystem"
                            spec = {
                                fileSystem = {
                                    rootdirectory = "/storage"
                                }
                            }
                        }
                        cache = {
                            kind = "Redis"
                            spec = {
                                embedded = {}
                            }
                        }
                    }
                }]
            
                resources
            }
            
            get_status_kubernetes = lambda spec: schema.RegistrySpec, ocds: any -> schema.RegistryStatus {
                """Extract status from observed composed resources."""
                _observed_harbor = ocds.get("${spec.name}-harbor", {})
                _observed_status = _observed_harbor.get("Resource", {}).get("status", {}) or {}
            
                _external_url = _observed_status.get("externalURL", "")
            
                schema.RegistryStatus {
                    provider = "kubernetes"
                    region = "in-cluster"
                    registryUrl = _external_url if _external_url else "https://${spec.name}-harbor.${spec.namespace}.svc.cluster.local"
                    repositoryName = spec.name
                }
            }
            """
            AWS VPC resource generation for network composition.
            """
            
            import schemas.network as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            import schemas.mappings as m
            
            generate_aws = lambda spec: schema.NetworkSpec, ocds: any -> [any] {
                """Generate AWS VPC resources from NetworkSpec."""
                _name = spec.name
                _region = regions.get_aws_region(spec.region) if spec.region else ""
                _cidr = spec.cidrBlock
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "network"
                    provider = "aws"
                    environment = spec.environment
                }
                _tags = labels.generate_tags(_label_config, "aws")
                _k8s_labels = labels.generate_labels(_label_config)
            
                # Get subnets (use defaults if not provided)
                _subnets = spec.subnets or m.get_default_subnets("aws")
            
                resources: [any] = []
            
                # AWS VPC
                resources += [{
                    apiVersion = "ec2.aws.upbound.io/v1beta1"
                    kind = "VPC"
                    metadata = h.metadata_with_labels("${_name}-vpc", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            cidrBlock = _cidr
                            enableDnsSupport = spec.enableDnsSupport
                            enableDnsHostnames = spec.enableDnsHostnames
                            tags = _tags | {"Name": "${_name}-vpc", "network": _name}
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Internet Gateway
                resources += [{
                    apiVersion = "ec2.aws.upbound.io/v1beta1"
                    kind = "InternetGateway"
                    metadata = h.metadata_with_labels("${_name}-igw", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            vpcIdRef = {
                                name = "${_name}-vpc"
                            }
                            tags = _tags | {"Name": "${_name}-igw", "network": _name}
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Subnets
                resources += [
                    {
                        apiVersion = "ec2.aws.upbound.io/v1beta1"
                        kind = "Subnet"
                        metadata = h.metadata_with_labels("${_name}-${subnet.name}", _k8s_labels | {
                            "crossplane.io/network" = _name
                            "crossplane.io/visibility" = subnet.type
                        })
                        spec = {
                            forProvider = {
                                region = _region
                                cidrBlock = subnet.cidrBlock
                                vpcIdRef = {
                                    name = "${_name}-vpc"
                                }
                                availabilityZone = "${_region}${subnet.availabilityZone}" if subnet.availabilityZone else None
                                mapPublicIpOnLaunch = subnet.type == "public"
                                tags = _tags | {"Name": "${_name}-${subnet.name}", "Type": subnet.type, "network": _name}
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }
                    for subnet in _subnets
                ]
            
                # Public Route Table
                resources += [{
                    apiVersion = "ec2.aws.upbound.io/v1beta1"
                    kind = "RouteTable"
                    metadata = h.metadata_with_labels("${_name}-public-rt", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            vpcIdRef = {
                                name = "${_name}-vpc"
                            }
                            tags = _tags | {"Name": "${_name}-public-rt", "network": _name}
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Route to Internet Gateway
                resources += [{
                    apiVersion = "ec2.aws.upbound.io/v1beta1"
                    kind = "Route"
                    metadata = h.metadata_with_labels("${_name}-public-route", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            routeTableIdRef = {
                                name = "${_name}-public-rt"
                            }
                            destinationCidrBlock = "0.0.0.0/0"
                            gatewayIdRef = {
                                name = "${_name}-igw"
                            }
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Route Table Associations for public subnets
                resources += [
                    {
                        apiVersion = "ec2.aws.upbound.io/v1beta1"
                        kind = "RouteTableAssociation"
                        metadata = h.metadata_with_labels("${_name}-${subnet.name}-rta", _k8s_labels)
                        spec = {
                            forProvider = {
                                region = _region
                                routeTableIdRef = {
                                    name = "${_name}-public-rt"
                                }
                                subnetIdRef = {
                                    name = "${_name}-${subnet.name}"
                                }
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }
                    for subnet in _subnets if subnet.type == "public"
                ]
            
                resources
            }
            
            get_status_aws = lambda spec: schema.NetworkSpec, ocds: any -> schema.NetworkStatus {
                """Extract status from observed composed resources."""
                _observed_vpc = ocds.get("${spec.name}-vpc", {})
                _observed_status = _observed_vpc.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _vpc_id = _observed_status.get("id", "")
            
                schema.NetworkStatus {
                    provider = "aws"
                    region = spec.region
                    networkId = _vpc_id
                    cidrBlock = spec.cidrBlock
                }
            }
            """
            GCP Network resource generation for network composition.
            """
            
            import schemas.network as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            import schemas.mappings as m
            
            generate_gcp = lambda spec: schema.NetworkSpec, ocds: any -> [any] {
                """Generate GCP Network resources from NetworkSpec."""
                _name = spec.name
                _region = regions.get_gcp_region(spec.region) if spec.region else ""
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "network"
                    provider = "gcp"
                    environment = spec.environment
                }
                _k8s_labels = labels.generate_labels(_label_config)
            
                # Get subnets (use defaults if not provided)
                _subnets = spec.subnets or m.get_default_subnets("gcp")
            
                resources: [any] = []
            
                # GCP Network (VPC)
                resources += [{
                    apiVersion = "compute.gcp.upbound.io/v1beta1"
                    kind = "Network"
                    metadata = h.metadata_with_labels("${_name}-network", _k8s_labels)
                    spec = {
                        forProvider = {
                            autoCreateSubnetworks = False
                            routingMode = "REGIONAL"
                            description = "Managed by Crossplane - ${_name}"
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Subnetworks
                resources += [
                    {
                        apiVersion = "compute.gcp.upbound.io/v1beta1"
                        kind = "Subnetwork"
                        metadata = h.metadata_with_labels("${_name}-${subnet.name}", _k8s_labels | {
                            "crossplane.io/network" = _name
                            "crossplane.io/visibility" = subnet.type
                        })
                        spec = {
                            forProvider = {
                                region = _region
                                ipCidrRange = subnet.cidrBlock
                                networkRef = {
                                    name = "${_name}-network"
                                }
                                privateIpGoogleAccess = subnet.type == "private"
                                description = "${subnet.type} subnet - ${subnet.name}"
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }
                    for subnet in _subnets
                ]
            
                # Cloud Router for NAT (if there are private subnets)
                _has_private_subnets = any(subnet.type == "private" for subnet in _subnets)
                if _has_private_subnets:
                    resources += [{
                        apiVersion = "compute.gcp.upbound.io/v1beta1"
                        kind = "Router"
                        metadata = h.metadata_with_labels("${_name}-router", _k8s_labels)
                        spec = {
                            forProvider = {
                                region = _region
                                networkRef = {
                                    name = "${_name}-network"
                                }
                                description = "NAT router for ${_name}"
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }]
            
                    # Cloud NAT for private subnet internet access
                    resources += [{
                        apiVersion = "compute.gcp.upbound.io/v1beta1"
                        kind = "RouterNAT"
                        metadata = h.metadata_with_labels("${_name}-nat", _k8s_labels)
                        spec = {
                            forProvider = {
                                region = _region
                                routerRef = {
                                    name = "${_name}-router"
                                }
                                natIpAllocateOption = "AUTO_ONLY"
                                sourceSubnetworkIpRangesToNat = "ALL_SUBNETWORKS_ALL_IP_RANGES"
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }]
            
                resources
            }
            
            get_status_gcp = lambda spec: schema.NetworkSpec, ocds: any -> schema.NetworkStatus {
                """Extract status from observed composed resources."""
                _observed_network = ocds.get("${spec.name}-network", {})
                _observed_status = _observed_network.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _network_id = _observed_status.get("id", "")
            
                schema.NetworkStatus {
                    provider = "gcp"
                    region = spec.region
                    networkId = _network_id
                    cidrBlock = spec.cidrBlock
                }
            }
            """
            AWS S3 resource generation for bucket composition.
            """
            
            import model.io.upbound.aws.s3.v1beta2 as s3
            import model.io.upbound.aws.s3.v1beta1 as s3v1beta1
            import schemas.bucket as schema
            import schemas.labels as labels
            import schemas.helpers as h
            
            generate_aws = lambda spec: schema.BucketSpec, ocds: any -> [any] {
                """Generate AWS S3 resources from BucketSpec."""
                _bucket_name = spec.name
                _region = spec.region
                _storage_class = schema.map_storage_class("aws", spec.storageClass)
                _deletion_policy = spec.deletionPolicy
            
                _label_config = labels.LabelConfig {
                    name = _bucket_name
                    component = "storage"
                    provider = "aws"
                    environment = spec.environment
                }
                _tags = labels.generate_tags(_label_config, "aws") | spec.tags
            
                resources: [any] = []
            
                # Main S3 Bucket
                resources += [s3.Bucket {
                    metadata = h.metadata(_bucket_name)
                    spec = {
                        forProvider = {
                            region = _region
                            tags = _tags
                        }
                        deletionPolicy = _deletion_policy
                    }
                }]
            
                # Bucket versioning
                if spec.versioning:
                    resources += [s3.BucketVersioning {
                        metadata = h.metadata("${_bucket_name}-versioning")
                        spec = {
                            forProvider = {
                                region = _region
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                versioningConfiguration = {
                                    status = "Enabled"
                                }
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                # Server-side encryption
                if spec.encryption:
                    resources += [s3.BucketServerSideEncryptionConfiguration {
                        metadata = h.metadata("${_bucket_name}-encryption")
                        spec = {
                            forProvider = {
                                region = _region
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                $rule = [{
                                    applyServerSideEncryptionByDefault = {
                                        sseAlgorithm = "AES256"
                                    }
                                    bucketKeyEnabled = True
                                }]
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                # Public access block (default: block all public access)
                resources += [s3v1beta1.BucketPublicAccessBlock {
                    metadata = h.metadata("${_bucket_name}-public-access")
                    spec = {
                        forProvider = {
                            region = _region
                            bucketSelector = {
                                matchControllerRef = True
                            }
                            blockPublicAcls = not spec.publicAccess
                            blockPublicPolicy = not spec.publicAccess
                            ignorePublicAcls = not spec.publicAccess
                            restrictPublicBuckets = not spec.publicAccess
                        }
                        deletionPolicy = _deletion_policy
                    }
                }]
            
                # CORS configuration
                if spec.cors:
                    resources += [{
                        apiVersion = "s3.aws.upbound.io/v1beta1"
                        kind = "BucketCorsConfiguration"
                        metadata = h.metadata("${_bucket_name}-cors")
                        spec = {
                            forProvider = {
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                region = _region
                                corsRule = [
                                    {
                                        allowedOrigins = rule.allowedOrigins
                                        allowedMethods = rule.allowedMethods
                                        allowedHeaders = rule.allowedHeaders
                                        maxAgeSeconds = rule.maxAgeSeconds
                                    }
                                    for rule in spec.cors
                                ]
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                # Lifecycle rules
                if spec.lifecycle:
                    resources += [{
                        apiVersion = "s3.aws.upbound.io/v1beta1"
                        kind = "BucketLifecycleConfiguration"
                        metadata = h.metadata("${_bucket_name}-lifecycle")
                        spec = {
                            forProvider = {
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                region = _region
                                $rule = [
                                    _build_lifecycle_rule(rule)
                                    for rule in spec.lifecycle
                                ]
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                resources
            }
            
            _build_lifecycle_rule = lambda rule: schema.LifecycleRule -> any {
                """Build an AWS S3 lifecycle rule."""
                base: {str:any} = {
                    id = rule.name
                    status = "Enabled" if rule.enabled else "Disabled"
                }
            
                if rule.prefix:
                    base |= {filter = [{prefix = rule.prefix}]}
            
                if rule.expirationDays > 0:
                    base |= {expiration = [{days = rule.expirationDays}]}
            
                if rule.transitionDays > 0:
                    base |= {
                        transition = [{
                            days = rule.transitionDays
                            storageClass = schema.map_storage_class("aws", rule.transitionStorageClass)
                        }]
                    }
            
                base
            }
            
            get_status_aws = lambda spec: schema.BucketSpec, ocds: any -> schema.BucketStatus {
                """Extract status from observed composed resources."""
                _observed_bucket = ocds.get(spec.name, {})
                _observed_status = _observed_bucket.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _bucket_id = _observed_status.get("id", spec.name)
                _bucket_domain = _observed_status.get("bucketRegionalDomainName", "")
            
                schema.BucketStatus {
                    provider = "aws"
                    region = spec.region
                    bucketName = _bucket_id
                    url = "s3://${_bucket_id}"
                    id = _bucket_id
                    cloudUrl = "https://${_bucket_domain}" if _bucket_domain else "https://${spec.name}.s3.${spec.region}.amazonaws.com"
                }
            }
            """
            GCP Cloud Storage resource generation for bucket composition.
            """
            
            import model.io.upbound.gcp.storage.v1beta2 as gcs
            import schemas.bucket as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.common as c
            
            generate_gcp = lambda spec: schema.BucketSpec, ocds: any -> [any] {
                """Generate GCP Cloud Storage resources from BucketSpec."""
                _bucket_name = spec.name
                _location = c.map_region("gcp", spec.region).upper()
                _storage_class = schema.map_storage_class("gcp", spec.storageClass)
                _deletion_policy = spec.deletionPolicy
            
                _label_config = labels.LabelConfig {
                    name = _bucket_name
                    component = "storage"
                    provider = "gcp"
                    environment = spec.environment
                }
                _labels = labels.generate_tags(_label_config, "gcp") | {
                    k.lower().replace("-", "_"): v.lower()
                    for k, v in spec.tags
                    if len(k) <= 63 and len(v) <= 63
                }
            
                resources: [any] = []
            
                # Build bucket forProvider config
                _for_provider: {str:any} = {
                    location = _location
                    storageClass = _storage_class
                    labels = _labels
                    uniformBucketLevelAccess = True
                    publicAccessPrevention = "enforced" if not spec.publicAccess else "inherited"
                }
            
                # Add versioning if enabled
                if spec.versioning:
                    _for_provider |= {
                        versioning = [{
                            enabled = True
                        }]
                    }
            
                # Add CORS rules if specified
                if spec.cors:
                    _for_provider |= {
                        cors = [
                            {
                                origin = rule.allowedOrigins
                                method = rule.allowedMethods
                                responseHeader = rule.allowedHeaders
                                maxAgeSeconds = rule.maxAgeSeconds
                            }
                            for rule in spec.cors
                        ]
                    }
            
                # Add lifecycle rules if specified
                if spec.lifecycle:
                    _for_provider |= {
                        lifecycleRule = [
                            _build_lifecycle_rule(rule)
                            for rule in spec.lifecycle
                        ]
                    }
            
                # Main GCS Bucket
                resources += [gcs.Bucket {
                    metadata = h.metadata(_bucket_name)
                    spec = {
                        forProvider = _for_provider
                        deletionPolicy = _deletion_policy
                    }
                }]
            
                # IAM binding for public access if enabled
                if spec.publicAccess:
                    resources += [{
                        apiVersion = "storage.gcp.upbound.io/v1beta1"
                        kind = "BucketIAMMember"
                        metadata = h.metadata("${_bucket_name}-public-read")
                        spec = {
                            forProvider = {
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                role = "roles/storage.objectViewer"
                                member = "allUsers"
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                resources
            }
            
            _build_lifecycle_rule = lambda rule: schema.LifecycleRule -> any {
                """Build a GCP lifecycle rule."""
                result: {str:any} = {
                    action = {}
                    condition = {}
                }
            
                if rule.expirationDays > 0:
                    result.action |= {$type = "Delete"}
                    result.condition |= {age = rule.expirationDays}
                elif rule.transitionDays > 0:
                    result.action |= {
                        $type = "SetStorageClass"
                        storageClass = schema.map_storage_class("gcp", rule.transitionStorageClass)
                    }
                    result.condition |= {age = rule.transitionDays}
            
                if rule.prefix:
                    result.condition |= {matchesPrefix = [rule.prefix]}
            
                result
            }
            
            get_status_gcp = lambda spec: schema.BucketSpec, ocds: any -> schema.BucketStatus {
                """Extract status from observed composed resources."""
                _observed_bucket = ocds.get(spec.name, {})
                _observed_status = _observed_bucket.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _bucket_url = _observed_status.get("url", "")
                _bucket_self_link = _observed_status.get("selfLink", "")
            
                schema.BucketStatus {
                    provider = "gcp"
                    region = spec.region
                    bucketName = spec.name
                    url = _bucket_url if _bucket_url else "gs://${spec.name}"
                    id = spec.name
                    cloudUrl = _bucket_self_link if _bucket_self_link else "https://storage.googleapis.com/${spec.name}"
                }
            }
            """
            AWS RDS resource generation for database composition.
            """
            
            import crossplane_provider_upjet_aws.v1beta2.rds_aws_upbound_io_v1beta2_instance as rds
            import schemas.database as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            
            generate_aws = lambda spec: schema.DatabaseSpec, ocds: any -> [any] {
                """Generate AWS RDS resources from DatabaseSpec."""
                _db_name = spec.region  # use oxr metadata name
                _region = regions.get_aws_region(spec.region) if spec.region else ""
                _instance_class = schema.get_instance_class("aws", spec.size)
                _engine_version = schema.get_engine_version(spec.engine, "aws", spec.engineVersion)
                _storage_type = schema.get_storage_type("aws", spec.storageType)
            
                _label_config = labels.LabelConfig {
                    name = _db_name
                    component = "database"
                    provider = "aws"
                    environment = spec.environment
                }
                _tags = labels.generate_tags(_label_config, "aws") | spec.tags
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # Main RDS Instance using typed schema
                _rds_spec: {str:any} = {
                    forProvider = {
                        region = _region
                        engine = spec.engine
                        engineVersion = _engine_version
                        instanceClass = _instance_class
                        allocatedStorage = spec.storageGB
                        storageType = _storage_type
                        storageEncrypted = True
                        multiAz = spec.multiAZ
                        publiclyAccessible = spec.publiclyAccessible
                        skipFinalSnapshot = spec.environment != "prod"
                        copyTagsToSnapshot = True
                        tags = _tags
                    }
                    deletionPolicy = spec.deletionPolicy
                }
            
                # Add final snapshot identifier for prod
                if spec.environment == "prod":
                    _rds_spec.forProvider |= {
                        finalSnapshotIdentifier = "${_db_name}-final"
                    }
            
                # Add backup configuration
                if spec.backup.enabled:
                    _rds_spec.forProvider |= {
                        backupRetentionPeriod = spec.backup.retentionDays
                        backupWindow = spec.backup.preferredWindow
                    }
            
                # Add password configuration
                if spec.secrets.generatePassword:
                    _rds_spec.forProvider |= {
                        username = "admin"
                        autoGeneratePassword = True
                    }
                    _rds_spec |= {
                        writeConnectionSecretToRef = {
                            name = "${_db_name}-credentials"
                            namespace = "crossplane-system"
                        }
                    }
                elif spec.secrets.passwordSecretRef:
                    _rds_spec.forProvider |= {
                        username = "admin"
                        passwordSecretRef = {
                            name = spec.secrets.passwordSecretRef
                            namespace = "crossplane-system"
                            key = "password"
                        }
                    }
            
                resources += [rds.Instance {
                    metadata = h.metadata_with_labels("${_db_name}-rds", _k8s_labels)
                    spec = _rds_spec
                }]
            
                resources
            }
            
            get_status_aws = lambda spec: schema.DatabaseSpec, ocds: any -> schema.DatabaseStatus {
                """Extract status from observed composed resources."""
                _db_name = spec.region
                _observed_db = ocds.get("${_db_name}-rds", {})
                _observed_status = _observed_db.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _endpoint = _observed_status.get("endpoint", "")
            
                schema.DatabaseStatus {
                    provider = "aws"
                    region = spec.region
                    engine = spec.engine
                    endpoint = _endpoint
                }
            }
            """
            GCP Cloud SQL resource generation for database composition.
            """
            
            import schemas.database as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.common as c
            
            generate_gcp = lambda spec: schema.DatabaseSpec, ocds: any, name: str -> [any] {
                """Generate GCP Cloud SQL resources from DatabaseSpec."""
                _db_name = name
                _region = c.map_region("gcp", spec.region) if spec.region else ""
                _tier = schema.get_instance_class("gcp", spec.size)
                _database_version = _get_gcp_database_version(spec.engine, spec.engineVersion)
            
                _label_config = labels.LabelConfig {
                    name = _db_name
                    component = "database"
                    provider = "gcp"
                    environment = spec.environment
                }
                _user_labels = labels.generate_tags(_label_config, "gcp") | {
                    k.lower().replace("-", "_"): v.lower()
                    for k, v in spec.tags
                    if len(k) <= 63 and len(v) <= 63
                }
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # Build settings
                _settings: {str:any} = {
                    tier = _tier
                    diskSize = spec.storageGB
                    diskType = "PD_SSD"
                    diskAutoresize = True
                    diskAutoresizeLimit = spec.storageGB * 2
                    availabilityType = "REGIONAL" if spec.multiAZ else "ZONAL"
                    userLabels = _user_labels
                    ipConfiguration = {
                        ipv4Enabled = spec.publiclyAccessible
                        requireSsl = True
                    }
                }
            
                # Add backup configuration
                if spec.backup.enabled:
                    _settings |= {
                        backupConfiguration = {
                            enabled = True
                            startTime = spec.backup.preferredWindow.split("-")[0]
                            pointInTimeRecoveryEnabled = True
                            transactionLogRetentionDays = spec.backup.retentionDays
                            backupRetentionSettings = {
                                retainedBackups = spec.backup.retentionDays
                                retentionUnit = "COUNT"
                            }
                        }
                    }
            
                # Main Cloud SQL Instance
                _sql_spec: {str:any} = {
                    forProvider = {
                        region = _region
                        databaseVersion = _database_version
                        deletionProtection = spec.environment == "prod"
                        settings = _settings
                    }
                    deletionPolicy = spec.deletionPolicy
                }
            
                # Add write connection secret if auto-generating password
                if spec.secrets.generatePassword:
                    _sql_spec |= {
                        writeConnectionSecretToRef = {
                            name = "${_db_name}-credentials"
                            namespace = "crossplane-system"
                        }
                    }
            
                resources += [{
                    apiVersion = "sql.gcp.upbound.io/v1beta2"
                    kind = "DatabaseInstance"
                    metadata = h.metadata_with_labels("${_db_name}-cloudsql", _k8s_labels)
                    spec = _sql_spec
                }]
            
                # Create database
                resources += [{
                    apiVersion = "sql.gcp.upbound.io/v1beta1"
                    kind = "Database"
                    metadata = h.metadata_with_labels("${_db_name}-db", _k8s_labels)
                    spec = {
                        forProvider = {
                            instanceSelector = {
                                matchControllerRef = True
                            }
                            charset = "UTF8" if spec.engine == "postgres" else "utf8mb4"
                            collation = "en_US.UTF8" if spec.engine == "postgres" else "utf8mb4_general_ci"
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Create user
                _user_spec: {str:any} = {
                    forProvider = {
                        instanceSelector = {
                            matchControllerRef = True
                        }
                        $type = "BUILT_IN"
                    }
                    deletionPolicy = spec.deletionPolicy
                }
            
                if spec.secrets.generatePassword:
                    _user_spec.forProvider |= {
                        passwordSecretRef = {
                            name = "${_db_name}-user-password"
                            namespace = "crossplane-system"
                            key = "password"
                        }
                    }
                elif spec.secrets.passwordSecretRef:
                    _user_spec.forProvider |= {
                        passwordSecretRef = {
                            name = spec.secrets.passwordSecretRef
                            namespace = "crossplane-system"
                            key = "password"
                        }
                    }
            
                resources += [{
                    apiVersion = "sql.gcp.upbound.io/v1beta1"
                    kind = "User"
                    metadata = h.metadata_with_labels("${_db_name}-user", _k8s_labels)
                    spec = _user_spec
                }]
            
                resources
            }
            
            _get_gcp_database_version = lambda engine: str, version: str -> str {
                """Get the GCP Cloud SQL database version string."""
                if engine == "postgres":
                    "POSTGRES_${version}"
                else:
                    "MYSQL_8_0"
            }
            
            get_status_gcp = lambda spec: schema.DatabaseSpec, ocds: any, name: str -> schema.DatabaseStatus {
                """Extract status from observed composed resources."""
                _db_name = name
                _observed_db = ocds.get("${_db_name}-cloudsql", {})
                _observed_status = _observed_db.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _connection_name = _observed_status.get("connectionName", "")
            
                schema.DatabaseStatus {
                    provider = "gcp"
                    region = spec.region
                    engine = spec.engine
                    endpoint = _connection_name
                }
            }
            """
            Kubernetes CloudNative-PG resource generation for database composition.
            """
            
            import schemas.database as schema
            import schemas.labels as labels
            import schemas.helpers as h
            
            generate_kubernetes = lambda spec: schema.DatabaseSpec, ocds: any, name: str -> [any] {
                """Generate CloudNative-PG Cluster from DatabaseSpec."""
                _db_name = name
                _namespace = spec.namespace
                _resources = schema.get_instance_class("kubernetes", spec.size)
            
                _label_config = labels.LabelConfig {
                    name = _db_name
                    component = "database"
                    provider = "kubernetes"
                    environment = spec.environment
                }
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # CloudNative-PG Cluster
                _cnpg_spec: {str:any} = {
                    instances = spec.instances
                    imageName = "ghcr.io/cloudnative-pg/postgresql:${spec.engineVersion}"
                    postgresql = {
                        parameters = {
                            max_connections = "100"
                            shared_buffers = "128MB"
                        }
                    }
                    bootstrap = {
                        initdb = {
                            database = "app"
                            owner = "app"
                        }
                    }
                    storage = {
                        size = "${spec.storageGB}Gi"
                    }
                    resources = {
                        requests = _resources
                        limits = _resources
                    }
                    monitoring = {
                        enablePodMonitor = spec.environment != "dev"
                    }
                }
            
                # Add backup configuration if enabled
                if spec.backup.enabled:
                    _cnpg_spec |= {
                        backup = {
                            barmanObjectStore = {
                                destinationPath = "s3://${_db_name}-backups/"
                                s3Credentials = {
                                    accessKeyId = {
                                        name = "${_db_name}-backup-creds"
                                        key = "ACCESS_KEY_ID"
                                    }
                                    secretAccessKey = {
                                        name = "${_db_name}-backup-creds"
                                        key = "SECRET_ACCESS_KEY"
                                    }
                                }
                            }
                            retentionPolicy = "${spec.backup.retentionDays}d"
                        }
                    }
            
                resources += [{
                    apiVersion = "postgresql.cnpg.io/v1"
                    kind = "Cluster"
                    metadata = {
                        name = "${_db_name}-cnpg"
                        namespace = _namespace
                        annotations = {
                            "krm.kcl.dev/composition-resource-name" = "${_db_name}-cnpg"
                        }
                        labels = _k8s_labels
                    }
                    spec = _cnpg_spec
                }]
            
                resources
            }
            
            get_status_kubernetes = lambda spec: schema.DatabaseSpec, ocds: any, name: str -> schema.DatabaseStatus {
                """Extract status from observed composed resources."""
                _db_name = name
                _observed_db = ocds.get("${_db_name}-cnpg", {})
                _observed_status = _observed_db.get("Resource", {}).get("status", {}) or {}
            
                _instances_ready = _observed_status.get("instancesReady", 0)
            
                schema.DatabaseStatus {
                    provider = "kubernetes"
                    region = "in-cluster"
                    engine = spec.engine
                    endpoint = "${_db_name}-cnpg-rw.${spec.namespace}.svc.cluster.local:5432" if _instances_ready > 0 else ""
                }
            }
            """
            AWS ECR resource generation for registry composition.
            """
            
            import crossplane_provider_upjet_aws.v1beta2.ecr_aws_upbound_io_v1beta2_repository as ecr
            import crossplane_provider_upjet_aws.v1beta1.ecr_aws_upbound_io_v1beta1_lifecycle_policy as ecr_lifecycle
            import schemas.registry as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            
            generate_aws = lambda spec: schema.RegistrySpec, ocds: any -> [any] {
                """Generate AWS ECR resources from RegistrySpec."""
                _name = spec.name
                _region = regions.get_aws_region(spec.region) if spec.region else ""
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "registry"
                    provider = "aws"
                    environment = spec.environment
                }
                _tags = labels.generate_tags(_label_config, "aws")
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # AWS ECR Repository
                resources += [ecr.Repository {
                    metadata = h.metadata_with_labels("${_name}-ecr", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            imageTagMutability = "IMMUTABLE" if spec.immutableTags else "MUTABLE"
                            imageScanningConfiguration = {
                                scanOnPush = spec.scanOnPush
                            }
                            encryptionConfiguration = [{
                                encryptionType = "AES256"
                            }] if spec.encryption else []
                            tags = _tags
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # AWS ECR Lifecycle Policy for retention
                if spec.retentionDays > 0:
                    resources += [ecr_lifecycle.LifecyclePolicy {
                        metadata = h.metadata_with_labels("${_name}-ecr-lifecycle", _k8s_labels)
                        spec = {
                            forProvider = {
                                region = _region
                                repositorySelector = {
                                    matchControllerRef = True
                                }
                                policy = '''{
                                    "rules": [
                                        {
                                            "rulePriority": 1,
                                            "description": "Expire untagged images older than ''' + str(spec.retentionDays) + ''' days",
                                            "selection": {
                                                "tagStatus": "untagged",
                                                "countType": "sinceImagePushed",
                                                "countUnit": "days",
                                                "countNumber": ''' + str(spec.retentionDays) + '''
                                            },
                                            "action": {
                                                "type": "expire"
                                            }
                                        }
                                    ]
                                }'''
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }]
            
                resources
            }
            
            get_status_aws = lambda spec: schema.RegistrySpec, ocds: any -> schema.RegistryStatus {
                """Extract status from observed composed resources."""
                _observed_ecr = ocds.get("${spec.name}-ecr", {})
                _observed_status = _observed_ecr.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _registry_url = _observed_status.get("repositoryUrl", "")
            
                schema.RegistryStatus {
                    provider = "aws"
                    region = spec.region
                    registryUrl = _registry_url
                    repositoryName = spec.name
                }
            }
            """
            GCP Artifact Registry resource generation for registry composition.
            """
            
            import crossplane_provider_upjet_gcp.v1beta1.artifact_gcp_upbound_io_v1beta1_registry_repository as artifact
            import schemas.registry as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            
            generate_gcp = lambda spec: schema.RegistrySpec, ocds: any -> [any] {
                """Generate GCP Artifact Registry resources from RegistrySpec."""
                _name = spec.name
                _region = regions.get_gcp_region(spec.region) if spec.region else ""
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "registry"
                    provider = "gcp"
                    environment = spec.environment
                }
                _gcp_labels = labels.generate_tags(_label_config, "gcp")
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # GCP Artifact Registry Repository
                resources += [artifact.RegistryRepository {
                    metadata = h.metadata_with_labels("${_name}-artifactregistry", _k8s_labels)
                    spec = {
                        forProvider = {
                            location = _region
                            format = spec.format.upper()
                            mode = "STANDARD_REPOSITORY"
                            labels = _gcp_labels
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                resources
            }
            
            get_status_gcp = lambda spec: schema.RegistrySpec, ocds: any -> schema.RegistryStatus {
                """Extract status from observed composed resources."""
                _observed_artifact = ocds.get("${spec.name}-artifactregistry", {})
                _observed_status = _observed_artifact.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _name = _observed_status.get("name", "")
                _region = spec.region
            
                schema.RegistryStatus {
                    provider = "gcp"
                    region = _region
                    registryUrl = "${_region}-docker.pkg.dev/${_name}" if _name else ""
                    repositoryName = spec.name
                }
            }
            """
            Kubernetes Harbor resource generation for registry composition.
            """
            
            import schemas.registry as schema
            import schemas.labels as labels
            import schemas.helpers as h
            
            generate_kubernetes = lambda spec: schema.RegistrySpec, ocds: any -> [any] {
                """Generate Harbor resources from RegistrySpec."""
                _name = spec.name
                _namespace = spec.namespace
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "registry"
                    provider = "kubernetes"
                    environment = spec.environment
                }
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # Harbor Cluster (using goharbor-operator)
                resources += [{
                    apiVersion = "goharbor.io/v1beta1"
                    kind = "HarborCluster"
                    metadata = {
                        name = "${_name}-harbor"
                        namespace = _namespace
                        annotations = {
                            "krm.kcl.dev/composition-resource-name" = "${_name}-harbor"
                        }
                        labels = _k8s_labels
                    }
                    spec = {
                        version = "2.11.0"
                        externalURL = "https://${_name}-harbor.${_namespace}.svc.cluster.local"
                        expose = {
                            core = {
                                ingress = {
                                    host = "${_name}-harbor.local"
                                }
                            }
                        }
                        database = {
                            kind = "PostgreSQL"
                            spec = {
                                embedded = {}
                            }
                        }
                        storage = {
                            kind = "FileSystem"
                            spec = {
                                fileSystem = {
                                    rootdirectory = "/storage"
                                }
                            }
                        }
                        cache = {
                            kind = "Redis"
                            spec = {
                                embedded = {}
                            }
                        }
                    }
                }]
            
                resources
            }
            
            get_status_kubernetes = lambda spec: schema.RegistrySpec, ocds: any -> schema.RegistryStatus {
                """Extract status from observed composed resources."""
                _observed_harbor = ocds.get("${spec.name}-harbor", {})
                _observed_status = _observed_harbor.get("Resource", {}).get("status", {}) or {}
            
                _external_url = _observed_status.get("externalURL", "")
            
                schema.RegistryStatus {
                    provider = "kubernetes"
                    region = "in-cluster"
                    registryUrl = _external_url if _external_url else "https://${spec.name}-harbor.${spec.namespace}.svc.cluster.local"
                    repositoryName = spec.name
                }
            }
            """
            AWS VPC resource generation for network composition.
            """
            
            import schemas.network as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            import schemas.mappings as m
            
            generate_aws = lambda spec: schema.NetworkSpec, ocds: any -> [any] {
                """Generate AWS VPC resources from NetworkSpec."""
                _name = spec.name
                _region = regions.get_aws_region(spec.region) if spec.region else ""
                _cidr = spec.cidrBlock
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "network"
                    provider = "aws"
                    environment = spec.environment
                }
                _tags = labels.generate_tags(_label_config, "aws")
                _k8s_labels = labels.generate_labels(_label_config)
            
                # Get subnets (use defaults if not provided)
                _subnets = spec.subnets or m.get_default_subnets("aws")
            
                resources: [any] = []
            
                # AWS VPC
                resources += [{
                    apiVersion = "ec2.aws.upbound.io/v1beta1"
                    kind = "VPC"
                    metadata = h.metadata_with_labels("${_name}-vpc", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            cidrBlock = _cidr
                            enableDnsSupport = spec.enableDnsSupport
                            enableDnsHostnames = spec.enableDnsHostnames
                            tags = _tags | {"Name": "${_name}-vpc", "network": _name}
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Internet Gateway
                resources += [{
                    apiVersion = "ec2.aws.upbound.io/v1beta1"
                    kind = "InternetGateway"
                    metadata = h.metadata_with_labels("${_name}-igw", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            vpcIdRef = {
                                name = "${_name}-vpc"
                            }
                            tags = _tags | {"Name": "${_name}-igw", "network": _name}
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Subnets
                resources += [
                    {
                        apiVersion = "ec2.aws.upbound.io/v1beta1"
                        kind = "Subnet"
                        metadata = h.metadata_with_labels("${_name}-${subnet.name}", _k8s_labels | {
                            "crossplane.io/network" = _name
                            "crossplane.io/visibility" = subnet.type
                        })
                        spec = {
                            forProvider = {
                                region = _region
                                cidrBlock = subnet.cidrBlock
                                vpcIdRef = {
                                    name = "${_name}-vpc"
                                }
                                availabilityZone = "${_region}${subnet.availabilityZone}" if subnet.availabilityZone else None
                                mapPublicIpOnLaunch = subnet.type == "public"
                                tags = _tags | {"Name": "${_name}-${subnet.name}", "Type": subnet.type, "network": _name}
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }
                    for subnet in _subnets
                ]
            
                # Public Route Table
                resources += [{
                    apiVersion = "ec2.aws.upbound.io/v1beta1"
                    kind = "RouteTable"
                    metadata = h.metadata_with_labels("${_name}-public-rt", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            vpcIdRef = {
                                name = "${_name}-vpc"
                            }
                            tags = _tags | {"Name": "${_name}-public-rt", "network": _name}
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Route to Internet Gateway
                resources += [{
                    apiVersion = "ec2.aws.upbound.io/v1beta1"
                    kind = "Route"
                    metadata = h.metadata_with_labels("${_name}-public-route", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            routeTableIdRef = {
                                name = "${_name}-public-rt"
                            }
                            destinationCidrBlock = "0.0.0.0/0"
                            gatewayIdRef = {
                                name = "${_name}-igw"
                            }
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Route Table Associations for public subnets
                resources += [
                    {
                        apiVersion = "ec2.aws.upbound.io/v1beta1"
                        kind = "RouteTableAssociation"
                        metadata = h.metadata_with_labels("${_name}-${subnet.name}-rta", _k8s_labels)
                        spec = {
                            forProvider = {
                                region = _region
                                routeTableIdRef = {
                                    name = "${_name}-public-rt"
                                }
                                subnetIdRef = {
                                    name = "${_name}-${subnet.name}"
                                }
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }
                    for subnet in _subnets if subnet.type == "public"
                ]
            
                resources
            }
            
            get_status_aws = lambda spec: schema.NetworkSpec, ocds: any -> schema.NetworkStatus {
                """Extract status from observed composed resources."""
                _observed_vpc = ocds.get("${spec.name}-vpc", {})
                _observed_status = _observed_vpc.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _vpc_id = _observed_status.get("id", "")
            
                schema.NetworkStatus {
                    provider = "aws"
                    region = spec.region
                    networkId = _vpc_id
                    cidrBlock = spec.cidrBlock
                }
            }
            """
            GCP Network resource generation for network composition.
            """
            
            import schemas.network as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            import schemas.mappings as m
            
            generate_gcp = lambda spec: schema.NetworkSpec, ocds: any -> [any] {
                """Generate GCP Network resources from NetworkSpec."""
                _name = spec.name
                _region = regions.get_gcp_region(spec.region) if spec.region else ""
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "network"
                    provider = "gcp"
                    environment = spec.environment
                }
                _k8s_labels = labels.generate_labels(_label_config)
            
                # Get subnets (use defaults if not provided)
                _subnets = spec.subnets or m.get_default_subnets("gcp")
            
                resources: [any] = []
            
                # GCP Network (VPC)
                resources += [{
                    apiVersion = "compute.gcp.upbound.io/v1beta1"
                    kind = "Network"
                    metadata = h.metadata_with_labels("${_name}-network", _k8s_labels)
                    spec = {
                        forProvider = {
                            autoCreateSubnetworks = False
                            routingMode = "REGIONAL"
                            description = "Managed by Crossplane - ${_name}"
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Subnetworks
                resources += [
                    {
                        apiVersion = "compute.gcp.upbound.io/v1beta1"
                        kind = "Subnetwork"
                        metadata = h.metadata_with_labels("${_name}-${subnet.name}", _k8s_labels | {
                            "crossplane.io/network" = _name
                            "crossplane.io/visibility" = subnet.type
                        })
                        spec = {
                            forProvider = {
                                region = _region
                                ipCidrRange = subnet.cidrBlock
                                networkRef = {
                                    name = "${_name}-network"
                                }
                                privateIpGoogleAccess = subnet.type == "private"
                                description = "${subnet.type} subnet - ${subnet.name}"
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }
                    for subnet in _subnets
                ]
            
                # Cloud Router for NAT (if there are private subnets)
                _has_private_subnets = any(subnet.type == "private" for subnet in _subnets)
                if _has_private_subnets:
                    resources += [{
                        apiVersion = "compute.gcp.upbound.io/v1beta1"
                        kind = "Router"
                        metadata = h.metadata_with_labels("${_name}-router", _k8s_labels)
                        spec = {
                            forProvider = {
                                region = _region
                                networkRef = {
                                    name = "${_name}-network"
                                }
                                description = "NAT router for ${_name}"
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }]
            
                    # Cloud NAT for private subnet internet access
                    resources += [{
                        apiVersion = "compute.gcp.upbound.io/v1beta1"
                        kind = "RouterNAT"
                        metadata = h.metadata_with_labels("${_name}-nat", _k8s_labels)
                        spec = {
                            forProvider = {
                                region = _region
                                routerRef = {
                                    name = "${_name}-router"
                                }
                                natIpAllocateOption = "AUTO_ONLY"
                                sourceSubnetworkIpRangesToNat = "ALL_SUBNETWORKS_ALL_IP_RANGES"
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }]
            
                resources
            }
            
            get_status_gcp = lambda spec: schema.NetworkSpec, ocds: any -> schema.NetworkStatus {
                """Extract status from observed composed resources."""
                _observed_network = ocds.get("${spec.name}-network", {})
                _observed_status = _observed_network.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _network_id = _observed_status.get("id", "")
            
                schema.NetworkStatus {
                    provider = "gcp"
                    region = spec.region
                    networkId = _network_id
                    cidrBlock = spec.cidrBlock
                }
            }
            """
            AWS S3 resource generation for bucket composition.
            """
            
            import model.io.upbound.aws.s3.v1beta2 as s3
            import model.io.upbound.aws.s3.v1beta1 as s3v1beta1
            import schemas.bucket as schema
            import schemas.labels as labels
            import schemas.helpers as h
            
            generate_aws = lambda spec: schema.BucketSpec, ocds: any -> [any] {
                """Generate AWS S3 resources from BucketSpec."""
                _bucket_name = spec.name
                _region = spec.region
                _storage_class = schema.map_storage_class("aws", spec.storageClass)
                _deletion_policy = spec.deletionPolicy
            
                _label_config = labels.LabelConfig {
                    name = _bucket_name
                    component = "storage"
                    provider = "aws"
                    environment = spec.environment
                }
                _tags = labels.generate_tags(_label_config, "aws") | spec.tags
            
                resources: [any] = []
            
                # Main S3 Bucket
                resources += [s3.Bucket {
                    metadata = h.metadata(_bucket_name)
                    spec = {
                        forProvider = {
                            region = _region
                            tags = _tags
                        }
                        deletionPolicy = _deletion_policy
                    }
                }]
            
                # Bucket versioning
                if spec.versioning:
                    resources += [s3.BucketVersioning {
                        metadata = h.metadata("${_bucket_name}-versioning")
                        spec = {
                            forProvider = {
                                region = _region
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                versioningConfiguration = {
                                    status = "Enabled"
                                }
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                # Server-side encryption
                if spec.encryption:
                    resources += [s3.BucketServerSideEncryptionConfiguration {
                        metadata = h.metadata("${_bucket_name}-encryption")
                        spec = {
                            forProvider = {
                                region = _region
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                $rule = [{
                                    applyServerSideEncryptionByDefault = {
                                        sseAlgorithm = "AES256"
                                    }
                                    bucketKeyEnabled = True
                                }]
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                # Public access block (default: block all public access)
                resources += [s3v1beta1.BucketPublicAccessBlock {
                    metadata = h.metadata("${_bucket_name}-public-access")
                    spec = {
                        forProvider = {
                            region = _region
                            bucketSelector = {
                                matchControllerRef = True
                            }
                            blockPublicAcls = not spec.publicAccess
                            blockPublicPolicy = not spec.publicAccess
                            ignorePublicAcls = not spec.publicAccess
                            restrictPublicBuckets = not spec.publicAccess
                        }
                        deletionPolicy = _deletion_policy
                    }
                }]
            
                # CORS configuration
                if spec.cors:
                    resources += [{
                        apiVersion = "s3.aws.upbound.io/v1beta1"
                        kind = "BucketCorsConfiguration"
                        metadata = h.metadata("${_bucket_name}-cors")
                        spec = {
                            forProvider = {
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                region = _region
                                corsRule = [
                                    {
                                        allowedOrigins = rule.allowedOrigins
                                        allowedMethods = rule.allowedMethods
                                        allowedHeaders = rule.allowedHeaders
                                        maxAgeSeconds = rule.maxAgeSeconds
                                    }
                                    for rule in spec.cors
                                ]
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                # Lifecycle rules
                if spec.lifecycle:
                    resources += [{
                        apiVersion = "s3.aws.upbound.io/v1beta1"
                        kind = "BucketLifecycleConfiguration"
                        metadata = h.metadata("${_bucket_name}-lifecycle")
                        spec = {
                            forProvider = {
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                region = _region
                                $rule = [
                                    _build_lifecycle_rule(rule)
                                    for rule in spec.lifecycle
                                ]
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                resources
            }
            
            _build_lifecycle_rule = lambda rule: schema.LifecycleRule -> any {
                """Build an AWS S3 lifecycle rule."""
                base: {str:any} = {
                    id = rule.name
                    status = "Enabled" if rule.enabled else "Disabled"
                }
            
                if rule.prefix:
                    base |= {$filter = [{prefix = rule.prefix}]}
            
                if rule.expirationDays > 0:
                    base |= {$expiration = [{days = rule.expirationDays}]}
            
                if rule.transitionDays > 0:
                    base |= {
                        $transition = [{
                            days = rule.transitionDays
                            storageClass = schema.map_storage_class("aws", rule.transitionStorageClass)
                        }]
                    }
            
                base
            }
            
            get_status_aws = lambda spec: schema.BucketSpec, ocds: any -> schema.BucketStatus {
                """Extract status from observed composed resources."""
                _observed_bucket = ocds.get(spec.name, {})
                _observed_status = _observed_bucket.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _bucket_id = _observed_status.get("id", spec.name)
                _bucket_domain = _observed_status.get("bucketRegionalDomainName", "")
            
                schema.BucketStatus {
                    provider = "aws"
                    region = spec.region
                    bucketName = _bucket_id
                    url = "s3://${_bucket_id}"
                    id = _bucket_id
                    cloudUrl = "https://${_bucket_domain}" if _bucket_domain else "https://${spec.name}.s3.${spec.region}.amazonaws.com"
                }
            }
            """
            GCP Cloud Storage resource generation for bucket composition.
            """
            
            import model.io.upbound.gcp.storage.v1beta2 as gcs
            import schemas.bucket as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.common as c
            
            generate_gcp = lambda spec: schema.BucketSpec, ocds: any -> [any] {
                """Generate GCP Cloud Storage resources from BucketSpec."""
                _bucket_name = spec.name
                _location = c.map_region("gcp", spec.region).upper()
                _storage_class = schema.map_storage_class("gcp", spec.storageClass)
                _deletion_policy = spec.deletionPolicy
            
                _label_config = labels.LabelConfig {
                    name = _bucket_name
                    component = "storage"
                    provider = "gcp"
                    environment = spec.environment
                }
                _labels = labels.generate_tags(_label_config, "gcp") | {
                    k.lower().replace("-", "_"): v.lower()
                    for k, v in spec.tags
                    if len(k) <= 63 and len(v) <= 63
                }
            
                resources: [any] = []
            
                # Build bucket forProvider config
                _for_provider: {str:any} = {
                    location = _location
                    storageClass = _storage_class
                    labels = _labels
                    uniformBucketLevelAccess = True
                    publicAccessPrevention = "enforced" if not spec.publicAccess else "inherited"
                }
            
                # Add versioning if enabled
                if spec.versioning:
                    _for_provider |= {
                        versioning = [{
                            enabled = True
                        }]
                    }
            
                # Add CORS rules if specified
                if spec.cors:
                    _for_provider |= {
                        cors = [
                            {
                                origin = rule.allowedOrigins
                                method = rule.allowedMethods
                                responseHeader = rule.allowedHeaders
                                maxAgeSeconds = rule.maxAgeSeconds
                            }
                            for rule in spec.cors
                        ]
                    }
            
                # Add lifecycle rules if specified
                if spec.lifecycle:
                    _for_provider |= {
                        lifecycleRule = [
                            _build_lifecycle_rule(rule)
                            for rule in spec.lifecycle
                        ]
                    }
            
                # Main GCS Bucket
                resources += [gcs.Bucket {
                    metadata = h.metadata(_bucket_name)
                    spec = {
                        forProvider = _for_provider
                        deletionPolicy = _deletion_policy
                    }
                }]
            
                # IAM binding for public access if enabled
                if spec.publicAccess:
                    resources += [{
                        apiVersion = "storage.gcp.upbound.io/v1beta1"
                        kind = "BucketIAMMember"
                        metadata = h.metadata("${_bucket_name}-public-read")
                        spec = {
                            forProvider = {
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                role = "roles/storage.objectViewer"
                                member = "allUsers"
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                resources
            }
            
            _build_lifecycle_rule = lambda rule: schema.LifecycleRule -> any {
                """Build a GCP lifecycle rule."""
                result: {str:any} = {
                    action = {}
                    condition = {}
                }
            
                if rule.expirationDays > 0:
                    result.action |= {$type = "Delete"}
                    result.condition |= {age = rule.expirationDays}
                elif rule.transitionDays > 0:
                    result.action |= {
                        $type = "SetStorageClass"
                        storageClass = schema.map_storage_class("gcp", rule.transitionStorageClass)
                    }
                    result.condition |= {age = rule.transitionDays}
            
                if rule.prefix:
                    result.condition |= {matchesPrefix = [rule.prefix]}
            
                result
            }
            
            get_status_gcp = lambda spec: schema.BucketSpec, ocds: any -> schema.BucketStatus {
                """Extract status from observed composed resources."""
                _observed_bucket = ocds.get(spec.name, {})
                _observed_status = _observed_bucket.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _bucket_url = _observed_status.get("url", "")
                _bucket_self_link = _observed_status.get("selfLink", "")
            
                schema.BucketStatus {
                    provider = "gcp"
                    region = spec.region
                    bucketName = spec.name
                    url = _bucket_url if _bucket_url else "gs://${spec.name}"
                    id = spec.name
                    cloudUrl = _bucket_self_link if _bucket_self_link else "https://storage.googleapis.com/${spec.name}"
                }
            }
            """
            AWS RDS resource generation for database composition.
            """
            
            import crossplane_provider_upjet_aws.v1beta2.rds_aws_upbound_io_v1beta2_instance as rds
            import schemas.database as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            
            generate_aws = lambda spec: schema.DatabaseSpec, ocds: any -> [any] {
                """Generate AWS RDS resources from DatabaseSpec."""
                _db_name = spec.region  # use oxr metadata name
                _region = regions.get_aws_region(spec.region) if spec.region else ""
                _instance_class = schema.get_instance_class("aws", spec.size)
                _engine_version = schema.get_engine_version(spec.engine, "aws", spec.engineVersion)
                _storage_type = schema.get_storage_type("aws", spec.storageType)
            
                _label_config = labels.LabelConfig {
                    name = _db_name
                    component = "database"
                    provider = "aws"
                    environment = spec.environment
                }
                _tags = labels.generate_tags(_label_config, "aws") | spec.tags
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # Main RDS Instance using typed schema
                _rds_spec: {str:any} = {
                    forProvider = {
                        region = _region
                        engine = spec.engine
                        engineVersion = _engine_version
                        instanceClass = _instance_class
                        allocatedStorage = spec.storageGB
                        storageType = _storage_type
                        storageEncrypted = True
                        multiAz = spec.multiAZ
                        publiclyAccessible = spec.publiclyAccessible
                        skipFinalSnapshot = spec.environment != "prod"
                        copyTagsToSnapshot = True
                        tags = _tags
                    }
                    deletionPolicy = spec.deletionPolicy
                }
            
                # Add final snapshot identifier for prod
                if spec.environment == "prod":
                    _rds_spec.forProvider |= {
                        finalSnapshotIdentifier = "${_db_name}-final"
                    }
            
                # Add backup configuration
                if spec.backup.enabled:
                    _rds_spec.forProvider |= {
                        backupRetentionPeriod = spec.backup.retentionDays
                        backupWindow = spec.backup.preferredWindow
                    }
            
                # Add password configuration
                if spec.secrets.generatePassword:
                    _rds_spec.forProvider |= {
                        username = "admin"
                        autoGeneratePassword = True
                    }
                    _rds_spec |= {
                        writeConnectionSecretToRef = {
                            name = "${_db_name}-credentials"
                            namespace = "crossplane-system"
                        }
                    }
                elif spec.secrets.passwordSecretRef:
                    _rds_spec.forProvider |= {
                        username = "admin"
                        passwordSecretRef = {
                            name = spec.secrets.passwordSecretRef
                            namespace = "crossplane-system"
                            key = "password"
                        }
                    }
            
                resources += [rds.Instance {
                    metadata = h.metadata_with_labels("${_db_name}-rds", _k8s_labels)
                    spec = _rds_spec
                }]
            
                resources
            }
            
            get_status_aws = lambda spec: schema.DatabaseSpec, ocds: any -> schema.DatabaseStatus {
                """Extract status from observed composed resources."""
                _db_name = spec.region
                _observed_db = ocds.get("${_db_name}-rds", {})
                _observed_status = _observed_db.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _endpoint = _observed_status.get("endpoint", "")
            
                schema.DatabaseStatus {
                    provider = "aws"
                    region = spec.region
                    engine = spec.engine
                    endpoint = _endpoint
                }
            }
            """
            GCP Cloud SQL resource generation for database composition.
            """
            
            import schemas.database as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.common as c
            
            generate_gcp = lambda spec: schema.DatabaseSpec, ocds: any, name: str -> [any] {
                """Generate GCP Cloud SQL resources from DatabaseSpec."""
                _db_name = name
                _region = c.map_region("gcp", spec.region) if spec.region else ""
                _tier = schema.get_instance_class("gcp", spec.size)
                _database_version = _get_gcp_database_version(spec.engine, spec.engineVersion)
            
                _label_config = labels.LabelConfig {
                    name = _db_name
                    component = "database"
                    provider = "gcp"
                    environment = spec.environment
                }
                _user_labels = labels.generate_tags(_label_config, "gcp") | {
                    k.lower().replace("-", "_"): v.lower()
                    for k, v in spec.tags
                    if len(k) <= 63 and len(v) <= 63
                }
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # Build settings
                _settings: {str:any} = {
                    tier = _tier
                    diskSize = spec.storageGB
                    diskType = "PD_SSD"
                    diskAutoresize = True
                    diskAutoresizeLimit = spec.storageGB * 2
                    availabilityType = "REGIONAL" if spec.multiAZ else "ZONAL"
                    userLabels = _user_labels
                    ipConfiguration = {
                        ipv4Enabled = spec.publiclyAccessible
                        requireSsl = True
                    }
                }
            
                # Add backup configuration
                if spec.backup.enabled:
                    _settings |= {
                        backupConfiguration = {
                            enabled = True
                            startTime = spec.backup.preferredWindow.split("-")[0]
                            pointInTimeRecoveryEnabled = True
                            transactionLogRetentionDays = spec.backup.retentionDays
                            backupRetentionSettings = {
                                retainedBackups = spec.backup.retentionDays
                                retentionUnit = "COUNT"
                            }
                        }
                    }
            
                # Main Cloud SQL Instance
                _sql_spec: {str:any} = {
                    forProvider = {
                        region = _region
                        databaseVersion = _database_version
                        deletionProtection = spec.environment == "prod"
                        settings = _settings
                    }
                    deletionPolicy = spec.deletionPolicy
                }
            
                # Add write connection secret if auto-generating password
                if spec.secrets.generatePassword:
                    _sql_spec |= {
                        writeConnectionSecretToRef = {
                            name = "${_db_name}-credentials"
                            namespace = "crossplane-system"
                        }
                    }
            
                resources += [{
                    apiVersion = "sql.gcp.upbound.io/v1beta2"
                    kind = "DatabaseInstance"
                    metadata = h.metadata_with_labels("${_db_name}-cloudsql", _k8s_labels)
                    spec = _sql_spec
                }]
            
                # Create database
                resources += [{
                    apiVersion = "sql.gcp.upbound.io/v1beta1"
                    kind = "Database"
                    metadata = h.metadata_with_labels("${_db_name}-db", _k8s_labels)
                    spec = {
                        forProvider = {
                            instanceSelector = {
                                matchControllerRef = True
                            }
                            charset = "UTF8" if spec.engine == "postgres" else "utf8mb4"
                            collation = "en_US.UTF8" if spec.engine == "postgres" else "utf8mb4_general_ci"
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Create user
                _user_spec: {str:any} = {
                    forProvider = {
                        instanceSelector = {
                            matchControllerRef = True
                        }
                        $type = "BUILT_IN"
                    }
                    deletionPolicy = spec.deletionPolicy
                }
            
                if spec.secrets.generatePassword:
                    _user_spec.forProvider |= {
                        passwordSecretRef = {
                            name = "${_db_name}-user-password"
                            namespace = "crossplane-system"
                            key = "password"
                        }
                    }
                elif spec.secrets.passwordSecretRef:
                    _user_spec.forProvider |= {
                        passwordSecretRef = {
                            name = spec.secrets.passwordSecretRef
                            namespace = "crossplane-system"
                            key = "password"
                        }
                    }
            
                resources += [{
                    apiVersion = "sql.gcp.upbound.io/v1beta1"
                    kind = "User"
                    metadata = h.metadata_with_labels("${_db_name}-user", _k8s_labels)
                    spec = _user_spec
                }]
            
                resources
            }
            
            _get_gcp_database_version = lambda engine: str, version: str -> str {
                """Get the GCP Cloud SQL database version string."""
                if engine == "postgres":
                    "POSTGRES_${version}"
                else:
                    "MYSQL_8_0"
            }
            
            get_status_gcp = lambda spec: schema.DatabaseSpec, ocds: any, name: str -> schema.DatabaseStatus {
                """Extract status from observed composed resources."""
                _db_name = name
                _observed_db = ocds.get("${_db_name}-cloudsql", {})
                _observed_status = _observed_db.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _connection_name = _observed_status.get("connectionName", "")
            
                schema.DatabaseStatus {
                    provider = "gcp"
                    region = spec.region
                    engine = spec.engine
                    endpoint = _connection_name
                }
            }
            """
            Kubernetes CloudNative-PG resource generation for database composition.
            """
            
            import schemas.database as schema
            import schemas.labels as labels
            import schemas.helpers as h
            
            generate_kubernetes = lambda spec: schema.DatabaseSpec, ocds: any, name: str -> [any] {
                """Generate CloudNative-PG Cluster from DatabaseSpec."""
                _db_name = name
                _namespace = spec.namespace
                _resources = schema.get_instance_class("kubernetes", spec.size)
            
                _label_config = labels.LabelConfig {
                    name = _db_name
                    component = "database"
                    provider = "kubernetes"
                    environment = spec.environment
                }
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # CloudNative-PG Cluster
                _cnpg_spec: {str:any} = {
                    instances = spec.instances
                    imageName = "ghcr.io/cloudnative-pg/postgresql:${spec.engineVersion}"
                    postgresql = {
                        parameters = {
                            max_connections = "100"
                            shared_buffers = "128MB"
                        }
                    }
                    bootstrap = {
                        initdb = {
                            database = "app"
                            owner = "app"
                        }
                    }
                    storage = {
                        size = "${spec.storageGB}Gi"
                    }
                    resources = {
                        requests = _resources
                        limits = _resources
                    }
                    monitoring = {
                        enablePodMonitor = spec.environment != "dev"
                    }
                }
            
                # Add backup configuration if enabled
                if spec.backup.enabled:
                    _cnpg_spec |= {
                        backup = {
                            barmanObjectStore = {
                                destinationPath = "s3://${_db_name}-backups/"
                                s3Credentials = {
                                    accessKeyId = {
                                        name = "${_db_name}-backup-creds"
                                        key = "ACCESS_KEY_ID"
                                    }
                                    secretAccessKey = {
                                        name = "${_db_name}-backup-creds"
                                        key = "SECRET_ACCESS_KEY"
                                    }
                                }
                            }
                            retentionPolicy = "${spec.backup.retentionDays}d"
                        }
                    }
            
                resources += [{
                    apiVersion = "postgresql.cnpg.io/v1"
                    kind = "Cluster"
                    metadata = {
                        name = "${_db_name}-cnpg"
                        namespace = _namespace
                        annotations = {
                            "krm.kcl.dev/composition-resource-name" = "${_db_name}-cnpg"
                        }
                        labels = _k8s_labels
                    }
                    spec = _cnpg_spec
                }]
            
                resources
            }
            
            get_status_kubernetes = lambda spec: schema.DatabaseSpec, ocds: any, name: str -> schema.DatabaseStatus {
                """Extract status from observed composed resources."""
                _db_name = name
                _observed_db = ocds.get("${_db_name}-cnpg", {})
                _observed_status = _observed_db.get("Resource", {}).get("status", {}) or {}
            
                _instances_ready = _observed_status.get("instancesReady", 0)
            
                schema.DatabaseStatus {
                    provider = "kubernetes"
                    region = "in-cluster"
                    engine = spec.engine
                    endpoint = "${_db_name}-cnpg-rw.${spec.namespace}.svc.cluster.local:5432" if _instances_ready > 0 else ""
                }
            }
            """
            AWS ECR resource generation for registry composition.
            """
            
            import crossplane_provider_upjet_aws.v1beta2.ecr_aws_upbound_io_v1beta2_repository as ecr
            import crossplane_provider_upjet_aws.v1beta1.ecr_aws_upbound_io_v1beta1_lifecycle_policy as ecr_lifecycle
            import schemas.registry as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            
            generate_aws = lambda spec: schema.RegistrySpec, ocds: any -> [any] {
                """Generate AWS ECR resources from RegistrySpec."""
                _name = spec.name
                _region = regions.get_aws_region(spec.region) if spec.region else ""
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "registry"
                    provider = "aws"
                    environment = spec.environment
                }
                _tags = labels.generate_tags(_label_config, "aws")
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # AWS ECR Repository
                resources += [ecr.Repository {
                    metadata = h.metadata_with_labels("${_name}-ecr", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            imageTagMutability = "IMMUTABLE" if spec.immutableTags else "MUTABLE"
                            imageScanningConfiguration = {
                                scanOnPush = spec.scanOnPush
                            }
                            encryptionConfiguration = [{
                                encryptionType = "AES256"
                            }] if spec.encryption else []
                            tags = _tags
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # AWS ECR Lifecycle Policy for retention
                if spec.retentionDays > 0:
                    resources += [ecr_lifecycle.LifecyclePolicy {
                        metadata = h.metadata_with_labels("${_name}-ecr-lifecycle", _k8s_labels)
                        spec = {
                            forProvider = {
                                region = _region
                                repositorySelector = {
                                    matchControllerRef = True
                                }
                                policy = '''{
                                    "rules": [
                                        {
                                            "rulePriority": 1,
                                            "description": "Expire untagged images older than ''' + str(spec.retentionDays) + ''' days",
                                            "selection": {
                                                "tagStatus": "untagged",
                                                "countType": "sinceImagePushed",
                                                "countUnit": "days",
                                                "countNumber": ''' + str(spec.retentionDays) + '''
                                            },
                                            "action": {
                                                "type": "expire"
                                            }
                                        }
                                    ]
                                }'''
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }]
            
                resources
            }
            
            get_status_aws = lambda spec: schema.RegistrySpec, ocds: any -> schema.RegistryStatus {
                """Extract status from observed composed resources."""
                _observed_ecr = ocds.get("${spec.name}-ecr", {})
                _observed_status = _observed_ecr.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _registry_url = _observed_status.get("repositoryUrl", "")
            
                schema.RegistryStatus {
                    provider = "aws"
                    region = spec.region
                    registryUrl = _registry_url
                    repositoryName = spec.name
                }
            }
            """
            GCP Artifact Registry resource generation for registry composition.
            """
            
            import crossplane_provider_upjet_gcp.v1beta1.artifact_gcp_upbound_io_v1beta1_registry_repository as artifact
            import schemas.registry as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            
            generate_gcp = lambda spec: schema.RegistrySpec, ocds: any -> [any] {
                """Generate GCP Artifact Registry resources from RegistrySpec."""
                _name = spec.name
                _region = regions.get_gcp_region(spec.region) if spec.region else ""
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "registry"
                    provider = "gcp"
                    environment = spec.environment
                }
                _gcp_labels = labels.generate_tags(_label_config, "gcp")
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # GCP Artifact Registry Repository
                resources += [artifact.RegistryRepository {
                    metadata = h.metadata_with_labels("${_name}-artifactregistry", _k8s_labels)
                    spec = {
                        forProvider = {
                            location = _region
                            format = spec.format.upper()
                            mode = "STANDARD_REPOSITORY"
                            labels = _gcp_labels
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                resources
            }
            
            get_status_gcp = lambda spec: schema.RegistrySpec, ocds: any -> schema.RegistryStatus {
                """Extract status from observed composed resources."""
                _observed_artifact = ocds.get("${spec.name}-artifactregistry", {})
                _observed_status = _observed_artifact.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _name = _observed_status.get("name", "")
                _region = spec.region
            
                schema.RegistryStatus {
                    provider = "gcp"
                    region = _region
                    registryUrl = "${_region}-docker.pkg.dev/${_name}" if _name else ""
                    repositoryName = spec.name
                }
            }
            """
            Kubernetes Harbor resource generation for registry composition.
            """
            
            import schemas.registry as schema
            import schemas.labels as labels
            import schemas.helpers as h
            
            generate_kubernetes = lambda spec: schema.RegistrySpec, ocds: any -> [any] {
                """Generate Harbor resources from RegistrySpec."""
                _name = spec.name
                _namespace = spec.namespace
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "registry"
                    provider = "kubernetes"
                    environment = spec.environment
                }
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # Harbor Cluster (using goharbor-operator)
                resources += [{
                    apiVersion = "goharbor.io/v1beta1"
                    kind = "HarborCluster"
                    metadata = {
                        name = "${_name}-harbor"
                        namespace = _namespace
                        annotations = {
                            "krm.kcl.dev/composition-resource-name" = "${_name}-harbor"
                        }
                        labels = _k8s_labels
                    }
                    spec = {
                        version = "2.11.0"
                        externalURL = "https://${_name}-harbor.${_namespace}.svc.cluster.local"
                        expose = {
                            core = {
                                ingress = {
                                    host = "${_name}-harbor.local"
                                }
                            }
                        }
                        database = {
                            kind = "PostgreSQL"
                            spec = {
                                embedded = {}
                            }
                        }
                        storage = {
                            kind = "FileSystem"
                            spec = {
                                fileSystem = {
                                    rootdirectory = "/storage"
                                }
                            }
                        }
                        cache = {
                            kind = "Redis"
                            spec = {
                                embedded = {}
                            }
                        }
                    }
                }]
            
                resources
            }
            
            get_status_kubernetes = lambda spec: schema.RegistrySpec, ocds: any -> schema.RegistryStatus {
                """Extract status from observed composed resources."""
                _observed_harbor = ocds.get("${spec.name}-harbor", {})
                _observed_status = _observed_harbor.get("Resource", {}).get("status", {}) or {}
            
                _external_url = _observed_status.get("externalURL", "")
            
                schema.RegistryStatus {
                    provider = "kubernetes"
                    region = "in-cluster"
                    registryUrl = _external_url if _external_url else "https://${spec.name}-harbor.${spec.namespace}.svc.cluster.local"
                    repositoryName = spec.name
                }
            }
            """
            AWS VPC resource generation for network composition.
            """
            
            import schemas.network as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            import schemas.mappings as m
            
            generate_aws = lambda spec: schema.NetworkSpec, ocds: any -> [any] {
                """Generate AWS VPC resources from NetworkSpec."""
                _name = spec.name
                _region = regions.get_aws_region(spec.region) if spec.region else ""
                _cidr = spec.cidrBlock
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "network"
                    provider = "aws"
                    environment = spec.environment
                }
                _tags = labels.generate_tags(_label_config, "aws")
                _k8s_labels = labels.generate_labels(_label_config)
            
                # Get subnets (use defaults if not provided)
                _subnets = spec.subnets or m.get_default_subnets("aws")
            
                resources: [any] = []
            
                # AWS VPC
                resources += [{
                    apiVersion = "ec2.aws.upbound.io/v1beta1"
                    kind = "VPC"
                    metadata = h.metadata_with_labels("${_name}-vpc", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            cidrBlock = _cidr
                            enableDnsSupport = spec.enableDnsSupport
                            enableDnsHostnames = spec.enableDnsHostnames
                            tags = _tags | {"Name": "${_name}-vpc", "network": _name}
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Internet Gateway
                resources += [{
                    apiVersion = "ec2.aws.upbound.io/v1beta1"
                    kind = "InternetGateway"
                    metadata = h.metadata_with_labels("${_name}-igw", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            vpcIdRef = {
                                name = "${_name}-vpc"
                            }
                            tags = _tags | {"Name": "${_name}-igw", "network": _name}
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Subnets
                resources += [
                    {
                        apiVersion = "ec2.aws.upbound.io/v1beta1"
                        kind = "Subnet"
                        metadata = h.metadata_with_labels("${_name}-${subnet.name}", _k8s_labels | {
                            "crossplane.io/network" = _name
                            "crossplane.io/visibility" = subnet.type
                        })
                        spec = {
                            forProvider = {
                                region = _region
                                cidrBlock = subnet.cidrBlock
                                vpcIdRef = {
                                    name = "${_name}-vpc"
                                }
                                availabilityZone = "${_region}${subnet.availabilityZone}" if subnet.availabilityZone else None
                                mapPublicIpOnLaunch = subnet.type == "public"
                                tags = _tags | {"Name": "${_name}-${subnet.name}", "Type": subnet.type, "network": _name}
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }
                    for subnet in _subnets
                ]
            
                # Public Route Table
                resources += [{
                    apiVersion = "ec2.aws.upbound.io/v1beta1"
                    kind = "RouteTable"
                    metadata = h.metadata_with_labels("${_name}-public-rt", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            vpcIdRef = {
                                name = "${_name}-vpc"
                            }
                            tags = _tags | {"Name": "${_name}-public-rt", "network": _name}
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Route to Internet Gateway
                resources += [{
                    apiVersion = "ec2.aws.upbound.io/v1beta1"
                    kind = "Route"
                    metadata = h.metadata_with_labels("${_name}-public-route", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            routeTableIdRef = {
                                name = "${_name}-public-rt"
                            }
                            destinationCidrBlock = "0.0.0.0/0"
                            gatewayIdRef = {
                                name = "${_name}-igw"
                            }
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Route Table Associations for public subnets
                resources += [
                    {
                        apiVersion = "ec2.aws.upbound.io/v1beta1"
                        kind = "RouteTableAssociation"
                        metadata = h.metadata_with_labels("${_name}-${subnet.name}-rta", _k8s_labels)
                        spec = {
                            forProvider = {
                                region = _region
                                routeTableIdRef = {
                                    name = "${_name}-public-rt"
                                }
                                subnetIdRef = {
                                    name = "${_name}-${subnet.name}"
                                }
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }
                    for subnet in _subnets if subnet.type == "public"
                ]
            
                resources
            }
            
            get_status_aws = lambda spec: schema.NetworkSpec, ocds: any -> schema.NetworkStatus {
                """Extract status from observed composed resources."""
                _observed_vpc = ocds.get("${spec.name}-vpc", {})
                _observed_status = _observed_vpc.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _vpc_id = _observed_status.get("id", "")
            
                schema.NetworkStatus {
                    provider = "aws"
                    region = spec.region
                    networkId = _vpc_id
                    cidrBlock = spec.cidrBlock
                }
            }
            """
            GCP Network resource generation for network composition.
            """
            
            import schemas.network as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            import schemas.mappings as m
            
            generate_gcp = lambda spec: schema.NetworkSpec, ocds: any -> [any] {
                """Generate GCP Network resources from NetworkSpec."""
                _name = spec.name
                _region = regions.get_gcp_region(spec.region) if spec.region else ""
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "network"
                    provider = "gcp"
                    environment = spec.environment
                }
                _k8s_labels = labels.generate_labels(_label_config)
            
                # Get subnets (use defaults if not provided)
                _subnets = spec.subnets or m.get_default_subnets("gcp")
            
                resources: [any] = []
            
                # GCP Network (VPC)
                resources += [{
                    apiVersion = "compute.gcp.upbound.io/v1beta1"
                    kind = "Network"
                    metadata = h.metadata_with_labels("${_name}-network", _k8s_labels)
                    spec = {
                        forProvider = {
                            autoCreateSubnetworks = False
                            routingMode = "REGIONAL"
                            description = "Managed by Crossplane - ${_name}"
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Subnetworks
                resources += [
                    {
                        apiVersion = "compute.gcp.upbound.io/v1beta1"
                        kind = "Subnetwork"
                        metadata = h.metadata_with_labels("${_name}-${subnet.name}", _k8s_labels | {
                            "crossplane.io/network" = _name
                            "crossplane.io/visibility" = subnet.type
                        })
                        spec = {
                            forProvider = {
                                region = _region
                                ipCidrRange = subnet.cidrBlock
                                networkRef = {
                                    name = "${_name}-network"
                                }
                                privateIpGoogleAccess = subnet.type == "private"
                                description = "${subnet.type} subnet - ${subnet.name}"
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }
                    for subnet in _subnets
                ]
            
                # Cloud Router for NAT (if there are private subnets)
                _has_private_subnets = any(subnet.type == "private" for subnet in _subnets)
                if _has_private_subnets:
                    resources += [{
                        apiVersion = "compute.gcp.upbound.io/v1beta1"
                        kind = "Router"
                        metadata = h.metadata_with_labels("${_name}-router", _k8s_labels)
                        spec = {
                            forProvider = {
                                region = _region
                                networkRef = {
                                    name = "${_name}-network"
                                }
                                description = "NAT router for ${_name}"
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }]
            
                    # Cloud NAT for private subnet internet access
                    resources += [{
                        apiVersion = "compute.gcp.upbound.io/v1beta1"
                        kind = "RouterNAT"
                        metadata = h.metadata_with_labels("${_name}-nat", _k8s_labels)
                        spec = {
                            forProvider = {
                                region = _region
                                routerRef = {
                                    name = "${_name}-router"
                                }
                                natIpAllocateOption = "AUTO_ONLY"
                                sourceSubnetworkIpRangesToNat = "ALL_SUBNETWORKS_ALL_IP_RANGES"
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }]
            
                resources
            }
            
            get_status_gcp = lambda spec: schema.NetworkSpec, ocds: any -> schema.NetworkStatus {
                """Extract status from observed composed resources."""
                _observed_network = ocds.get("${spec.name}-network", {})
                _observed_status = _observed_network.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _network_id = _observed_status.get("id", "")
            
                schema.NetworkStatus {
                    provider = "gcp"
                    region = spec.region
                    networkId = _network_id
                    cidrBlock = spec.cidrBlock
                }
            }
            """
            AWS S3 resource generation for bucket composition.
            """
            
            import model.io.upbound.aws.s3.v1beta2 as s3
            import model.io.upbound.aws.s3.v1beta1 as s3v1beta1
            import schemas.bucket as schema
            import schemas.labels as labels
            import schemas.helpers as h
            
            generate_aws = lambda spec: schema.BucketSpec, ocds: any -> [any] {
                """Generate AWS S3 resources from BucketSpec."""
                _bucket_name = spec.name
                _region = spec.region
                _storage_class = schema.map_storage_class("aws", spec.storageClass)
                _deletion_policy = spec.deletionPolicy
            
                _label_config = labels.LabelConfig {
                    name = _bucket_name
                    component = "storage"
                    provider = "aws"
                    environment = spec.environment
                }
                _tags = labels.generate_tags(_label_config, "aws") | spec.tags
            
                resources: [any] = []
            
                # Main S3 Bucket
                resources += [s3.Bucket {
                    metadata = h.metadata(_bucket_name)
                    spec = {
                        forProvider = {
                            region = _region
                            tags = _tags
                        }
                        deletionPolicy = _deletion_policy
                    }
                }]
            
                # Bucket versioning
                if spec.versioning:
                    resources += [s3.BucketVersioning {
                        metadata = h.metadata("${_bucket_name}-versioning")
                        spec = {
                            forProvider = {
                                region = _region
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                versioningConfiguration = {
                                    status = "Enabled"
                                }
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                # Server-side encryption
                if spec.encryption:
                    resources += [s3.BucketServerSideEncryptionConfiguration {
                        metadata = h.metadata("${_bucket_name}-encryption")
                        spec = {
                            forProvider = {
                                region = _region
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                $rule = [{
                                    applyServerSideEncryptionByDefault = {
                                        sseAlgorithm = "AES256"
                                    }
                                    bucketKeyEnabled = True
                                }]
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                # Public access block (default: block all public access)
                resources += [s3v1beta1.BucketPublicAccessBlock {
                    metadata = h.metadata("${_bucket_name}-public-access")
                    spec = {
                        forProvider = {
                            region = _region
                            bucketSelector = {
                                matchControllerRef = True
                            }
                            blockPublicAcls = not spec.publicAccess
                            blockPublicPolicy = not spec.publicAccess
                            ignorePublicAcls = not spec.publicAccess
                            restrictPublicBuckets = not spec.publicAccess
                        }
                        deletionPolicy = _deletion_policy
                    }
                }]
            
                # CORS configuration
                if spec.cors:
                    resources += [{
                        apiVersion = "s3.aws.upbound.io/v1beta1"
                        kind = "BucketCorsConfiguration"
                        metadata = h.metadata("${_bucket_name}-cors")
                        spec = {
                            forProvider = {
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                region = _region
                                corsRule = [
                                    {
                                        allowedOrigins = rule.allowedOrigins
                                        allowedMethods = rule.allowedMethods
                                        allowedHeaders = rule.allowedHeaders
                                        maxAgeSeconds = rule.maxAgeSeconds
                                    }
                                    for rule in spec.cors
                                ]
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                # Lifecycle rules
                if spec.lifecycle:
                    resources += [{
                        apiVersion = "s3.aws.upbound.io/v1beta1"
                        kind = "BucketLifecycleConfiguration"
                        metadata = h.metadata("${_bucket_name}-lifecycle")
                        spec = {
                            forProvider = {
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                region = _region
                                $rule = [
                                    _build_lifecycle_rule(rule)
                                    for rule in spec.lifecycle
                                ]
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                resources
            }
            
            _build_lifecycle_rule = lambda rule: schema.LifecycleRule -> any {
                """Build an AWS S3 lifecycle rule."""
                base: {str:any} = {
                    id = rule.name
                    status = "Enabled" if rule.enabled else "Disabled"
                }
            
                if rule.prefix:
                    base |= {$filter = [{prefix = rule.prefix}]}
            
                if rule.expirationDays > 0:
                    base |= {$expiration = [{days = rule.expirationDays}]}
            
                if rule.transitionDays > 0:
                    base |= {
                        $transition = [{
                            days = rule.transitionDays
                            storageClass = schema.map_storage_class("aws", rule.transitionStorageClass)
                        }]
                    }
            
                base
            }
            
            get_status_aws = lambda spec: schema.BucketSpec, ocds: any -> schema.BucketStatus {
                """Extract status from observed composed resources."""
                _observed_bucket = ocds.get(spec.name, {})
                _observed_status = _observed_bucket.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _bucket_id = _observed_status.get("id", spec.name)
                _bucket_domain = _observed_status.get("bucketRegionalDomainName", "")
            
                schema.BucketStatus {
                    provider = "aws"
                    region = spec.region
                    bucketName = _bucket_id
                    url = "s3://${_bucket_id}"
                    id = _bucket_id
                    cloudUrl = "https://${_bucket_domain}" if _bucket_domain else "https://${spec.name}.s3.${spec.region}.amazonaws.com"
                }
            }
            """
            GCP Cloud Storage resource generation for bucket composition.
            """
            
            import model.io.upbound.gcp.storage.v1beta2 as gcs
            import schemas.bucket as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.common as c
            
            generate_gcp = lambda spec: schema.BucketSpec, ocds: any -> [any] {
                """Generate GCP Cloud Storage resources from BucketSpec."""
                _bucket_name = spec.name
                _location = c.map_region("gcp", spec.region).upper()
                _storage_class = schema.map_storage_class("gcp", spec.storageClass)
                _deletion_policy = spec.deletionPolicy
            
                _label_config = labels.LabelConfig {
                    name = _bucket_name
                    component = "storage"
                    provider = "gcp"
                    environment = spec.environment
                }
                _labels = labels.generate_tags(_label_config, "gcp") | {
                    k.lower().replace("-", "_"): v.lower()
                    for k, v in spec.tags
                    if len(k) <= 63 and len(v) <= 63
                }
            
                resources: [any] = []
            
                # Build bucket forProvider config
                _for_provider: {str:any} = {
                    location = _location
                    storageClass = _storage_class
                    labels = _labels
                    uniformBucketLevelAccess = True
                    publicAccessPrevention = "enforced" if not spec.publicAccess else "inherited"
                }
            
                # Add versioning if enabled
                if spec.versioning:
                    _for_provider |= {
                        versioning = [{
                            enabled = True
                        }]
                    }
            
                # Add CORS rules if specified
                if spec.cors:
                    _for_provider |= {
                        cors = [
                            {
                                origin = rule.allowedOrigins
                                method = rule.allowedMethods
                                responseHeader = rule.allowedHeaders
                                maxAgeSeconds = rule.maxAgeSeconds
                            }
                            for rule in spec.cors
                        ]
                    }
            
                # Add lifecycle rules if specified
                if spec.lifecycle:
                    _for_provider |= {
                        lifecycleRule = [
                            _build_lifecycle_rule(rule)
                            for rule in spec.lifecycle
                        ]
                    }
            
                # Main GCS Bucket
                resources += [gcs.Bucket {
                    metadata = h.metadata(_bucket_name)
                    spec = {
                        forProvider = _for_provider
                        deletionPolicy = _deletion_policy
                    }
                }]
            
                # IAM binding for public access if enabled
                if spec.publicAccess:
                    resources += [{
                        apiVersion = "storage.gcp.upbound.io/v1beta1"
                        kind = "BucketIAMMember"
                        metadata = h.metadata("${_bucket_name}-public-read")
                        spec = {
                            forProvider = {
                                bucketSelector = {
                                    matchControllerRef = True
                                }
                                role = "roles/storage.objectViewer"
                                member = "allUsers"
                            }
                            deletionPolicy = _deletion_policy
                        }
                    }]
            
                resources
            }
            
            _build_lifecycle_rule = lambda rule: schema.LifecycleRule -> any {
                """Build a GCP lifecycle rule."""
                result: {str:any} = {
                    action = {}
                    condition = {}
                }
            
                if rule.expirationDays > 0:
                    result.action |= {$type = "Delete"}
                    result.condition |= {age = rule.expirationDays}
                elif rule.transitionDays > 0:
                    result.action |= {
                        $type = "SetStorageClass"
                        storageClass = schema.map_storage_class("gcp", rule.transitionStorageClass)
                    }
                    result.condition |= {age = rule.transitionDays}
            
                if rule.prefix:
                    result.condition |= {matchesPrefix = [rule.prefix]}
            
                result
            }
            
            get_status_gcp = lambda spec: schema.BucketSpec, ocds: any -> schema.BucketStatus {
                """Extract status from observed composed resources."""
                _observed_bucket = ocds.get(spec.name, {})
                _observed_status = _observed_bucket.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _bucket_url = _observed_status.get("url", "")
                _bucket_self_link = _observed_status.get("selfLink", "")
            
                schema.BucketStatus {
                    provider = "gcp"
                    region = spec.region
                    bucketName = spec.name
                    url = _bucket_url if _bucket_url else "gs://${spec.name}"
                    id = spec.name
                    cloudUrl = _bucket_self_link if _bucket_self_link else "https://storage.googleapis.com/${spec.name}"
                }
            }
            """
            AWS RDS resource generation for database composition.
            """
            
            import crossplane_provider_upjet_aws.v1beta2.rds_aws_upbound_io_v1beta2_instance as rds
            import schemas.database as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            
            generate_aws = lambda spec: schema.DatabaseSpec, ocds: any -> [any] {
                """Generate AWS RDS resources from DatabaseSpec."""
                _db_name = spec.region  # use oxr metadata name
                _region = regions.get_aws_region(spec.region) if spec.region else ""
                _instance_class = schema.get_instance_class("aws", spec.size)
                _engine_version = schema.get_engine_version(spec.engine, "aws", spec.engineVersion)
                _storage_type = schema.get_storage_type("aws", spec.storageType)
            
                _label_config = labels.LabelConfig {
                    name = _db_name
                    component = "database"
                    provider = "aws"
                    environment = spec.environment
                }
                _tags = labels.generate_tags(_label_config, "aws") | spec.tags
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # Main RDS Instance using typed schema
                _rds_spec: {str:any} = {
                    forProvider = {
                        region = _region
                        engine = spec.engine
                        engineVersion = _engine_version
                        instanceClass = _instance_class
                        allocatedStorage = spec.storageGB
                        storageType = _storage_type
                        storageEncrypted = True
                        multiAz = spec.multiAZ
                        publiclyAccessible = spec.publiclyAccessible
                        skipFinalSnapshot = spec.environment != "prod"
                        copyTagsToSnapshot = True
                        tags = _tags
                    }
                    deletionPolicy = spec.deletionPolicy
                }
            
                # Add final snapshot identifier for prod
                if spec.environment == "prod":
                    _rds_spec.forProvider |= {
                        finalSnapshotIdentifier = "${_db_name}-final"
                    }
            
                # Add backup configuration
                if spec.backup.enabled:
                    _rds_spec.forProvider |= {
                        backupRetentionPeriod = spec.backup.retentionDays
                        backupWindow = spec.backup.preferredWindow
                    }
            
                # Add password configuration
                if spec.secrets.generatePassword:
                    _rds_spec.forProvider |= {
                        username = "admin"
                        autoGeneratePassword = True
                    }
                    _rds_spec |= {
                        writeConnectionSecretToRef = {
                            name = "${_db_name}-credentials"
                            namespace = "crossplane-system"
                        }
                    }
                elif spec.secrets.passwordSecretRef:
                    _rds_spec.forProvider |= {
                        username = "admin"
                        passwordSecretRef = {
                            name = spec.secrets.passwordSecretRef
                            namespace = "crossplane-system"
                            key = "password"
                        }
                    }
            
                resources += [rds.Instance {
                    metadata = h.metadata_with_labels("${_db_name}-rds", _k8s_labels)
                    spec = _rds_spec
                }]
            
                resources
            }
            
            get_status_aws = lambda spec: schema.DatabaseSpec, ocds: any -> schema.DatabaseStatus {
                """Extract status from observed composed resources."""
                _db_name = spec.region
                _observed_db = ocds.get("${_db_name}-rds", {})
                _observed_status = _observed_db.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _endpoint = _observed_status.get("endpoint", "")
            
                schema.DatabaseStatus {
                    provider = "aws"
                    region = spec.region
                    engine = spec.engine
                    endpoint = _endpoint
                }
            }
            """
            GCP Cloud SQL resource generation for database composition.
            """
            
            import schemas.database as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.common as c
            
            generate_gcp = lambda spec: schema.DatabaseSpec, ocds: any, name: str -> [any] {
                """Generate GCP Cloud SQL resources from DatabaseSpec."""
                _db_name = name
                _region = c.map_region("gcp", spec.region) if spec.region else ""
                _tier = schema.get_instance_class("gcp", spec.size)
                _database_version = _get_gcp_database_version(spec.engine, spec.engineVersion)
            
                _label_config = labels.LabelConfig {
                    name = _db_name
                    component = "database"
                    provider = "gcp"
                    environment = spec.environment
                }
                _user_labels = labels.generate_tags(_label_config, "gcp") | {
                    k.lower().replace("-", "_"): v.lower()
                    for k, v in spec.tags
                    if len(k) <= 63 and len(v) <= 63
                }
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # Build settings
                _settings: {str:any} = {
                    tier = _tier
                    diskSize = spec.storageGB
                    diskType = "PD_SSD"
                    diskAutoresize = True
                    diskAutoresizeLimit = spec.storageGB * 2
                    availabilityType = "REGIONAL" if spec.multiAZ else "ZONAL"
                    userLabels = _user_labels
                    ipConfiguration = {
                        ipv4Enabled = spec.publiclyAccessible
                        requireSsl = True
                    }
                }
            
                # Add backup configuration
                if spec.backup.enabled:
                    _settings |= {
                        backupConfiguration = {
                            enabled = True
                            startTime = spec.backup.preferredWindow.split("-")[0]
                            pointInTimeRecoveryEnabled = True
                            transactionLogRetentionDays = spec.backup.retentionDays
                            backupRetentionSettings = {
                                retainedBackups = spec.backup.retentionDays
                                retentionUnit = "COUNT"
                            }
                        }
                    }
            
                # Main Cloud SQL Instance
                _sql_spec: {str:any} = {
                    forProvider = {
                        region = _region
                        databaseVersion = _database_version
                        deletionProtection = spec.environment == "prod"
                        settings = _settings
                    }
                    deletionPolicy = spec.deletionPolicy
                }
            
                # Add write connection secret if auto-generating password
                if spec.secrets.generatePassword:
                    _sql_spec |= {
                        writeConnectionSecretToRef = {
                            name = "${_db_name}-credentials"
                            namespace = "crossplane-system"
                        }
                    }
            
                resources += [{
                    apiVersion = "sql.gcp.upbound.io/v1beta2"
                    kind = "DatabaseInstance"
                    metadata = h.metadata_with_labels("${_db_name}-cloudsql", _k8s_labels)
                    spec = _sql_spec
                }]
            
                # Create database
                resources += [{
                    apiVersion = "sql.gcp.upbound.io/v1beta1"
                    kind = "Database"
                    metadata = h.metadata_with_labels("${_db_name}-db", _k8s_labels)
                    spec = {
                        forProvider = {
                            instanceSelector = {
                                matchControllerRef = True
                            }
                            charset = "UTF8" if spec.engine == "postgres" else "utf8mb4"
                            collation = "en_US.UTF8" if spec.engine == "postgres" else "utf8mb4_general_ci"
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Create user
                _user_spec: {str:any} = {
                    forProvider = {
                        instanceSelector = {
                            matchControllerRef = True
                        }
                        $type = "BUILT_IN"
                    }
                    deletionPolicy = spec.deletionPolicy
                }
            
                if spec.secrets.generatePassword:
                    _user_spec.forProvider |= {
                        passwordSecretRef = {
                            name = "${_db_name}-user-password"
                            namespace = "crossplane-system"
                            key = "password"
                        }
                    }
                elif spec.secrets.passwordSecretRef:
                    _user_spec.forProvider |= {
                        passwordSecretRef = {
                            name = spec.secrets.passwordSecretRef
                            namespace = "crossplane-system"
                            key = "password"
                        }
                    }
            
                resources += [{
                    apiVersion = "sql.gcp.upbound.io/v1beta1"
                    kind = "User"
                    metadata = h.metadata_with_labels("${_db_name}-user", _k8s_labels)
                    spec = _user_spec
                }]
            
                resources
            }
            
            _get_gcp_database_version = lambda engine: str, version: str -> str {
                """Get the GCP Cloud SQL database version string."""
                if engine == "postgres":
                    "POSTGRES_${version}"
                else:
                    "MYSQL_8_0"
            }
            
            get_status_gcp = lambda spec: schema.DatabaseSpec, ocds: any, name: str -> schema.DatabaseStatus {
                """Extract status from observed composed resources."""
                _db_name = name
                _observed_db = ocds.get("${_db_name}-cloudsql", {})
                _observed_status = _observed_db.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _connection_name = _observed_status.get("connectionName", "")
            
                schema.DatabaseStatus {
                    provider = "gcp"
                    region = spec.region
                    engine = spec.engine
                    endpoint = _connection_name
                }
            }
            """
            Kubernetes CloudNative-PG resource generation for database composition.
            """
            
            import schemas.database as schema
            import schemas.labels as labels
            import schemas.helpers as h
            
            generate_kubernetes = lambda spec: schema.DatabaseSpec, ocds: any, name: str -> [any] {
                """Generate CloudNative-PG Cluster from DatabaseSpec."""
                _db_name = name
                _namespace = spec.namespace
                _resources = schema.get_instance_class("kubernetes", spec.size)
            
                _label_config = labels.LabelConfig {
                    name = _db_name
                    component = "database"
                    provider = "kubernetes"
                    environment = spec.environment
                }
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # CloudNative-PG Cluster
                _cnpg_spec: {str:any} = {
                    instances = spec.instances
                    imageName = "ghcr.io/cloudnative-pg/postgresql:${spec.engineVersion}"
                    postgresql = {
                        parameters = {
                            max_connections = "100"
                            shared_buffers = "128MB"
                        }
                    }
                    bootstrap = {
                        initdb = {
                            database = "app"
                            owner = "app"
                        }
                    }
                    storage = {
                        size = "${spec.storageGB}Gi"
                    }
                    resources = {
                        requests = _resources
                        limits = _resources
                    }
                    monitoring = {
                        enablePodMonitor = spec.environment != "dev"
                    }
                }
            
                # Add backup configuration if enabled
                if spec.backup.enabled:
                    _cnpg_spec |= {
                        backup = {
                            barmanObjectStore = {
                                destinationPath = "s3://${_db_name}-backups/"
                                s3Credentials = {
                                    accessKeyId = {
                                        name = "${_db_name}-backup-creds"
                                        key = "ACCESS_KEY_ID"
                                    }
                                    secretAccessKey = {
                                        name = "${_db_name}-backup-creds"
                                        key = "SECRET_ACCESS_KEY"
                                    }
                                }
                            }
                            retentionPolicy = "${spec.backup.retentionDays}d"
                        }
                    }
            
                resources += [{
                    apiVersion = "postgresql.cnpg.io/v1"
                    kind = "Cluster"
                    metadata = {
                        name = "${_db_name}-cnpg"
                        namespace = _namespace
                        annotations = {
                            "krm.kcl.dev/composition-resource-name" = "${_db_name}-cnpg"
                        }
                        labels = _k8s_labels
                    }
                    spec = _cnpg_spec
                }]
            
                resources
            }
            
            get_status_kubernetes = lambda spec: schema.DatabaseSpec, ocds: any, name: str -> schema.DatabaseStatus {
                """Extract status from observed composed resources."""
                _db_name = name
                _observed_db = ocds.get("${_db_name}-cnpg", {})
                _observed_status = _observed_db.get("Resource", {}).get("status", {}) or {}
            
                _instances_ready = _observed_status.get("instancesReady", 0)
            
                schema.DatabaseStatus {
                    provider = "kubernetes"
                    region = "in-cluster"
                    engine = spec.engine
                    endpoint = "${_db_name}-cnpg-rw.${spec.namespace}.svc.cluster.local:5432" if _instances_ready > 0 else ""
                }
            }
            """
            AWS ECR resource generation for registry composition.
            """
            
            import crossplane_provider_upjet_aws.v1beta2.ecr_aws_upbound_io_v1beta2_repository as ecr
            import crossplane_provider_upjet_aws.v1beta1.ecr_aws_upbound_io_v1beta1_lifecycle_policy as ecr_lifecycle
            import schemas.registry as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            
            generate_aws = lambda spec: schema.RegistrySpec, ocds: any -> [any] {
                """Generate AWS ECR resources from RegistrySpec."""
                _name = spec.name
                _region = regions.get_aws_region(spec.region) if spec.region else ""
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "registry"
                    provider = "aws"
                    environment = spec.environment
                }
                _tags = labels.generate_tags(_label_config, "aws")
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # AWS ECR Repository
                resources += [ecr.Repository {
                    metadata = h.metadata_with_labels("${_name}-ecr", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            imageTagMutability = "IMMUTABLE" if spec.immutableTags else "MUTABLE"
                            imageScanningConfiguration = {
                                scanOnPush = spec.scanOnPush
                            }
                            encryptionConfiguration = [{
                                encryptionType = "AES256"
                            }] if spec.encryption else []
                            tags = _tags
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # AWS ECR Lifecycle Policy for retention
                if spec.retentionDays > 0:
                    resources += [ecr_lifecycle.LifecyclePolicy {
                        metadata = h.metadata_with_labels("${_name}-ecr-lifecycle", _k8s_labels)
                        spec = {
                            forProvider = {
                                region = _region
                                repositorySelector = {
                                    matchControllerRef = True
                                }
                                policy = '''{
                                    "rules": [
                                        {
                                            "rulePriority": 1,
                                            "description": "Expire untagged images older than ''' + str(spec.retentionDays) + ''' days",
                                            "selection": {
                                                "tagStatus": "untagged",
                                                "countType": "sinceImagePushed",
                                                "countUnit": "days",
                                                "countNumber": ''' + str(spec.retentionDays) + '''
                                            },
                                            "action": {
                                                "type": "expire"
                                            }
                                        }
                                    ]
                                }'''
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }]
            
                resources
            }
            
            get_status_aws = lambda spec: schema.RegistrySpec, ocds: any -> schema.RegistryStatus {
                """Extract status from observed composed resources."""
                _observed_ecr = ocds.get("${spec.name}-ecr", {})
                _observed_status = _observed_ecr.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _registry_url = _observed_status.get("repositoryUrl", "")
            
                schema.RegistryStatus {
                    provider = "aws"
                    region = spec.region
                    registryUrl = _registry_url
                    repositoryName = spec.name
                }
            }
            """
            GCP Artifact Registry resource generation for registry composition.
            """
            
            import crossplane_provider_upjet_gcp.v1beta1.artifact_gcp_upbound_io_v1beta1_registry_repository as artifact
            import schemas.registry as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            
            generate_gcp = lambda spec: schema.RegistrySpec, ocds: any -> [any] {
                """Generate GCP Artifact Registry resources from RegistrySpec."""
                _name = spec.name
                _region = regions.get_gcp_region(spec.region) if spec.region else ""
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "registry"
                    provider = "gcp"
                    environment = spec.environment
                }
                _gcp_labels = labels.generate_tags(_label_config, "gcp")
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # GCP Artifact Registry Repository
                resources += [artifact.RegistryRepository {
                    metadata = h.metadata_with_labels("${_name}-artifactregistry", _k8s_labels)
                    spec = {
                        forProvider = {
                            location = _region
                            format = spec.format.upper()
                            mode = "STANDARD_REPOSITORY"
                            labels = _gcp_labels
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                resources
            }
            
            get_status_gcp = lambda spec: schema.RegistrySpec, ocds: any -> schema.RegistryStatus {
                """Extract status from observed composed resources."""
                _observed_artifact = ocds.get("${spec.name}-artifactregistry", {})
                _observed_status = _observed_artifact.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _name = _observed_status.get("name", "")
                _region = spec.region
            
                schema.RegistryStatus {
                    provider = "gcp"
                    region = _region
                    registryUrl = "${_region}-docker.pkg.dev/${_name}" if _name else ""
                    repositoryName = spec.name
                }
            }
            """
            Kubernetes Harbor resource generation for registry composition.
            """
            
            import schemas.registry as schema
            import schemas.labels as labels
            import schemas.helpers as h
            
            generate_kubernetes = lambda spec: schema.RegistrySpec, ocds: any -> [any] {
                """Generate Harbor resources from RegistrySpec."""
                _name = spec.name
                _namespace = spec.namespace
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "registry"
                    provider = "kubernetes"
                    environment = spec.environment
                }
                _k8s_labels = labels.generate_labels(_label_config)
            
                resources: [any] = []
            
                # Harbor Cluster (using goharbor-operator)
                resources += [{
                    apiVersion = "goharbor.io/v1beta1"
                    kind = "HarborCluster"
                    metadata = {
                        name = "${_name}-harbor"
                        namespace = _namespace
                        annotations = {
                            "krm.kcl.dev/composition-resource-name" = "${_name}-harbor"
                        }
                        labels = _k8s_labels
                    }
                    spec = {
                        version = "2.11.0"
                        externalURL = "https://${_name}-harbor.${_namespace}.svc.cluster.local"
                        expose = {
                            core = {
                                ingress = {
                                    host = "${_name}-harbor.local"
                                }
                            }
                        }
                        database = {
                            kind = "PostgreSQL"
                            spec = {
                                embedded = {}
                            }
                        }
                        storage = {
                            kind = "FileSystem"
                            spec = {
                                fileSystem = {
                                    rootdirectory = "/storage"
                                }
                            }
                        }
                        cache = {
                            kind = "Redis"
                            spec = {
                                embedded = {}
                            }
                        }
                    }
                }]
            
                resources
            }
            
            get_status_kubernetes = lambda spec: schema.RegistrySpec, ocds: any -> schema.RegistryStatus {
                """Extract status from observed composed resources."""
                _observed_harbor = ocds.get("${spec.name}-harbor", {})
                _observed_status = _observed_harbor.get("Resource", {}).get("status", {}) or {}
            
                _external_url = _observed_status.get("externalURL", "")
            
                schema.RegistryStatus {
                    provider = "kubernetes"
                    region = "in-cluster"
                    registryUrl = _external_url if _external_url else "https://${spec.name}-harbor.${spec.namespace}.svc.cluster.local"
                    repositoryName = spec.name
                }
            }
            """
            AWS VPC resource generation for network composition.
            """
            
            import schemas.network as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            import schemas.mappings as m
            
            generate_aws = lambda spec: schema.NetworkSpec, ocds: any -> [any] {
                """Generate AWS VPC resources from NetworkSpec."""
                _name = spec.name
                _region = regions.get_aws_region(spec.region) if spec.region else ""
                _cidr = spec.cidrBlock
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "network"
                    provider = "aws"
                    environment = spec.environment
                }
                _tags = labels.generate_tags(_label_config, "aws")
                _k8s_labels = labels.generate_labels(_label_config)
            
                # Get subnets (use defaults if not provided)
                _subnets = spec.subnets or m.get_default_subnets("aws")
            
                resources: [any] = []
            
                # AWS VPC
                resources += [{
                    apiVersion = "ec2.aws.upbound.io/v1beta1"
                    kind = "VPC"
                    metadata = h.metadata_with_labels("${_name}-vpc", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            cidrBlock = _cidr
                            enableDnsSupport = spec.enableDnsSupport
                            enableDnsHostnames = spec.enableDnsHostnames
                            tags = _tags | {"Name": "${_name}-vpc", "network": _name}
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Internet Gateway
                resources += [{
                    apiVersion = "ec2.aws.upbound.io/v1beta1"
                    kind = "InternetGateway"
                    metadata = h.metadata_with_labels("${_name}-igw", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            vpcIdRef = {
                                name = "${_name}-vpc"
                            }
                            tags = _tags | {"Name": "${_name}-igw", "network": _name}
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Subnets
                resources += [
                    {
                        apiVersion = "ec2.aws.upbound.io/v1beta1"
                        kind = "Subnet"
                        metadata = h.metadata_with_labels("${_name}-${subnet.name}", _k8s_labels | {
                            "crossplane.io/network" = _name
                            "crossplane.io/visibility" = subnet.type
                        })
                        spec = {
                            forProvider = {
                                region = _region
                                cidrBlock = subnet.cidrBlock
                                vpcIdRef = {
                                    name = "${_name}-vpc"
                                }
                                availabilityZone = "${_region}${subnet.availabilityZone}" if subnet.availabilityZone else None
                                mapPublicIpOnLaunch = subnet.type == "public"
                                tags = _tags | {"Name": "${_name}-${subnet.name}", "Type": subnet.type, "network": _name}
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }
                    for subnet in _subnets
                ]
            
                # Public Route Table
                resources += [{
                    apiVersion = "ec2.aws.upbound.io/v1beta1"
                    kind = "RouteTable"
                    metadata = h.metadata_with_labels("${_name}-public-rt", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            vpcIdRef = {
                                name = "${_name}-vpc"
                            }
                            tags = _tags | {"Name": "${_name}-public-rt", "network": _name}
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Route to Internet Gateway
                resources += [{
                    apiVersion = "ec2.aws.upbound.io/v1beta1"
                    kind = "Route"
                    metadata = h.metadata_with_labels("${_name}-public-route", _k8s_labels)
                    spec = {
                        forProvider = {
                            region = _region
                            routeTableIdRef = {
                                name = "${_name}-public-rt"
                            }
                            destinationCidrBlock = "0.0.0.0/0"
                            gatewayIdRef = {
                                name = "${_name}-igw"
                            }
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Route Table Associations for public subnets
                resources += [
                    {
                        apiVersion = "ec2.aws.upbound.io/v1beta1"
                        kind = "RouteTableAssociation"
                        metadata = h.metadata_with_labels("${_name}-${subnet.name}-rta", _k8s_labels)
                        spec = {
                            forProvider = {
                                region = _region
                                routeTableIdRef = {
                                    name = "${_name}-public-rt"
                                }
                                subnetIdRef = {
                                    name = "${_name}-${subnet.name}"
                                }
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }
                    for subnet in _subnets if subnet.type == "public"
                ]
            
                resources
            }
            
            get_status_aws = lambda spec: schema.NetworkSpec, ocds: any -> schema.NetworkStatus {
                """Extract status from observed composed resources."""
                _observed_vpc = ocds.get("${spec.name}-vpc", {})
                _observed_status = _observed_vpc.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _vpc_id = _observed_status.get("id", "")
            
                schema.NetworkStatus {
                    provider = "aws"
                    region = spec.region
                    networkId = _vpc_id
                    cidrBlock = spec.cidrBlock
                }
            }
            """
            GCP Network resource generation for network composition.
            """
            
            import schemas.network as schema
            import schemas.labels as labels
            import schemas.helpers as h
            import schemas.regions as regions
            import schemas.mappings as m
            
            generate_gcp = lambda spec: schema.NetworkSpec, ocds: any -> [any] {
                """Generate GCP Network resources from NetworkSpec."""
                _name = spec.name
                _region = regions.get_gcp_region(spec.region) if spec.region else ""
            
                _label_config = labels.LabelConfig {
                    name = _name
                    component = "network"
                    provider = "gcp"
                    environment = spec.environment
                }
                _k8s_labels = labels.generate_labels(_label_config)
            
                # Get subnets (use defaults if not provided)
                _subnets = spec.subnets or m.get_default_subnets("gcp")
            
                resources: [any] = []
            
                # GCP Network (VPC)
                resources += [{
                    apiVersion = "compute.gcp.upbound.io/v1beta1"
                    kind = "Network"
                    metadata = h.metadata_with_labels("${_name}-network", _k8s_labels)
                    spec = {
                        forProvider = {
                            autoCreateSubnetworks = False
                            routingMode = "REGIONAL"
                            description = "Managed by Crossplane - ${_name}"
                        }
                        deletionPolicy = spec.deletionPolicy
                    }
                }]
            
                # Subnetworks
                resources += [
                    {
                        apiVersion = "compute.gcp.upbound.io/v1beta1"
                        kind = "Subnetwork"
                        metadata = h.metadata_with_labels("${_name}-${subnet.name}", _k8s_labels | {
                            "crossplane.io/network" = _name
                            "crossplane.io/visibility" = subnet.type
                        })
                        spec = {
                            forProvider = {
                                region = _region
                                ipCidrRange = subnet.cidrBlock
                                networkRef = {
                                    name = "${_name}-network"
                                }
                                privateIpGoogleAccess = subnet.type == "private"
                                description = "${subnet.type} subnet - ${subnet.name}"
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }
                    for subnet in _subnets
                ]
            
                # Cloud Router for NAT (if there are private subnets)
                _has_private_subnets = any(subnet.type == "private" for subnet in _subnets)
                if _has_private_subnets:
                    resources += [{
                        apiVersion = "compute.gcp.upbound.io/v1beta1"
                        kind = "Router"
                        metadata = h.metadata_with_labels("${_name}-router", _k8s_labels)
                        spec = {
                            forProvider = {
                                region = _region
                                networkRef = {
                                    name = "${_name}-network"
                                }
                                description = "NAT router for ${_name}"
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }]
            
                    # Cloud NAT for private subnet internet access
                    resources += [{
                        apiVersion = "compute.gcp.upbound.io/v1beta1"
                        kind = "RouterNAT"
                        metadata = h.metadata_with_labels("${_name}-nat", _k8s_labels)
                        spec = {
                            forProvider = {
                                region = _region
                                routerRef = {
                                    name = "${_name}-router"
                                }
                                natIpAllocateOption = "AUTO_ONLY"
                                sourceSubnetworkIpRangesToNat = "ALL_SUBNETWORKS_ALL_IP_RANGES"
                            }
                            deletionPolicy = spec.deletionPolicy
                        }
                    }]
            
                resources
            }
            
            get_status_gcp = lambda spec: schema.NetworkSpec, ocds: any -> schema.NetworkStatus {
                """Extract status from observed composed resources."""
                _observed_network = ocds.get("${spec.name}-network", {})
                _observed_status = _observed_network.get("Resource", {}).get("status", {}).get("atProvider", {})
            
                _network_id = _observed_status.get("id", "")
            
                schema.NetworkStatus {
                    provider = "gcp"
                    region = spec.region
                    networkId = _network_id
                    cidrBlock = spec.cidrBlock
                }
            }
            
            # --- Main Orchestrator ---
            """
            Multi-provider network composition.
            Creates AWS VPC or GCP Network with subnets based on provider field.
            Uses modular provider implementations for clean separation.
            """
            
            import schemas.network as schema
            import schemas.regions as regions
            
            # Crossplane function inputs
            oxr = option("params").oxr
            _ocds = option("params").ocds or {}
            dxr = option("params").dxr
            dcds = option("params").dcds
            
            # Type-annotated spec extraction
            _raw_spec = oxr.spec
            
            # Parse subnets if provided
            _subnets = [
                schema.SubnetSpec {
                    name = s.name
                    cidrBlock = s.cidrBlock
                    type = s.type or "private"
                    availabilityZone = s.availabilityZone if s.availabilityZone else None
                }
                for s in _raw_spec.subnets
            ] if _raw_spec.subnets else None
            
            _spec: schema.NetworkSpec = schema.NetworkSpec {
                provider = _raw_spec.provider
                name = _raw_spec.name
                region = _raw_spec.region or "europe-west1"
                cidrBlock = _raw_spec.cidrBlock or "10.0.0.0/16"
                subnets = _subnets
                enableDnsSupport = _raw_spec.enableDnsSupport if _raw_spec.enableDnsSupport != None else True
                enableDnsHostnames = _raw_spec.enableDnsHostnames if _raw_spec.enableDnsHostnames != None else True
                environment = _raw_spec.environment or "dev"
                deletionPolicy = _raw_spec.deletionPolicy or "Delete"
            }
            
            # Generate provider-specific resources
            _resources = generate_aws(_spec, _ocds) if _spec.provider == "aws" else generate_gcp(_spec, _ocds)
            
            # Get provider-specific status
            _status = get_status_aws(_spec, _ocds) if _spec.provider == "aws" else get_status_gcp(_spec, _ocds)
            
            # Update composite resource status
            _dxr = {
                **oxr
                status = {
                    provider = _status.provider
                    region = _status.region
                    networkId = _status.networkId
                    cidrBlock = _status.cidrBlock
                }
            }
            
            # Output items
            items = _resources + [_dxr]
    - step: auto-ready
      functionRef:
        name: function-auto-ready
