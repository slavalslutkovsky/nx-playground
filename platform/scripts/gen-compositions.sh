#!/usr/bin/env bash
# Generate composition.yaml files with inline KCL source
# This embeds the KCL code directly in the composition while pulling dependencies from OCI

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PLATFORM_DIR="$(dirname "$SCRIPT_DIR")"

# Schema version to use for dependencies
SCHEMA_VERSION="${SCHEMA_VERSION:-0.0.1}"
REGISTRY="${REGISTRY:-docker.io/yurikrupnik}"

# Function to generate a composition with inline KCL
generate_composition() {
    local func_name="$1"
    local xrd_name="$2"
    local xrd_group="$3"
    local xrd_kind="$4"
    local api_version="$5"
    local composition_name="$6"  # Explicit composition name

    local func_dir="$PLATFORM_DIR/functions/$func_name"
    local output_file="$PLATFORM_DIR/apis/$xrd_name/composition.yaml"
    local main_k="$func_dir/main.k"
    local kcl_mod="$func_dir/kcl.mod"

    if [[ ! -f "$main_k" ]]; then
        echo "Warning: $main_k not found, skipping"
        return
    fi

    echo "Generating $output_file from $main_k"

    # Read the KCL source and transform imports for OCI dependencies
    # Replace local path imports with OCI-compatible module names
    local kcl_source
    kcl_source=$(cat "$main_k" | sed 's/import models\./import model./g')

    # Extract non-path dependencies from kcl.mod [dependencies] section
    # These are version-based deps like: crossplane-provider-upjet-aws = "1.23.0"
    local extra_deps=""
    if [[ -f "$kcl_mod" ]]; then
        # Extract lines with version-only deps (e.g., foo = "1.2.3"), excluding path/oci refs
        extra_deps=$(sed -n '/^\[dependencies\]/,/^\[/p' "$kcl_mod" | \
            grep -E '^[a-zA-Z].*=.*"[0-9]' | \
            grep -v 'path\s*=' | \
            grep -v 'oci\s*=' | \
            sed 's/^/            /' || true)
    fi

    # Generate the composition YAML
    cat > "$output_file" << EOF
apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: ${composition_name}
  labels:
    crossplane.io/xrd: ${xrd_name}.${xrd_group}
spec:
  compositeTypeRef:
    apiVersion: ${api_version}
    kind: ${xrd_kind}
  mode: Pipeline
  pipeline:
    - step: ${func_name}
      functionRef:
        name: function-kcl
      input:
        apiVersion: krm.kcl.dev/v1alpha1
        kind: KCLRun
        metadata:
          name: ${func_name}
        spec:
          target: Default
          # OCI dependencies - models generated by 'up project generate', schemas published to registry
          dependencies: |
            model = { oci = "oci://${REGISTRY}/platform-models", tag = "${SCHEMA_VERSION}" }
            schemas = { oci = "oci://${REGISTRY}/platform-schemas", tag = "${SCHEMA_VERSION}" }
${extra_deps}
          source: |
$(echo "$kcl_source" | sed 's/^/            /')
    - step: auto-ready
      functionRef:
        name: function-auto-ready
EOF
}

# Generate all compositions
echo "Generating compositions with inline KCL (deps from OCI)..."
echo "Using REGISTRY=${REGISTRY}, SCHEMA_VERSION=${SCHEMA_VERSION}"

generate_composition "compose-bucket" "xbuckets" "storage.platform.io" "XBucket" "storage.platform.io/v1alpha1" "xbucket"
generate_composition "compose-database" "xdatabases" "database.platform.io" "XDatabase" "database.platform.io/v1alpha1" "xdatabase"
generate_composition "compose-registry" "xregistries" "registry.platform.io" "XRegistry" "registry.platform.io/v1alpha1" "xregistry"
generate_composition "compose-application" "xapplications" "platform.io" "XApplication" "platform.io/v1alpha1" "xapplication"
generate_composition "compose-network" "xnetworks" "network.platform.io" "XNetwork" "network.platform.io/v1alpha1" "xnetwork"

echo "Done! Compositions generated with inline KCL source."
echo ""
echo "Note: Ensure these OCI packages are published:"
echo "  - ${REGISTRY}/platform-models:${SCHEMA_VERSION}"
echo "  - ${REGISTRY}/platform-schemas:${SCHEMA_VERSION}"
