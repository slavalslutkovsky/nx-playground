#!/usr/bin/env bash
# Generate composition.yaml files with inline KCL source
# This embeds the KCL code directly in the composition while pulling dependencies from OCI

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PLATFORM_DIR="$(dirname "$SCRIPT_DIR")"

# Schema version to use for dependencies
SCHEMA_VERSION="${SCHEMA_VERSION:-0.0.1}"
REGISTRY="${REGISTRY:-docker.io/yurikrupnik}"

# Function to generate a composition with inline KCL
generate_composition() {
    local func_name="$1"
    local xrd_name="$2"
    local xrd_group="$3"
    local xrd_kind="$4"
    local api_version="$5"
    local composition_name="$6"  # Explicit composition name

    local func_dir="$PLATFORM_DIR/functions/$func_name"
    local output_file="$PLATFORM_DIR/apis/$xrd_name/composition.yaml"
    local main_k="$func_dir/main.k"
    local kcl_mod="$func_dir/kcl.mod"

    if [[ ! -f "$main_k" ]]; then
        echo "Warning: $main_k not found, skipping"
        return
    fi

    echo "Generating $output_file from $main_k"

    # Read the KCL source and transform imports for OCI dependencies
    # Replace local path imports with OCI-compatible module names
    # Also inline provider files for modular compositions
    local kcl_source
    local func_dir_path="$func_dir"

    # Check if this function has providers directory
    if [[ -d "$func_dir/providers" ]]; then
        # Concatenate main.k with provider files, removing relative provider imports
        kcl_source=""

        # First, add provider files
        for provider_file in "$func_dir"/providers/*.k; do
            if [[ -f "$provider_file" ]]; then
                provider_name=$(basename "$provider_file" .k)
                kcl_source+="# --- Provider: $provider_name ---"$'\n'
                # Replace relative imports with absolute and add namespace
                cat "$provider_file" | \
                    sed 's/import models\./import model./g' | \
                    sed "s/import schemas\./import schemas./g" | \
                    sed "s/^generate = lambda/generate_${provider_name} = lambda/g" | \
                    sed "s/^get_status = lambda/get_status_${provider_name} = lambda/g" >> /tmp/provider_content.k
                kcl_source+=$(cat /tmp/provider_content.k)
                kcl_source+=$'\n\n'
            fi
        done

        # Then add main.k, removing provider imports and transforming calls
        main_content=$(cat "$main_k" | \
            sed 's/import models\./import model./g' | \
            sed '/^import \.providers\./d' | \
            sed 's/aws\.generate/generate_aws/g' | \
            sed 's/gcp\.generate/generate_gcp/g' | \
            sed 's/k8s\.generate/generate_kubernetes/g' | \
            sed 's/aws\.get_status/get_status_aws/g' | \
            sed 's/gcp\.get_status/get_status_gcp/g' | \
            sed 's/k8s\.get_status/get_status_kubernetes/g')
        kcl_source+="# --- Main Orchestrator ---"$'\n'
        kcl_source+="$main_content"
    else
        # No providers directory, use original simple approach
        kcl_source=$(cat "$main_k" | sed 's/import models\./import model./g')
    fi

    # Extract non-path dependencies from kcl.mod [dependencies] section
    # These are version-based deps like: crossplane-provider-upjet-aws = "1.23.0"
    local extra_deps=""
    if [[ -f "$kcl_mod" ]]; then
        # Extract lines with version-only deps (e.g., foo = "1.2.3"), excluding path/oci refs
        extra_deps=$(sed -n '/^\[dependencies\]/,/^\[/p' "$kcl_mod" | \
            grep -E '^[a-zA-Z].*=.*"[0-9]' | \
            grep -v 'path\s*=' | \
            grep -v 'oci\s*=' | \
            sed 's/^/            /' || true)
    fi

    # Generate the composition YAML
    cat > "$output_file" << EOF
apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: ${composition_name}
  labels:
    crossplane.io/xrd: ${xrd_name}.${xrd_group}
spec:
  compositeTypeRef:
    apiVersion: ${api_version}
    kind: ${xrd_kind}
  mode: Pipeline
  pipeline:
    - step: ${func_name}
      functionRef:
        name: function-kcl
      input:
        apiVersion: krm.kcl.dev/v1alpha1
        kind: KCLRun
        metadata:
          name: ${func_name}
        spec:
          target: Default
          # OCI dependencies - models generated by 'up project generate', schemas published to registry
          dependencies: |
            model = { oci = "oci://${REGISTRY}/platform-models", tag = "${SCHEMA_VERSION}" }
            schemas = { oci = "oci://${REGISTRY}/platform-schemas", tag = "${SCHEMA_VERSION}" }
${extra_deps}
          source: |
$(echo "$kcl_source" | sed 's/^/            /')
    - step: auto-ready
      functionRef:
        name: function-auto-ready
EOF
}

# Generate all compositions
echo "Generating compositions with inline KCL (deps from OCI)..."
echo "Using REGISTRY=${REGISTRY}, SCHEMA_VERSION=${SCHEMA_VERSION}"

generate_composition "compose-bucket" "xbuckets" "storage.platform.io" "XBucket" "storage.platform.io/v1alpha1" "xbucket"
generate_composition "compose-database" "xdatabases" "database.platform.io" "XDatabase" "database.platform.io/v1alpha1" "xdatabase"
generate_composition "compose-registry" "xregistries" "registry.platform.io" "XRegistry" "registry.platform.io/v1alpha1" "xregistry"
generate_composition "compose-application" "xapplications" "platform.io" "XApplication" "platform.io/v1alpha1" "xapplication"
generate_composition "compose-network" "xnetworks" "network.platform.io" "XNetwork" "network.platform.io/v1alpha1" "xnetwork"

echo "Done! Compositions generated with inline KCL source."
echo ""
echo "Note: Ensure these OCI packages are published:"
echo "  - ${REGISTRY}/platform-models:${SCHEMA_VERSION}"
echo "  - ${REGISTRY}/platform-schemas:${SCHEMA_VERSION}"
